{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduzione BSD e Linux sono entrambi sistemi Unix-like, sistemi che discendono o si ispirano a Unix, il sistema operativo sviluppato per la prima volta negli anni '60 dai Bell Labs, parte di AT&T, la compagnia telefonica americana. POSIX (Portable Operating System Interface) \u00e8 uno standard che definisce l'insieme minimo di funzionalit\u00e0, comandi e interfacce, nonch\u00e9 la struttura delle directory, che un sistema deve implementare per essere considerato un sistema Unix. UNIX Dal 1964 al 1968 : MULTICS (MULTiplexed Information and Computing Service) \u00e8 sviluppato per MIT, Bell Labs (AT&T) e General Electric. 1969 : Dopo il ritiro della Bell (1969) e poi della General Electric dal progetto, due sviluppatori (Ken Thompson e Dennis Ritchie), affiancati in seguito da Brian Kernighan, giudicando MULTICS troppo complesso, lanciano lo sviluppo di UNIX (UNiplexed Information and Computing Service). Originariamente sviluppato in assembler, i progettisti di UNIX hanno sviluppato il linguaggio B e poi il linguaggio C (1971) e hanno completamente riscritto UNIX. Essendo stato sviluppato nel 1970, la data di riferimento dei sistemi UNIX/Linux \u00e8 ancora fissata al 1\u00b0 gennaio 1970. Il linguaggio C \u00e8 ancora oggi uno dei linguaggi di programmazione pi\u00f9 popolari! Linguaggio di basso livello, vicino all'hardware, consente l'adattamento del sistema operativo a qualsiasi architettura di macchina dotata di compilatore C. UNIX \u00e8 un sistema operativo aperto e in evoluzione che ha svolto un ruolo importante nella storia dell'informatica. \u00c8 stata la base per molti altri sistemi: Linux, BSD, Mac OSX, ecc. UNIX \u00e8 ancora rilevante oggi (HP-UX, AIX, Solaris, etc.) Minix 1987 : AS Tanenbaum sviluppa MINIX, un UNIX semplificato, per insegnare i sistemi operativi in \u200b\u200bmodo semplice. Mr. Tanenbaum mette a disposizione il codice sorgente del suo sistema operativo. Linux 1991 : Uno studente finlandese, Linus Torvalds , crea un sistema operativo dedicato al suo personal computer e lo chiama Linux. Pubblica la sua prima versione 0.02, sul forum di discussione Usenet e altri sviluppatori vengono ad aiutarlo a migliorare il suo sistema. Il termine Linux \u00e8 un gioco di parole tra il nome del fondatore, Linus, e UNIX. 1993 : Viene creata la distribuzione Debian. Debian \u00e8 una distribuzione non commerciale, basata sulla comunit\u00e0. Sviluppato originariamente per essere utilizzato su server, \u00e8 particolarmente adatto a questo ruolo, ma \u00e8 pensato per essere un sistema universale e quindi utilizzabile anche su un personal computer. Debian \u00e8 usata come base per molte altre distribuzioni, come Mint o Ubuntu. 1994 : La distribuzione commerciale RedHat viene creata dalla societ\u00e0 RedHat, che \u00e8 oggi il principale distributore del sistema operativo GNU/Linux. RedHat supporta la versione community Fedora e recentemente la distribuzione gratuita CentOS. 1997 : Viene creato l'ambiente desktop KDE. Si basa sulla libreria di componenti Qt e sul linguaggio di sviluppo C++. 1999 : Viene creato l'ambiente desktop Gnome. Questo si basa sulla libreria di componenti GTK+. 2002 : Viene creata la distribuzione Arch. La sua particolarit\u00e0 \u00e8 quella di essere rilasciato in Rolling Release (aggiornamento continuo). 2004 : Ubuntu viene creato dalla societ\u00e0 Canonical (Mark Shuttleworth). \u00c8 basato su Debian, che include software gratuito e proprietario. 2021 : Nascita di Rocky Linux, basato sulla distribuzione RedHat.","title":"Introduzione"},{"location":"#introduzione","text":"BSD e Linux sono entrambi sistemi Unix-like, sistemi che discendono o si ispirano a Unix, il sistema operativo sviluppato per la prima volta negli anni '60 dai Bell Labs, parte di AT&T, la compagnia telefonica americana. POSIX (Portable Operating System Interface) \u00e8 uno standard che definisce l'insieme minimo di funzionalit\u00e0, comandi e interfacce, nonch\u00e9 la struttura delle directory, che un sistema deve implementare per essere considerato un sistema Unix.","title":"Introduzione"},{"location":"#unix","text":"Dal 1964 al 1968 : MULTICS (MULTiplexed Information and Computing Service) \u00e8 sviluppato per MIT, Bell Labs (AT&T) e General Electric. 1969 : Dopo il ritiro della Bell (1969) e poi della General Electric dal progetto, due sviluppatori (Ken Thompson e Dennis Ritchie), affiancati in seguito da Brian Kernighan, giudicando MULTICS troppo complesso, lanciano lo sviluppo di UNIX (UNiplexed Information and Computing Service). Originariamente sviluppato in assembler, i progettisti di UNIX hanno sviluppato il linguaggio B e poi il linguaggio C (1971) e hanno completamente riscritto UNIX. Essendo stato sviluppato nel 1970, la data di riferimento dei sistemi UNIX/Linux \u00e8 ancora fissata al 1\u00b0 gennaio 1970. Il linguaggio C \u00e8 ancora oggi uno dei linguaggi di programmazione pi\u00f9 popolari! Linguaggio di basso livello, vicino all'hardware, consente l'adattamento del sistema operativo a qualsiasi architettura di macchina dotata di compilatore C. UNIX \u00e8 un sistema operativo aperto e in evoluzione che ha svolto un ruolo importante nella storia dell'informatica. \u00c8 stata la base per molti altri sistemi: Linux, BSD, Mac OSX, ecc. UNIX \u00e8 ancora rilevante oggi (HP-UX, AIX, Solaris, etc.)","title":"UNIX"},{"location":"#minix","text":"1987 : AS Tanenbaum sviluppa MINIX, un UNIX semplificato, per insegnare i sistemi operativi in \u200b\u200bmodo semplice. Mr. Tanenbaum mette a disposizione il codice sorgente del suo sistema operativo.","title":"Minix"},{"location":"#linux","text":"1991 : Uno studente finlandese, Linus Torvalds , crea un sistema operativo dedicato al suo personal computer e lo chiama Linux. Pubblica la sua prima versione 0.02, sul forum di discussione Usenet e altri sviluppatori vengono ad aiutarlo a migliorare il suo sistema. Il termine Linux \u00e8 un gioco di parole tra il nome del fondatore, Linus, e UNIX. 1993 : Viene creata la distribuzione Debian. Debian \u00e8 una distribuzione non commerciale, basata sulla comunit\u00e0. Sviluppato originariamente per essere utilizzato su server, \u00e8 particolarmente adatto a questo ruolo, ma \u00e8 pensato per essere un sistema universale e quindi utilizzabile anche su un personal computer. Debian \u00e8 usata come base per molte altre distribuzioni, come Mint o Ubuntu. 1994 : La distribuzione commerciale RedHat viene creata dalla societ\u00e0 RedHat, che \u00e8 oggi il principale distributore del sistema operativo GNU/Linux. RedHat supporta la versione community Fedora e recentemente la distribuzione gratuita CentOS. 1997 : Viene creato l'ambiente desktop KDE. Si basa sulla libreria di componenti Qt e sul linguaggio di sviluppo C++. 1999 : Viene creato l'ambiente desktop Gnome. Questo si basa sulla libreria di componenti GTK+. 2002 : Viene creata la distribuzione Arch. La sua particolarit\u00e0 \u00e8 quella di essere rilasciato in Rolling Release (aggiornamento continuo). 2004 : Ubuntu viene creato dalla societ\u00e0 Canonical (Mark Shuttleworth). \u00c8 basato su Debian, che include software gratuito e proprietario. 2021 : Nascita di Rocky Linux, basato sulla distribuzione RedHat.","title":"Linux"},{"location":"additional_software_en/","tags":["nvchad","coding"],"text":"Additional Software Required RipGrep ripgrep is a line-oriented search tool that recursively searches the current directory for a regex (regular expression) pattern. By default, ripgrep respects the rules of gitignore and automatically skips hidden files/directories and binaries. Ripgrep offers excellent support on Windows, macOS and Linux, with binaries available at the for each release. Ripgrep is a software written in Rust and is installable with the cargo utility. Note, however, that cargo is not installed by the default installation of rust so you have to install it explicitly. dnf install rust cargo Once the necessary software is installed, we can install it with: cargo install ripgrep The installation will save the rg executable in the ~/.cargo/bin folder which is outside the PATH, to use it at the user level we will move it to ~/.local/bin/ . mv ~/.cargo/bin/rg ~/.local/bin/ At this point we can verify that everything is in place with: rg --version ripgrep 13 .0.0 -SIMD -AVX ( compiled ) +SIMD +AVX ( runtime ) RipGrep is needed for recursive searches with :Telescope . Lazygit LazyGit is an ncurses-style interface that allows you to perform all git operations in a more user-friendly way, it is required by the nvim.lazygit plugin, this plugin makes it possible to use LazyGit directly from NvChad, it opens a floating window from where you can perform all operations on your repositories, thus allowing you to make all changes to the repository git without leaving the editor. To install it we can use the repository for Fedora, on Rocky Linux 9 it works perfectly. sudo dnf copr enable atim/lazygit -y sudo dnf install lazygit Once installed we open a terminal and type the command lazygit and an interface similar to this will appear, with the x key we can bring up the menu with all available commands. LSP What is the Language Server protocol? It is a server service that provides support for advanced editing functions, such as automatic source code completion or the \"Go to Definition\" function for a programming language in an editor or IDE. The Language Server Protocol (LSP) is the product of standardizing the messages exchanged between a development tool and a language server process. The goal of LSP is to simplify this type of integration and to provide a useful framework for exposing language features to a variety of tools. LSP in NvChad NvChad provides an automatic mechanism for installing language servers through the nvim.lspconfig plugin. Introduction to nvim.lspconfig nvim-lspconfig is a collection of configurations, provided by the community, for the language client server built into the Nvim core. This plugin provides four main features: default startup commands, initialization options, and settings for each server. a root directory resolver that attempts to locate the root of the project an automatic command mapping that launches either a new language server or a language server for each open buffer if it is part of a traced project. utility commands such as LspInfo, LspStart, LspStop, and LspRestart for managing language server instances. Installation with npm npm is a powerful package manager and the key to the success of Node.js. It allows you to query, install, update packages. In the default installation on Rocky Linux the installation path of npm is /usr/local/ and thus requires administrator privileges to write into it, in order to use npm at user level we need to make some changes to its configuration. The modification allows us to use the full functionality of language servers while keeping the operating system tree clean. First, let's update npm : npm install -g npm@latest npm --version 8.15.1 Now we check the default path of npm with: npm config get prefix /usr/local What we want to do is change the directory set in the prefix variable to be able to install global packages in our home directory . We then change the variable and verify that the change has been registered with: npm config set prefix=$HOME/.local npm config get prefix /home/your_username/.local your_username clearly is an arbitrary name, instead there should be the username of the currently logged in user. Now we need to install npm again since the one currently installed is still owned by root . The new installation will also create all the directories and files needed for user-level management. npm install npm@latest -g From now on, all requested installations even if requested globally will be installed in .local/bin , the path is already in the user's PATH and this will make the executables immediately available. vscode-langserver-extracted The package is a cumulative package that contains language servers for HTML, CSS, JSON, Markdown and ESLint, to install it we use the following command: npm install vscode-langserver-extracted -g Once the installation is finished, we can verify that the language servers have been properly installed with: ls .local/bin/vscode* .local/bin/vscode-css-language-server .local/bin/vscode-eslint-language-server .local/bin/vscode-html-language-server .local/bin/vscode-json-language-server .local/bin/vscode-markdown-language-server In order to give NvChad a way to register them as local servers and load them as needed, we need to put them in the lspconfig.lua configuration file. local servers = { \"html\" , \"cssls\" , \"jsonls\" } SumnekoLua Another very important component is the lua-language-server executable, which completely changes the experience of writing lua code, and consequently also the editing of NvChad configuration files that are written in this language. This is also the default LSP for lua in Nvchad. L'eseguibile \u00e8 fornito dal progetto SumnekoLua e pu\u00f2 essere scaricato a questo indirizzo: https://github.com/sumneko/lua-language-server/releases/download/3.5.1/lua-language-server-3.5.1-linux-x64.tar.gz Once downloaded we need to unzip it somewhere and create a symbolic link of the executable in some specified folder in the PATH. To do this we unpack the file in ~/.local/share/ : mkdir -p ~/.local/share/lua-language-server tar xvzf lua-language-server-3.5.1-linux-x64.tar.gz -C ~/.local/share/lua-language-server And then from the folder ~/.local/bin/ we create a symbolic link to lua-language-server cd ~/.local/bin/ ln -s ~/.local/share/lua-language-server/bin/lua-language-server lua-language-server At this point you will have an assistant while writing and editing files written in lua . It should be noted that the lua server does not need to be configured in the lspconfig.lua configuration file as it being the default server for NvChad works without the need for any additional configuration. And if we use the <escape> key followed by the q key we get the list of errors found in the open file. Marksman Marksman is a language server for Markdown that provides auto-completion, go-to definitions, reference searching, diagnostics, etc. All types of links support completion, hover, and goto/reference definition. In addition, Marksman provides diagnostics for wiki links to detect broken references and duplicate/ambiguous titles. The language server is provided as an executable for various architectures, in this case we will need the linux version which can be downloaded at this address: https://github.com/artempyanykh/marksman/releases In order to have the support we have to move it to some PATH location which in our case will be ~/.local/bin/ and rename it by removing the -linux suffix and making it executable, assuming we have downloaded it to /home/user/downloads/ the command will be as follows: mv /home/user/downloads/marksman-linux ~/.local/bin/ chmod +x ~/.local/bin/marksman Ora \u00e8 il momento di inserirlo nei local server del file di configurazione lspconfig.lua , la riga da modificare \u00e8 la seguente: local servers = { \"html\" , \"cssls\" , \"jsonls\" , \"marksman\" } Having done this by opening a file written in Markdown we will have all the advanced features. And if we try to create some errors, in our example we will create a few blank lines that in markdown are not an error but are considered to be poor formatting we will get a visual warning (the pink squares to the left of the line number) that will alert us of the problem. yamlls 'yamlls` provides the functions of validating the entire yaml file, checking for errors and warnings regarding the code, autocompletion of commands, and hovering over a node displays the description, if available. The language server is provided by the package yaml-language-server that can be installed with npm : npm install -g yaml-language-server As with the other language servers we need to add it to the local servers of our plugin: local servers = { \"html\" , \"cssls\" , \"jsonls\" , \"marksman\" , \"yamlls\" } Once installed it will spring into action whenever we open a .yaml file by making a valuable contribution to writing and debugging code.","title":"Additional Software"},{"location":"additional_software_en/#additional-software-required","text":"","title":"Additional Software Required"},{"location":"additional_software_en/#ripgrep","text":"ripgrep is a line-oriented search tool that recursively searches the current directory for a regex (regular expression) pattern. By default, ripgrep respects the rules of gitignore and automatically skips hidden files/directories and binaries. Ripgrep offers excellent support on Windows, macOS and Linux, with binaries available at the for each release. Ripgrep is a software written in Rust and is installable with the cargo utility. Note, however, that cargo is not installed by the default installation of rust so you have to install it explicitly. dnf install rust cargo Once the necessary software is installed, we can install it with: cargo install ripgrep The installation will save the rg executable in the ~/.cargo/bin folder which is outside the PATH, to use it at the user level we will move it to ~/.local/bin/ . mv ~/.cargo/bin/rg ~/.local/bin/ At this point we can verify that everything is in place with: rg --version ripgrep 13 .0.0 -SIMD -AVX ( compiled ) +SIMD +AVX ( runtime ) RipGrep is needed for recursive searches with :Telescope .","title":"RipGrep"},{"location":"additional_software_en/#lazygit","text":"LazyGit is an ncurses-style interface that allows you to perform all git operations in a more user-friendly way, it is required by the nvim.lazygit plugin, this plugin makes it possible to use LazyGit directly from NvChad, it opens a floating window from where you can perform all operations on your repositories, thus allowing you to make all changes to the repository git without leaving the editor. To install it we can use the repository for Fedora, on Rocky Linux 9 it works perfectly. sudo dnf copr enable atim/lazygit -y sudo dnf install lazygit Once installed we open a terminal and type the command lazygit and an interface similar to this will appear, with the x key we can bring up the menu with all available commands.","title":"Lazygit"},{"location":"additional_software_en/#lsp","text":"What is the Language Server protocol? It is a server service that provides support for advanced editing functions, such as automatic source code completion or the \"Go to Definition\" function for a programming language in an editor or IDE. The Language Server Protocol (LSP) is the product of standardizing the messages exchanged between a development tool and a language server process. The goal of LSP is to simplify this type of integration and to provide a useful framework for exposing language features to a variety of tools.","title":"LSP"},{"location":"additional_software_en/#lsp-in-nvchad","text":"NvChad provides an automatic mechanism for installing language servers through the nvim.lspconfig plugin.","title":"LSP in NvChad"},{"location":"additional_software_en/#introduction-to-nvimlspconfig","text":"nvim-lspconfig is a collection of configurations, provided by the community, for the language client server built into the Nvim core. This plugin provides four main features: default startup commands, initialization options, and settings for each server. a root directory resolver that attempts to locate the root of the project an automatic command mapping that launches either a new language server or a language server for each open buffer if it is part of a traced project. utility commands such as LspInfo, LspStart, LspStop, and LspRestart for managing language server instances.","title":"Introduction to nvim.lspconfig"},{"location":"additional_software_en/#installation-with-npm","text":"npm is a powerful package manager and the key to the success of Node.js. It allows you to query, install, update packages. In the default installation on Rocky Linux the installation path of npm is /usr/local/ and thus requires administrator privileges to write into it, in order to use npm at user level we need to make some changes to its configuration. The modification allows us to use the full functionality of language servers while keeping the operating system tree clean. First, let's update npm : npm install -g npm@latest npm --version 8.15.1 Now we check the default path of npm with: npm config get prefix /usr/local What we want to do is change the directory set in the prefix variable to be able to install global packages in our home directory . We then change the variable and verify that the change has been registered with: npm config set prefix=$HOME/.local npm config get prefix /home/your_username/.local your_username clearly is an arbitrary name, instead there should be the username of the currently logged in user. Now we need to install npm again since the one currently installed is still owned by root . The new installation will also create all the directories and files needed for user-level management. npm install npm@latest -g From now on, all requested installations even if requested globally will be installed in .local/bin , the path is already in the user's PATH and this will make the executables immediately available.","title":"Installation with npm"},{"location":"additional_software_en/#vscode-langserver-extracted","text":"The package is a cumulative package that contains language servers for HTML, CSS, JSON, Markdown and ESLint, to install it we use the following command: npm install vscode-langserver-extracted -g Once the installation is finished, we can verify that the language servers have been properly installed with: ls .local/bin/vscode* .local/bin/vscode-css-language-server .local/bin/vscode-eslint-language-server .local/bin/vscode-html-language-server .local/bin/vscode-json-language-server .local/bin/vscode-markdown-language-server In order to give NvChad a way to register them as local servers and load them as needed, we need to put them in the lspconfig.lua configuration file. local servers = { \"html\" , \"cssls\" , \"jsonls\" }","title":"vscode-langserver-extracted"},{"location":"additional_software_en/#sumnekolua","text":"Another very important component is the lua-language-server executable, which completely changes the experience of writing lua code, and consequently also the editing of NvChad configuration files that are written in this language. This is also the default LSP for lua in Nvchad. L'eseguibile \u00e8 fornito dal progetto SumnekoLua e pu\u00f2 essere scaricato a questo indirizzo: https://github.com/sumneko/lua-language-server/releases/download/3.5.1/lua-language-server-3.5.1-linux-x64.tar.gz Once downloaded we need to unzip it somewhere and create a symbolic link of the executable in some specified folder in the PATH. To do this we unpack the file in ~/.local/share/ : mkdir -p ~/.local/share/lua-language-server tar xvzf lua-language-server-3.5.1-linux-x64.tar.gz -C ~/.local/share/lua-language-server And then from the folder ~/.local/bin/ we create a symbolic link to lua-language-server cd ~/.local/bin/ ln -s ~/.local/share/lua-language-server/bin/lua-language-server lua-language-server At this point you will have an assistant while writing and editing files written in lua . It should be noted that the lua server does not need to be configured in the lspconfig.lua configuration file as it being the default server for NvChad works without the need for any additional configuration. And if we use the <escape> key followed by the q key we get the list of errors found in the open file.","title":"SumnekoLua"},{"location":"additional_software_en/#marksman","text":"Marksman is a language server for Markdown that provides auto-completion, go-to definitions, reference searching, diagnostics, etc. All types of links support completion, hover, and goto/reference definition. In addition, Marksman provides diagnostics for wiki links to detect broken references and duplicate/ambiguous titles. The language server is provided as an executable for various architectures, in this case we will need the linux version which can be downloaded at this address: https://github.com/artempyanykh/marksman/releases In order to have the support we have to move it to some PATH location which in our case will be ~/.local/bin/ and rename it by removing the -linux suffix and making it executable, assuming we have downloaded it to /home/user/downloads/ the command will be as follows: mv /home/user/downloads/marksman-linux ~/.local/bin/ chmod +x ~/.local/bin/marksman Ora \u00e8 il momento di inserirlo nei local server del file di configurazione lspconfig.lua , la riga da modificare \u00e8 la seguente: local servers = { \"html\" , \"cssls\" , \"jsonls\" , \"marksman\" } Having done this by opening a file written in Markdown we will have all the advanced features. And if we try to create some errors, in our example we will create a few blank lines that in markdown are not an error but are considered to be poor formatting we will get a visual warning (the pink squares to the left of the line number) that will alert us of the problem.","title":"Marksman"},{"location":"additional_software_en/#yamlls","text":"'yamlls` provides the functions of validating the entire yaml file, checking for errors and warnings regarding the code, autocompletion of commands, and hovering over a node displays the description, if available. The language server is provided by the package yaml-language-server that can be installed with npm : npm install -g yaml-language-server As with the other language servers we need to add it to the local servers of our plugin: local servers = { \"html\" , \"cssls\" , \"jsonls\" , \"marksman\" , \"yamlls\" } Once installed it will spring into action whenever we open a .yaml file by making a valuable contribution to writing and debugging code.","title":"yamlls"},{"location":"desktop/gsettings/","tags":["gnome","desktop"],"text":"Gestire le impostazioni di GNOME dalla riga di comando con gsettings Le applicazioni GNOME (e altre) utilizzano comunemente l'API GSettings per memorizzare le impostazioni delle applicazioni. GSettings ha molti aspetti positivi: tipi di dati flessibili, con schemi GVariant , in modo che altri possano capire le impostazioni (ad esempio, dconf-editor ) sovrascritture, in modo che le distro possano modificare le impostazioni predefinite che non gradiscono. Ha diversi backend, in modo da poter essere adattato per funzionare in modo trasparente in molte situazioni. Un esempio di come questo sia utile \u00e8 quando si usa un backend di memoria per evitare di far persistere le impostazioni durante l'esecuzione dei test. Il backend di GSettings che viene normalmente utilizzato per il funzionamento normale \u00e8 quello di DConf . Queste impostazioni sono memorizzate in forma binaria per un rapido recupero e possono essere manipolate anche al di fuori dell'applicazione, utilizzando strumenti specifici. Questo sistema pu\u00f2 essere visto come un database, il cui schema \u00e8 descritto in un file XML (convenzionalmente chiamato .gschema.xml ) che viene poi compilato per migliorare le prestazioni in fase di esecuzione. GLib supporta un formato di dati binari chiamato GVariant, comunemente utilizzato per memorizzare varie forme di dati applicativi. Ad esempio, viene utilizzato per memorizzare il database dconf e come i dati on-disk nei repository OSTree. gsettings \u00c8 uno strumento a riga di comando per visualizzare e modificare le impostazioni GSettings e funziona indipendentemente dal backend GSettings in uso. Per modificare la memoria del backend dconf, si pu\u00f2 usare anche lo strumento dconf, ma si dovrebbe preferire gsettings. Si veda l'output --help dei due strumenti per informazioni sul loro utilizzo. Impostare i font dell'interfaccia Per prima cosa dobbiamo cercare le chiavi corrispondenti memorizzate in dconf, per far questo usiamo il comando gsettings list-keys : gsettings list-keys org.gnome.desktop.interface | grep font document-font-name font-antialiasing font-hinting font-name font-rgba-order monospace-font-name A questo punto sappiamo che le chiavi che definiscono le impostazioni dei font sono quelle elencate sopra e possiamo verificare il valore di una delle chiavi con gsettings get : gsettings get org.gnome.desktop.interface font-name 'Cantarell 11' Per modificare il font per l'interfaccia si utilizza il comando gsettings set: gsettings set org.gnome.desktop.interface font-name \"Montserrat 11\" Se ora andiamo a ripetere il comando per visualizzare il valore della chiave appena modificata troveremo la nostra impostazione: gsettings get org.gnome.desktop.interface font-name 'Montserrat 11' Una impostazione interessante per chi utilizza frequentemente la shell e la chiave monospace-font-name che definisce il carattere utilizzato nella shell, questo pu\u00f2 essere modificato con un carattere pi\u00f9 adatto alla programmazione come FiraCode , Source Code Pro , etc: gsettings get org.gnome.desktop.interface monospace-font-name 'Monospace 11' Per modificarlo: gsettings set org.gnome.desktop.interface monospacefont-name \"Red Hat Mono 12\" Modificare il tema delle icone Allo stesso modo interroghiamo la configurazione dell'interfaccia con gsettings list-keys per vedere quali chiavi contengono i valori sul tema delle icone: gsettings list-keys org.gnome.desktop.interface | grep icon icon-theme toolbar-icons-size Ricaviamo il valore con gsettings get : gsettings get org.gnome.desktop.interface icon-theme 'Tela-nord' I temi disponibili sono memorizzati in /usr/share/icons e possono essere visualizzati con il comando: tree -L 1 /usr/share/icons/ /usr/share/icons/ \u251c\u2500\u2500 Adwaita \u251c\u2500\u2500 Bluecurve \u251c\u2500\u2500 default \u251c\u2500\u2500 gnome \u251c\u2500\u2500 gnome-logo-text-dark.svg \u251c\u2500\u2500 gnome-logo-text.svg \u251c\u2500\u2500 hicolor \u251c\u2500\u2500 HighContrast \u251c\u2500\u2500 locolor \u251c\u2500\u2500 Newaita \u2514\u2500\u2500 oxygen Modifichiamo quindi il tema con gsettings set : gsettings set org.gnome.desktop.interface icon-theme 'Newaita' NOTA: Il tema Newaita non \u00e8 installato di default ma pu\u00f2 essere scaricato da Gnome Look gsettings set org.gnome.desktop.interface document-font-name 'Sans 10' gsettings set org.gnome.desktop.interface font-name 'Ubuntu 10' gsettings set org.gnome.desktop.interface monospace-font-name 'Ubuntu Mono 11' gsettings set org.gnome.nautilus.desktop font 'Ubuntu 10'","title":"GSettings"},{"location":"desktop/gsettings/#gestire-le-impostazioni-di-gnome-dalla-riga-di-comando-con-gsettings","text":"Le applicazioni GNOME (e altre) utilizzano comunemente l'API GSettings per memorizzare le impostazioni delle applicazioni. GSettings ha molti aspetti positivi: tipi di dati flessibili, con schemi GVariant , in modo che altri possano capire le impostazioni (ad esempio, dconf-editor ) sovrascritture, in modo che le distro possano modificare le impostazioni predefinite che non gradiscono. Ha diversi backend, in modo da poter essere adattato per funzionare in modo trasparente in molte situazioni. Un esempio di come questo sia utile \u00e8 quando si usa un backend di memoria per evitare di far persistere le impostazioni durante l'esecuzione dei test. Il backend di GSettings che viene normalmente utilizzato per il funzionamento normale \u00e8 quello di DConf . Queste impostazioni sono memorizzate in forma binaria per un rapido recupero e possono essere manipolate anche al di fuori dell'applicazione, utilizzando strumenti specifici. Questo sistema pu\u00f2 essere visto come un database, il cui schema \u00e8 descritto in un file XML (convenzionalmente chiamato .gschema.xml ) che viene poi compilato per migliorare le prestazioni in fase di esecuzione. GLib supporta un formato di dati binari chiamato GVariant, comunemente utilizzato per memorizzare varie forme di dati applicativi. Ad esempio, viene utilizzato per memorizzare il database dconf e come i dati on-disk nei repository OSTree.","title":"Gestire le impostazioni di GNOME dalla riga di comando con gsettings"},{"location":"desktop/gsettings/#gsettings","text":"\u00c8 uno strumento a riga di comando per visualizzare e modificare le impostazioni GSettings e funziona indipendentemente dal backend GSettings in uso. Per modificare la memoria del backend dconf, si pu\u00f2 usare anche lo strumento dconf, ma si dovrebbe preferire gsettings. Si veda l'output --help dei due strumenti per informazioni sul loro utilizzo.","title":"gsettings"},{"location":"desktop/gsettings/#impostare-i-font-dellinterfaccia","text":"Per prima cosa dobbiamo cercare le chiavi corrispondenti memorizzate in dconf, per far questo usiamo il comando gsettings list-keys : gsettings list-keys org.gnome.desktop.interface | grep font document-font-name font-antialiasing font-hinting font-name font-rgba-order monospace-font-name A questo punto sappiamo che le chiavi che definiscono le impostazioni dei font sono quelle elencate sopra e possiamo verificare il valore di una delle chiavi con gsettings get : gsettings get org.gnome.desktop.interface font-name 'Cantarell 11' Per modificare il font per l'interfaccia si utilizza il comando gsettings set: gsettings set org.gnome.desktop.interface font-name \"Montserrat 11\" Se ora andiamo a ripetere il comando per visualizzare il valore della chiave appena modificata troveremo la nostra impostazione: gsettings get org.gnome.desktop.interface font-name 'Montserrat 11' Una impostazione interessante per chi utilizza frequentemente la shell e la chiave monospace-font-name che definisce il carattere utilizzato nella shell, questo pu\u00f2 essere modificato con un carattere pi\u00f9 adatto alla programmazione come FiraCode , Source Code Pro , etc: gsettings get org.gnome.desktop.interface monospace-font-name 'Monospace 11' Per modificarlo: gsettings set org.gnome.desktop.interface monospacefont-name \"Red Hat Mono 12\"","title":"Impostare i font dell'interfaccia"},{"location":"desktop/gsettings/#modificare-il-tema-delle-icone","text":"Allo stesso modo interroghiamo la configurazione dell'interfaccia con gsettings list-keys per vedere quali chiavi contengono i valori sul tema delle icone: gsettings list-keys org.gnome.desktop.interface | grep icon icon-theme toolbar-icons-size Ricaviamo il valore con gsettings get : gsettings get org.gnome.desktop.interface icon-theme 'Tela-nord' I temi disponibili sono memorizzati in /usr/share/icons e possono essere visualizzati con il comando: tree -L 1 /usr/share/icons/ /usr/share/icons/ \u251c\u2500\u2500 Adwaita \u251c\u2500\u2500 Bluecurve \u251c\u2500\u2500 default \u251c\u2500\u2500 gnome \u251c\u2500\u2500 gnome-logo-text-dark.svg \u251c\u2500\u2500 gnome-logo-text.svg \u251c\u2500\u2500 hicolor \u251c\u2500\u2500 HighContrast \u251c\u2500\u2500 locolor \u251c\u2500\u2500 Newaita \u2514\u2500\u2500 oxygen Modifichiamo quindi il tema con gsettings set : gsettings set org.gnome.desktop.interface icon-theme 'Newaita' NOTA: Il tema Newaita non \u00e8 installato di default ma pu\u00f2 essere scaricato da Gnome Look gsettings set org.gnome.desktop.interface document-font-name 'Sans 10' gsettings set org.gnome.desktop.interface font-name 'Ubuntu 10' gsettings set org.gnome.desktop.interface monospace-font-name 'Ubuntu Mono 11' gsettings set org.gnome.nautilus.desktop font 'Ubuntu 10'","title":"Modificare il tema delle icone"},{"location":"desktop/kernel_realtime/","tags":["desktop","multimedia","rocky linux"],"text":"Lavorare con il kernel real-time su Rocky Linux Vale la pena di eseguire un kernel real-time e di valutarne il potenziale e i vantaggi in termini di prestazioni per le applicazioni. La funzionalit\u00e0 del kernel real-time esistono da oltre un decennio nell'ecosistema open-source. Allo stesso modo, il supporto di Red Hat Enterprise Linux:tm: (RHEL) per il kernel in tempo reale \u00e8 disponibile da diversi anni. Tuttavia, molti amministratori di sistema interpretano in modo errato i suoi concetti fondamentali e il suo reale comportamento operativo. In questo articolo descrivo alcune delle sue caratteristiche principali, le differenze rispetto al kernel standard e i passaggi rapidi per l'installazione. Che cos'\u00e8 il kernel in real-time? Un kernel real-time non \u00e8 necessariamente superiore o migliore di un kernel standard. Risponde invece a diversi requisiti aziendali o di sistema. \u00c8 un kernel ottimizzato progettato per mantenere una bassa latenza, tempi di risposta costanti e determinismo. A titolo di paragone, un kernel RHEL standard si concentra su operazioni orientate al rendimento e su una pianificazione equa dei compiti. Il kernel in tempo reale \u00e8 conosciuto anche come kernel-rt o preempt-rt. Il modo pi\u00f9 semplice per identificare un kernel in tempo reale \u00e8 eseguire il comando uname -r sul terminale e cercare la parola chiave rt nella versione del kernel. Se manca la parola rt, il sistema utilizza il kernel standard. Questo \u00e8 il kernel rt attuale per Rocky Linux 9 . uname -r kernel-rt-5.14.0-70.13.1.rt21.83.el9_0.x86_64.rpm Alcuni importanti meccanismi del kernel-rt includono: La priorit\u00e0 di un task viene controllata (1-99) in condizioni di carico elevato. Ai task ad alta priorit\u00e0 (99) viene data la preferenza per l'esecuzione da parte della CPU. Non utilizza la politica di Completely Fair Scheduling (CFS). Le politiche di schedulazione in uso sono SCHED_FIFO o SCHED_RR. Mantiene un tempo di esecuzione a bassa latenza. Offre la possibilit\u00e0 di misurare, registrare e configurare il tempo di risposta. Di seguito sono elencate alcune altre differenze fondamentali per confrontare RHEL for Real Time con RHEL standard : Kexec e vmcore - L'installazione e la configurazione sono le stesse di RHEL standard. Moduli di terze parti - Tutti i moduli devono essere ricompilati con kernel-rt prima di essere utilizzati. Demone irqbalance - Disabilitato per impostazione predefinita. Politica di pianificazione - Vengono utilizzati solo SCHED_FIFO o SCHED_RR. Interrupt (IRQ) - Utilizza CPU dedicate per isolare i processi gli uni dagli altri. Installazione del kernel RT su Rocky Linux Il repository RT \u00e8 disabilitato per impostazione predefinita. dnf repolist --all | grep rt rt Rocky Linux 9 - Realtim disabilitato rt-debug Rocky Linux 9 - Realtim disabilitato rt-source Rocky Linux 9 - Realtim disabilitato Per installare il kernel real-time dobbiamo abilitare il repository corrispondente con il comando: dnf config-manager --set-enabled rt E confermare l'avvenuta abilitazione con: sudo dnf grouplist | grep RT RT A questo punto possiamo passare all'intallazione del gruppo corrispondente con: dnf groupinstall RT Ultima verifica della scadenza dei metadati: 0 :05:09 fa il sab 16 lug 2022 , 22 :52:13. Dipendenze risolte. ======================================================================================================================================================= Package Architecture Version Repository Size ======================================================================================================================================================= Installing group/module packages: kernel-rt x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 705 k kernel-rt-core x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 33 M kernel-rt-devel x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 15 M kernel-rt-modules x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 21 M kernel-rt-modules-extra x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 1 .1 M realtime-setup x86_64 2 .2-5.el9 rt 22 k realtime-tests x86_64 2 .3-3.el9 appstream 176 k rteval noarch 3 .3-4.el9_0 rt 126 k rteval-loads noarch 1 .5-1.el9 rt 114 M tuned-profiles-realtime noarch 2 .18.0-1.el9 rt 14 k Installazione dipendenze: Judy x86_64 1 .0.5-28.el9 appstream 128 k gmp-c++ x86_64 1 :6.2.0-10.el9 appstream 19 k gmp-devel .... Riavviare il sistema e selezionare kernel-rt dalla console di avvio. Gli utenti dovrebbero eseguire l'installazione del gruppo RT, in quanto fornisce tutti i pacchetti dipendenti da kernel-rt necessari. La tabella seguente mostra i dettagli dei pacchetti dipendenti: kernel-rt - Kernel in tempo reale rt-setup - Il pacchetto pi\u00f9 importante per la configurazione dell'ambiente RT. rtctl - Configura le priorit\u00e0 di pianificazione per i thread del kernel. rt-test, rt-checks, rteval - Utilizzati per testare le capacit\u00e0 e i carichi del sistema. Conclusione Vale la pena eseguire un kernel real-time e valutarne il potenziale, poich\u00e9 molte applicazioni possono trarne beneficio. Il kernel-rt pu\u00f2 essere messo a punto per ridurre ulteriormente i problemi di prestazioni. Strumenti come ftrace sono forniti con Rocky Linux e sono molto utili per analizzare e fare il debug dei problemi di latenza. Tuttavia, questi dettagli sono fuori dallo scopo di questo articolo. Il kernel in tempo reale esiste da molto tempo, ma molti sysadmin non sono sicuri su come utilizzarlo. Forse il kernel real-time aiuter\u00e0 la vostre macchine ad ottenere prestazioni Linux ancora pi\u00f9 elevate!","title":"Kernel Real-Time"},{"location":"desktop/kernel_realtime/#lavorare-con-il-kernel-real-time-su-rocky-linux","text":"Vale la pena di eseguire un kernel real-time e di valutarne il potenziale e i vantaggi in termini di prestazioni per le applicazioni. La funzionalit\u00e0 del kernel real-time esistono da oltre un decennio nell'ecosistema open-source. Allo stesso modo, il supporto di Red Hat Enterprise Linux:tm: (RHEL) per il kernel in tempo reale \u00e8 disponibile da diversi anni. Tuttavia, molti amministratori di sistema interpretano in modo errato i suoi concetti fondamentali e il suo reale comportamento operativo. In questo articolo descrivo alcune delle sue caratteristiche principali, le differenze rispetto al kernel standard e i passaggi rapidi per l'installazione.","title":"Lavorare con il kernel real-time su Rocky Linux"},{"location":"desktop/kernel_realtime/#che-cose-il-kernel-in-real-time","text":"Un kernel real-time non \u00e8 necessariamente superiore o migliore di un kernel standard. Risponde invece a diversi requisiti aziendali o di sistema. \u00c8 un kernel ottimizzato progettato per mantenere una bassa latenza, tempi di risposta costanti e determinismo. A titolo di paragone, un kernel RHEL standard si concentra su operazioni orientate al rendimento e su una pianificazione equa dei compiti. Il kernel in tempo reale \u00e8 conosciuto anche come kernel-rt o preempt-rt. Il modo pi\u00f9 semplice per identificare un kernel in tempo reale \u00e8 eseguire il comando uname -r sul terminale e cercare la parola chiave rt nella versione del kernel. Se manca la parola rt, il sistema utilizza il kernel standard. Questo \u00e8 il kernel rt attuale per Rocky Linux 9 . uname -r kernel-rt-5.14.0-70.13.1.rt21.83.el9_0.x86_64.rpm Alcuni importanti meccanismi del kernel-rt includono: La priorit\u00e0 di un task viene controllata (1-99) in condizioni di carico elevato. Ai task ad alta priorit\u00e0 (99) viene data la preferenza per l'esecuzione da parte della CPU. Non utilizza la politica di Completely Fair Scheduling (CFS). Le politiche di schedulazione in uso sono SCHED_FIFO o SCHED_RR. Mantiene un tempo di esecuzione a bassa latenza. Offre la possibilit\u00e0 di misurare, registrare e configurare il tempo di risposta. Di seguito sono elencate alcune altre differenze fondamentali per confrontare RHEL for Real Time con RHEL standard : Kexec e vmcore - L'installazione e la configurazione sono le stesse di RHEL standard. Moduli di terze parti - Tutti i moduli devono essere ricompilati con kernel-rt prima di essere utilizzati. Demone irqbalance - Disabilitato per impostazione predefinita. Politica di pianificazione - Vengono utilizzati solo SCHED_FIFO o SCHED_RR. Interrupt (IRQ) - Utilizza CPU dedicate per isolare i processi gli uni dagli altri.","title":"Che cos'\u00e8 il kernel in real-time?"},{"location":"desktop/kernel_realtime/#installazione-del-kernel-rt-su-rocky-linux","text":"Il repository RT \u00e8 disabilitato per impostazione predefinita. dnf repolist --all | grep rt rt Rocky Linux 9 - Realtim disabilitato rt-debug Rocky Linux 9 - Realtim disabilitato rt-source Rocky Linux 9 - Realtim disabilitato Per installare il kernel real-time dobbiamo abilitare il repository corrispondente con il comando: dnf config-manager --set-enabled rt E confermare l'avvenuta abilitazione con: sudo dnf grouplist | grep RT RT A questo punto possiamo passare all'intallazione del gruppo corrispondente con: dnf groupinstall RT Ultima verifica della scadenza dei metadati: 0 :05:09 fa il sab 16 lug 2022 , 22 :52:13. Dipendenze risolte. ======================================================================================================================================================= Package Architecture Version Repository Size ======================================================================================================================================================= Installing group/module packages: kernel-rt x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 705 k kernel-rt-core x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 33 M kernel-rt-devel x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 15 M kernel-rt-modules x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 21 M kernel-rt-modules-extra x86_64 5 .14.0-70.13.1.rt21.83.el9_0 rt 1 .1 M realtime-setup x86_64 2 .2-5.el9 rt 22 k realtime-tests x86_64 2 .3-3.el9 appstream 176 k rteval noarch 3 .3-4.el9_0 rt 126 k rteval-loads noarch 1 .5-1.el9 rt 114 M tuned-profiles-realtime noarch 2 .18.0-1.el9 rt 14 k Installazione dipendenze: Judy x86_64 1 .0.5-28.el9 appstream 128 k gmp-c++ x86_64 1 :6.2.0-10.el9 appstream 19 k gmp-devel .... Riavviare il sistema e selezionare kernel-rt dalla console di avvio. Gli utenti dovrebbero eseguire l'installazione del gruppo RT, in quanto fornisce tutti i pacchetti dipendenti da kernel-rt necessari. La tabella seguente mostra i dettagli dei pacchetti dipendenti: kernel-rt - Kernel in tempo reale rt-setup - Il pacchetto pi\u00f9 importante per la configurazione dell'ambiente RT. rtctl - Configura le priorit\u00e0 di pianificazione per i thread del kernel. rt-test, rt-checks, rteval - Utilizzati per testare le capacit\u00e0 e i carichi del sistema.","title":"Installazione del kernel RT su Rocky Linux"},{"location":"desktop/kernel_realtime/#conclusione","text":"Vale la pena eseguire un kernel real-time e valutarne il potenziale, poich\u00e9 molte applicazioni possono trarne beneficio. Il kernel-rt pu\u00f2 essere messo a punto per ridurre ulteriormente i problemi di prestazioni. Strumenti come ftrace sono forniti con Rocky Linux e sono molto utili per analizzare e fare il debug dei problemi di latenza. Tuttavia, questi dettagli sono fuori dallo scopo di questo articolo. Il kernel in tempo reale esiste da molto tempo, ma molti sysadmin non sono sicuri su come utilizzarlo. Forse il kernel real-time aiuter\u00e0 la vostre macchine ad ottenere prestazioni Linux ancora pi\u00f9 elevate!","title":"Conclusione"},{"location":"freebsd/","text":"Introduzione a FreeBSD Presentazione Cos'\u00e8 FreeBSD? FreeBSD \u00e8 un moderno sistema operativo per desktop, portatili, server e sistemi embedded con supporto per un gran numero di piattaforme. \u00c8 basato sulla versione \"4.4BSD-Lite\" dell'U.C. Berkeley, con alcuni miglioramenti \"4.4BSD-Lite2\". \u00c8 anche basato indirettamente sul port di William Jolitz di \"Net/2\" dell'U.C. Berkeley su i386\u2122, conosciuto come \"386BSD\", anche se rimane molto poco del codice di 386BSD. FreeBSD \u00e8 usato da aziende, Internet Service Provider, ricercatori, professionisti del computer, studenti e utenti domestici in tutto il mondo nel loro lavoro, istruzione e ricreazione. Qual \u00e8 l'obiettivo del progetto FreeBSD? L'obiettivo del progetto FreeBSD \u00e8 di fornire un sistema operativo stabile e veloce di uso generale che possa essere usato per qualsiasi scopo senza vincoli. La licenza FreeBSD ha delle restrizioni? S\u00ec. Queste restrizioni non controllano come il codice \u00e8 usato, ma come trattare il progetto FreeBSD stesso. La licenza stessa \u00e8 disponibile su license e pu\u00f2 essere riassunta cos\u00ec: Non dichiarate di averlo scritto voi. Non fateci causa se si rompe. Non rimuovete o modificate la licenza. Gli sviluppatori di FreeBSD credono che la prima e pi\u00f9 importante \"missione\" sia quella di fornire codice a tutti quelli che ne hanno bisogno, e per qualsiasi scopo, in modo che il codice ottenga il pi\u00f9 ampio uso possibile e fornisca il pi\u00f9 ampio beneficio possibile. Questo \u00e8 uno degli obiettivi fondamentali del Software Libero, che FreeBSD sostiene con entusiasmo. Il codice dell'albero dei sorgenti che rientra nell' ambito della GNU General Public License (GPL) o la GNU Library General Public License (LGPL) ha qualche vincolo in pi\u00f9. A causa delle complessit\u00e0 aggiuntive che possono sorgere nell'uso commerciale del software GPL, cerchiamo comunque di sostituire tale software con quello sotto la pi\u00f9 permissiva licenza FreeBSD, quando possibile. Perch\u00e9 si chiama FreeBSD? Perch\u00e8 pu\u00f2 essere usato gratuitamente, anche da utenti commerciali. Il sorgente completo del sistema operativo \u00e8 liberamente disponibile, e le minime restrizioni possibili sono state poste sul suo uso, distribuzione e incorporazione in altri lavori (commerciali o non commerciali). Chiunque abbia un miglioramento o una correzione di bug \u00e8 libero di inviare il proprio codice e farlo aggiungere all'albero dei sorgenti (soggetto a una o due ovvie disposizioni). Vale la pena sottolineare che la parola \"libero\" \u00e8 usata in due modi qui: uno significa \"a costo zero\" e l'altro significa \"fai quello che vuoi\". A parte una o due cose che non puoi fare con il codice FreeBSD, per esempio fingere di averlo scritto tu, puoi davvero farci quello che vuoi. Qual \u00e8 l'ultima versione di FreeBSD? In qualsiasi momento dello sviluppo di FreeBSD, ci possono essere pi\u00f9 rami paralleli. Le versioni 13.X sono fatte dal ramo 13-STABLE, e le versioni 12.X sono fatte dal ramo 12-STABLE. Fino al rilascio della 12.0, la serie 12.X era quella conosciuta come -STABLE. Tuttavia, a partire dalla 14.X, il ramo 12.X sar\u00e0 designato per uno stato di \"supporto esteso\" e ricever\u00e0 solo correzioni per problemi importanti, come le correzioni relative alla sicurezza. I rilasci vengono fatti ogni pochi mesi. Mentre molte persone mantengono aggiornati i propri sisteme con i sorgenti di FreeBSD (vedi la sezione su FreeBSD-CURRENT e FreeBSD-STABLE), fare ci\u00f2 richiede un impegno maggiore, dato che i sorgenti sono un bersaglio in movimento. Maggiori informazioni sui rilasci di FreeBSD possono essere trovate nella pagina Release Engineering e in release(7) . Cos'\u00e8 FreeBSD-CURRENT? FreeBSD-CURRENT \u00e8 la versione di sviluppo del sistema operativo, che a tempo debito diventer\u00e0 il nuovo ramo FreeBSD-STABLE. Come tale, \u00e8 veramente di interesse solo per gli sviluppatori che lavorano sul sistema e per gli hobbisti incalliti. Vedi la sezione relativa nel Manuale per i dettagli sull'esecuzione di -CURRENT. Gli utenti che non hanno familiarit\u00e0 con FreeBSD non dovrebbero usare FreeBSD-CURRENT. Questo ramo a volte si evolve abbastanza velocemente e a causa di un errore pu\u00f2 essere a volte non compilabile. Dalle persone che usano FreeBSD-CURRENT ci si aspetta che siano in grado di analizzare, fare il debug e segnalare i problemi. Cos'\u00e8 il concetto di FreeBSD-STABLE? FreeBSD-STABLE \u00e8 il ramo di sviluppo da cui vengono fatti i rilasci principali. I cambiamenti in questo ramo vanno ad un ritmo pi\u00f9 lento e con il presupposto generale che siano stati prima testati in FreeBSD-CURRENT. Tuttavia, in qualsiasi momento, i sorgenti di FreeBSD-STABLE possono essere o meno adatti all'uso generale, poich\u00e9 possono venir scoperti bug e casi particolari che non sono stati ancora trovati in FreeBSD-CURRENT. Gli utenti che non hanno le risorse per eseguire i test dovrebbero invece eseguire la versione pi\u00f9 recente di FreeBSD. FreeBSD-CURRENT, d'altra parte, \u00e8 stata online ininterrottamente fin dal rilascio della 2.0. Quando vengono rilasciate le release di FreeBSD? Il Release Engineering Team re@FreeBSD.org rilascia una nuova versione maggiore di FreeBSD circa ogni 18 mesi e una nuova versione minore circa ogni 8 mesi, in media. Le date di rilascio sono annunciate con largo anticipo, in modo che le persone che lavorano al sistema sappiano quando i loro progetti devono essere finiti e testati. Un periodo di test precede ogni rilascio, per assicurare che l'aggiunta di nuove caratteristiche non comprometta la stabilit\u00e0 del rilascio. Molti utenti considerano questa precauzione come una delle cose migliori di FreeBSD, anche se aspettare che tutte le ultime chicche raggiungano -STABLE pu\u00f2 essere un po' frustrante. FreeBSD pu\u00f2 sostituire il mio attuale sistema operativo? Per la maggior parte delle persone, s\u00ec. Ma questa domanda non \u00e8 cos\u00ec scontata. La maggior parte delle persone non usa effettivamente un sistema operativo, usa le applicazioni. Le applicazioni sono ci\u00f2 che realmente usano il sistema operativo. FreeBSD \u00e8 progettato per fornire un ambiente robusto e completo per le applicazioni. Supporta un'ampia variet\u00e0 di browser web, suite per ufficio, lettori di email, programmi di grafica, ambienti di programmazione, server di rete, e molto altro. La maggior parte di queste applicazioni pu\u00f2 essere gestita attraverso la collezione dei ports . Se un'applicazione \u00e8 disponibile solo su un sistema operativo, quel sistema operativo non pu\u00f2 essere semplicemente sostituito. \u00c8 probabile che ci sia comunque un'applicazione molto simile su FreeBSD. Come un solido server per l'ufficio o per Internet o una stazione di lavoro affidabile, FreeBSD far\u00e0 quasi certamente tutto ci\u00f2 di cui hai bisogno. Molti utenti di computer in tutto il mondo, inclusi sia principianti che esperti amministratori UNIX\u00ae, usano FreeBSD come loro unico sistema operativo desktop.","title":"Introduzione FreeBSD"},{"location":"freebsd/#introduzione-a-freebsd","text":"","title":"Introduzione a FreeBSD"},{"location":"freebsd/#presentazione","text":"","title":"Presentazione"},{"location":"freebsd/#cose-freebsd","text":"FreeBSD \u00e8 un moderno sistema operativo per desktop, portatili, server e sistemi embedded con supporto per un gran numero di piattaforme. \u00c8 basato sulla versione \"4.4BSD-Lite\" dell'U.C. Berkeley, con alcuni miglioramenti \"4.4BSD-Lite2\". \u00c8 anche basato indirettamente sul port di William Jolitz di \"Net/2\" dell'U.C. Berkeley su i386\u2122, conosciuto come \"386BSD\", anche se rimane molto poco del codice di 386BSD. FreeBSD \u00e8 usato da aziende, Internet Service Provider, ricercatori, professionisti del computer, studenti e utenti domestici in tutto il mondo nel loro lavoro, istruzione e ricreazione.","title":"Cos'\u00e8 FreeBSD?"},{"location":"freebsd/#qual-e-lobiettivo-del-progetto-freebsd","text":"L'obiettivo del progetto FreeBSD \u00e8 di fornire un sistema operativo stabile e veloce di uso generale che possa essere usato per qualsiasi scopo senza vincoli.","title":"Qual \u00e8 l'obiettivo del progetto FreeBSD?"},{"location":"freebsd/#la-licenza-freebsd-ha-delle-restrizioni","text":"S\u00ec. Queste restrizioni non controllano come il codice \u00e8 usato, ma come trattare il progetto FreeBSD stesso. La licenza stessa \u00e8 disponibile su license e pu\u00f2 essere riassunta cos\u00ec: Non dichiarate di averlo scritto voi. Non fateci causa se si rompe. Non rimuovete o modificate la licenza. Gli sviluppatori di FreeBSD credono che la prima e pi\u00f9 importante \"missione\" sia quella di fornire codice a tutti quelli che ne hanno bisogno, e per qualsiasi scopo, in modo che il codice ottenga il pi\u00f9 ampio uso possibile e fornisca il pi\u00f9 ampio beneficio possibile. Questo \u00e8 uno degli obiettivi fondamentali del Software Libero, che FreeBSD sostiene con entusiasmo. Il codice dell'albero dei sorgenti che rientra nell' ambito della GNU General Public License (GPL) o la GNU Library General Public License (LGPL) ha qualche vincolo in pi\u00f9. A causa delle complessit\u00e0 aggiuntive che possono sorgere nell'uso commerciale del software GPL, cerchiamo comunque di sostituire tale software con quello sotto la pi\u00f9 permissiva licenza FreeBSD, quando possibile.","title":"La licenza FreeBSD ha delle restrizioni?"},{"location":"freebsd/#perche-si-chiama-freebsd","text":"Perch\u00e8 pu\u00f2 essere usato gratuitamente, anche da utenti commerciali. Il sorgente completo del sistema operativo \u00e8 liberamente disponibile, e le minime restrizioni possibili sono state poste sul suo uso, distribuzione e incorporazione in altri lavori (commerciali o non commerciali). Chiunque abbia un miglioramento o una correzione di bug \u00e8 libero di inviare il proprio codice e farlo aggiungere all'albero dei sorgenti (soggetto a una o due ovvie disposizioni). Vale la pena sottolineare che la parola \"libero\" \u00e8 usata in due modi qui: uno significa \"a costo zero\" e l'altro significa \"fai quello che vuoi\". A parte una o due cose che non puoi fare con il codice FreeBSD, per esempio fingere di averlo scritto tu, puoi davvero farci quello che vuoi.","title":"Perch\u00e9 si chiama FreeBSD?"},{"location":"freebsd/#qual-e-lultima-versione-di-freebsd","text":"In qualsiasi momento dello sviluppo di FreeBSD, ci possono essere pi\u00f9 rami paralleli. Le versioni 13.X sono fatte dal ramo 13-STABLE, e le versioni 12.X sono fatte dal ramo 12-STABLE. Fino al rilascio della 12.0, la serie 12.X era quella conosciuta come -STABLE. Tuttavia, a partire dalla 14.X, il ramo 12.X sar\u00e0 designato per uno stato di \"supporto esteso\" e ricever\u00e0 solo correzioni per problemi importanti, come le correzioni relative alla sicurezza. I rilasci vengono fatti ogni pochi mesi. Mentre molte persone mantengono aggiornati i propri sisteme con i sorgenti di FreeBSD (vedi la sezione su FreeBSD-CURRENT e FreeBSD-STABLE), fare ci\u00f2 richiede un impegno maggiore, dato che i sorgenti sono un bersaglio in movimento. Maggiori informazioni sui rilasci di FreeBSD possono essere trovate nella pagina Release Engineering e in release(7) .","title":"Qual \u00e8 l'ultima versione di FreeBSD?"},{"location":"freebsd/#cose-freebsd-current","text":"FreeBSD-CURRENT \u00e8 la versione di sviluppo del sistema operativo, che a tempo debito diventer\u00e0 il nuovo ramo FreeBSD-STABLE. Come tale, \u00e8 veramente di interesse solo per gli sviluppatori che lavorano sul sistema e per gli hobbisti incalliti. Vedi la sezione relativa nel Manuale per i dettagli sull'esecuzione di -CURRENT. Gli utenti che non hanno familiarit\u00e0 con FreeBSD non dovrebbero usare FreeBSD-CURRENT. Questo ramo a volte si evolve abbastanza velocemente e a causa di un errore pu\u00f2 essere a volte non compilabile. Dalle persone che usano FreeBSD-CURRENT ci si aspetta che siano in grado di analizzare, fare il debug e segnalare i problemi.","title":"Cos'\u00e8 FreeBSD-CURRENT?"},{"location":"freebsd/#cose-il-concetto-di-freebsd-stable","text":"FreeBSD-STABLE \u00e8 il ramo di sviluppo da cui vengono fatti i rilasci principali. I cambiamenti in questo ramo vanno ad un ritmo pi\u00f9 lento e con il presupposto generale che siano stati prima testati in FreeBSD-CURRENT. Tuttavia, in qualsiasi momento, i sorgenti di FreeBSD-STABLE possono essere o meno adatti all'uso generale, poich\u00e9 possono venir scoperti bug e casi particolari che non sono stati ancora trovati in FreeBSD-CURRENT. Gli utenti che non hanno le risorse per eseguire i test dovrebbero invece eseguire la versione pi\u00f9 recente di FreeBSD. FreeBSD-CURRENT, d'altra parte, \u00e8 stata online ininterrottamente fin dal rilascio della 2.0.","title":"Cos'\u00e8 il concetto di FreeBSD-STABLE?"},{"location":"freebsd/#quando-vengono-rilasciate-le-release-di-freebsd","text":"Il Release Engineering Team re@FreeBSD.org rilascia una nuova versione maggiore di FreeBSD circa ogni 18 mesi e una nuova versione minore circa ogni 8 mesi, in media. Le date di rilascio sono annunciate con largo anticipo, in modo che le persone che lavorano al sistema sappiano quando i loro progetti devono essere finiti e testati. Un periodo di test precede ogni rilascio, per assicurare che l'aggiunta di nuove caratteristiche non comprometta la stabilit\u00e0 del rilascio. Molti utenti considerano questa precauzione come una delle cose migliori di FreeBSD, anche se aspettare che tutte le ultime chicche raggiungano -STABLE pu\u00f2 essere un po' frustrante.","title":"Quando vengono rilasciate le release di FreeBSD?"},{"location":"freebsd/#freebsd-puo-sostituire-il-mio-attuale-sistema-operativo","text":"Per la maggior parte delle persone, s\u00ec. Ma questa domanda non \u00e8 cos\u00ec scontata. La maggior parte delle persone non usa effettivamente un sistema operativo, usa le applicazioni. Le applicazioni sono ci\u00f2 che realmente usano il sistema operativo. FreeBSD \u00e8 progettato per fornire un ambiente robusto e completo per le applicazioni. Supporta un'ampia variet\u00e0 di browser web, suite per ufficio, lettori di email, programmi di grafica, ambienti di programmazione, server di rete, e molto altro. La maggior parte di queste applicazioni pu\u00f2 essere gestita attraverso la collezione dei ports . Se un'applicazione \u00e8 disponibile solo su un sistema operativo, quel sistema operativo non pu\u00f2 essere semplicemente sostituito. \u00c8 probabile che ci sia comunque un'applicazione molto simile su FreeBSD. Come un solido server per l'ufficio o per Internet o una stazione di lavoro affidabile, FreeBSD far\u00e0 quasi certamente tutto ci\u00f2 di cui hai bisogno. Molti utenti di computer in tutto il mondo, inclusi sia principianti che esperti amministratori UNIX\u00ae, usano FreeBSD come loro unico sistema operativo desktop.","title":"FreeBSD pu\u00f2 sostituire il mio attuale sistema operativo?"},{"location":"freebsd/comparazione/","tags":["freebsd","linux"],"text":"Un'introduzione comparativa a FreeBSD per gli utenti Linux Introduzione FreeBSD \u00e8 un sistema operativo Unix-like gratuito e open source e una popolare piattaforma server. Mentre FreeBSD e altri sistemi basati su BSD condividono molto in comune con sistemi come Linux, ci sono punti in cui queste due famiglie divergono in modo importante. In questa guida, discuteremo brevemente alcuni punti in comune tra FreeBSD e Linux prima di passare a una discussione pi\u00f9 estesa sulle importanti differenze tra loro. Molti dei punti seguenti possono essere applicati con precisione alla pi\u00f9 grande famiglia dei sistemi derivati da BSD, ma come conseguenza del nostro focus, ci riferiremo principalmente a FreeBSD come rappresentante della famiglia. Tratti che FreeBSD e Linux condividono Prima di iniziare a esaminare le aree in cui FreeBSD e Linux differiscono, discutiamo in termini generali le cose che questi sistemi hanno in comune. Mentre le licenze specifiche che ogni famiglia impiega differiscono (ne parleremo pi\u00f9 avanti), entrambe queste famiglie di sistemi sono gratuite e open source. Gli utenti possono visualizzare e modificare la fonte come desiderano e lo sviluppo viene eseguito in modo aperto. Sia le distribuzioni FreeBSD che le distribuzioni basate su Linux sono di natura Unix-like. FreeBSD ha radici vicine ai sistemi Unix del passato, mentre Linux \u00e8 stato creato da zero come alternativa aperta simile a Unix. Questa aspetto influisce nelle decisioni sulla progettazione dei sistemi, su come i componenti debbano interagire e sulle aspettative generali su come il sistema debba apparire e lavorare. Il comportamento comune unix-like \u00e8 principalmente il risultato del fatto che entrambe le famiglie sono per lo pi\u00f9 conformi a POSIX. La sensazione generale e il design dei sistemi sono piuttosto standardizzati e utilizzano modelli simili. La gerarchia del filesystem \u00e8 divisa in modo simile, gli ambienti shell sono il metodo principale di interazione per entrambi i sistemi e le API di programmazione condividono caratteristiche simili. A causa di queste considerazioni, le distribuzioni FreeBSD e Linux sono in grado di condividere molti degli stessi strumenti e applicazioni. Alcuni casi impongono che le versioni o tipi di questi programmi differiscano tra i sistemi, ma le applicazioni possono essere trasferite pi\u00f9 facilmente di quanto non si possa fare con sistemi non Unix-like. Con questi punti in mente, passeremo ora a discutere le aree in cui queste due famiglie di sistemi operativi divergono. Speriamo che questi punti in comune ti aiutino a digerire pi\u00f9 accuratamente le informazioni relative alle loro differenze. Differenze di licenza Una delle differenze fondamentali tra i sistemi FreeBSD e Linux \u00e8 una questione di licenze. Il kernel Linux, le applicazioni basate su GNU e molti pezzi di software originari del mondo Linux sono concessi in licenza sotto una qualche forma di GPL, o GNU General Public License. Questa licenza \u00e8 spesso descritta come una licenza \" copyleft \", che \u00e8 una forma di licenza che consente la libert\u00e0 di visualizzare, distribuire e modificare il codice sorgente, mentre richiede che qualsiasi opera derivata mantenga tale licenza. FreeBSD d'altra parte, incluso il kernel e tutti gli strumenti creati dai contributori di FreeBSD, concede in licenza il suo software sotto una licenza BSD. Questo tipo di licenza \u00e8 pi\u00f9 permissivo della GPL in quanto non richiede lavoro derivato per mantenere i termini di licenza. Ci\u00f2 significa che qualsiasi persona o organizzazione pu\u00f2 utilizzare, distribuire o modificare il programma senza la necessit\u00e0 di apportare modifiche o rilasciare la fonte del lavoro che sta creando. Gli unici requisiti sono che il copyright originale e una copia della licenza BSD siano inclusi nel codice sorgente o nella documentazione (a seconda del metodo di rilascio) dell'opera derivata e che sia incluso un disclaimer fornito che limiti la responsabilit\u00e0. La licenza principale \u00e8 molto breve e pu\u00f2 essere visionata qui . L'attrattiva di ciascuno di questi tipi di licenza dipende quasi interamente dalla filosofia e dalle esigenze dell'utente. Le licenze GPL promuovono la condivisione e un ecosistema aperto al di sopra di ogni altra considerazione. Il software proprietario deve stare molto attento a non fare affidamento su software basato su GPL. D'altra parte, il software con licenza BSD pu\u00f2 essere liberamente incorporato in applicazioni proprietarie e closed source. Ci\u00f2 lo rende pi\u00f9 attraente per molte aziende e individui che sperano di monetizzare il loro software perch\u00e9 \u00e8 possibile vendere il software direttamente e conservare la fonte. Gli sviluppatori tendono a preferire una filosofia di licenza rispetto all'altra, ma ognuna ha i suoi vantaggi. Comprendere le licenze di questi sistemi pu\u00f2 aiutarci a iniziare a capire alcune delle scelte e della filosofia che hanno nel loro sviluppo. Il lignaggio FreeBSD e le sue implicazioni Un'altra importante differenza tra i sistemi FreeBSD e Linux \u00e8 il lignaggio e la storia di ciascun sistema. Insieme alle differenze di licenza discusse sopra, questo \u00e8 forse il pi\u00f9 grande influencer della filosofia a cui ogni campo aderisce. Linux \u00e8 un kernel sviluppato da Linus Torvalds come mezzo per sostituire il sistema MINIX orientato all'istruzione, ma restrittivo che stava usando all'Universit\u00e0 di Helsinki. Combinato con altri componenti, molti provenienti dalla suite GNU, un sistema operativo costruito sul kernel Linux ha molte propriet\u00e0 Unix-like, nonostante non sia direttamente derivato da un precedente sistema operativo Unix. Poich\u00e9 Linux \u00e8 stato avviato da zero senza alcune delle scelte di progettazione e considerazioni ereditate, pu\u00f2 differire in modo significativo dai sistemi con legami pi\u00f9 stretti con Unix. FreeBSD ha molti legami diretti con la sua eredit\u00e0 Unix. BSD, o Berkeley Software Distribution, era una distribuzione di Unix creata presso l'Universit\u00e0 della California, Berkeley, che estendeva il set di funzionalit\u00e0 del sistema operativo Unix di AT&T e aveva termini di licenza meno restrittivi. Successivamente, \u00e8 stata presa la decisione di cercare di sostituire il pi\u00f9 possibile il sistema operativo AT&T originale con alternative open source in modo che agli utenti non fosse richiesto di ottenere una licenza AT&T per utilizzare BSD. Alla fine, tutti i componenti dell'originale AT&T Unix furono riscritti sotto la licenza BSD e trasferiti sull'architettura i386 come 386BSD. FreeBSD \u00e8 stato biforcato da questa base nel tentativo di mantenere, migliorare e modernizzare il lavoro che era gi\u00e0 l\u00ec, e alla fine \u00e8 stato rifondato su una versione incompleta chiamata BSD-Lite per motivi di problemi di licenza. Attraverso il lungo e multi-stadio processo di derivazione, FreeBSD divenne libero in termini di licenze, ma mantenne stretti legami con il suo passato. Gli sviluppatori che lavoravano per creare il sistema sono rimasti aderenti al modo di operare di Unix, probabilmente perch\u00e9 FreeBSD \u00e8 sempre stato pensato per operare come un clone di Unix con licenza aperta. Queste radici hanno influenzato la direzione di ogni ulteriore sviluppo e sono la ragione dietro alcune delle scelte di cui parleremo. Separazione del sistema operativo principale dal software aggiuntivo Una differenza fondamentale in termini di sforzo di sviluppo e progettazione del sistema tra le distribuzioni FreeBSD e Linux \u00e8 la portata del sistema. Il team di FreeBSD sviluppa il kernel e il sistema operativo di base come un'unit\u00e0 coesa, mentre Linux si riferisce tecnicamente solo al kernel, con gli altri componenti provenienti da una variet\u00e0 di fonti. Questa potrebbe sembrare una piccola differenza, ma in realt\u00e0 influisce sul modo in cui interagisci e gestisci ciascun sistema. In Linux, una distribuzione potrebbe raggruppare insieme un gruppo selezionato di pacchetti, assicurando che interagiscano bene insieme. Tuttavia, la maggior parte dei componenti prorr\u00e0 da una vasta gamma di fonti e gli sviluppatori e i manutentori della distribuzione hanno il compito di modellarli in un sistema che funzioni correttamente. In questo senso, i componenti essenziali non sono molto diversi dai pacchetti opzionali disponibili attraverso i repository della distribuzione. Gli strumenti di gestione dei pacchetti della distribuzione vengono utilizzati per tracciare e gestire questi componenti esattamente allo stesso modo. Una distribuzione potrebbe mantenere repository diversi in base a quali team sono responsabili di determinati pacchetti in modo che il team di sviluppo principale debba preoccuparsi solo di un sottoinsieme del software disponibile, ma questa \u00e8 una differenza organizzativa e di messa a fuoco e generalmente non comporta differenze nella gestione del software dal punto di vista di un utente. Al contrario, FreeBSD mantiene un intero sistema operativo di base. Il kernel e una raccolta di software, molti dei quali sono creati dagli stessi sviluppatori di FreeBSD, sono mantenuti come un'unit\u00e0. Non \u00e8 cos\u00ec semplice sostituire i componenti che fanno parte di questa raccolta di base perch\u00e9 \u00e8, in un certo senso, un insieme monolitico di software. Ci\u00f2 consente al team di FreeBSD di gestire molto da vicino il sistema operativo principale, garantendo una stretta integrazione e una maggiore prevedibilit\u00e0. Il software incluso nel sistema operativo principale \u00e8 considerato completamente separato dai componenti offerti come aggiunte opzionali. FreeBSD offre una vasta collezione di software opzionale, proprio come fanno le distribuzioni Linux, ma questo \u00e8 gestito separatamente. Il sistema principale viene aggiornato come una singola unit\u00e0 in modo indipendente e il software opzionale pu\u00f2 essere aggiornato individualmente. Come si formano i rilasci La maggior parte delle versioni di Linux sono il risultato della raccolta di software da una variet\u00e0 di fonti e della sua modifica secondo necessit\u00e0. I manutentori della distribuzione decidono quali componenti includere nel supporto di installazione, quali componenti includere nei repository gestiti dalla distribuzione, ecc. Dopo aver testato i componenti insieme, viene creata una versione contenente il software testato. Nell'ultima sezione, abbiamo appreso che: Gran parte del sistema operativo FreeBSD \u00e8 sviluppato dal team di FreeBSD. Il sistema operativo di base \u00e8 l'output principale prodotto. Il software di base \u00e8 considerato un insieme coeso. Queste qualit\u00e0 portano ad un approccio diverso al rilascio di software rispetto alla maggior parte delle distribuzioni Linux. Poich\u00e9 FreeBSD organizza le cose a livello di sistema operativo, tutti i componenti di base sono mantenuti all'interno di un singolo repository di codice sorgente. Ci\u00f2 ha alcune importanti implicazioni. Prima di tutto, poich\u00e9 questi strumenti sono tutti sviluppati in tandem in un unico repository, una versione si forma semplicemente selezionando una revisione di uno dei rami del repository. Questo \u00e8 simile al modo in cui viene rilasciata la maggior parte del software in quanto un punto stabile viene selezionato da una base di codice organizzata. Poich\u00e9 il sistema operativo di base \u00e8 tutto sotto il controllo attivo della versione, ci\u00f2 significa anche che gli utenti possono \"tracciare\" diversi rami o livelli di stabilit\u00e0 a seconda di quanto stabili vogliano che siano i loro componenti di sistema. Gli utenti non devono aspettare che gli sviluppatori approvino le modifiche per inserirle nel loro sistema. Questo \u00e8 in qualche modo simile agli utenti che tracciano diversi repository organizzati per stabilit\u00e0 in alcune distribuzioni Linux. In Linux, si tiene traccia di un repository di pacchetti, mentre in FreeBSD, \u00e8 possibile tenere traccia di un ramo di un repository sorgente centralizzato. Differenze software e progettazione del sistema Le restanti differenze che discuteremo saranno legate al software stesso e alle qualit\u00e0 generali del sistema. Installazioni di pacchetti e fonti supportate Una delle principali differenze tra FreeBSD e la maggior parte delle distribuzioni Linux dal punto di vista dell'utente \u00e8 la disponibilit\u00e0 e il supporto sia del software confezionato che del software installato dal codice sorgente. Mentre la maggior parte delle distribuzioni Linux fornisce solo pacchetti binari precompilati del software supportato dalla distribuzione, FreeBSD contiene sia pacchetti pre-costruiti che un sistema di compilazione per la compilazione e l'installazione dal sorgente. Per la maggior parte dei software, questo consente di scegliere tra pacchetti precompilati costruiti con impostazioni predefinite ragionevoli e la possibilit\u00e0 di personalizzare il software durante il processo di compilazione costruendolo da soli. FreeBSD lo fa attraverso un sistema che chiama \"ports\". Il sistema dei ports FreeBSD \u00e8 una raccolta di software che FreeBSD \u00e8 in grado di costruire. Una gerarchia organizzata che rappresenta questo software \u00e8 disponibile all'interno della directory /usr/ports in cui gli utenti possono eseguire le ricerche nelle directory per ogni applicazione. Queste directory contengono alcuni file che specificano la posizione in cui \u00e8 possibile ottenere i file sorgente, cos\u00ec come le istruzioni per il compilatore su come applicare correttamente patch al sorgente per funzionare correttamente con FreeBSD. Le versioni pacchettizzate del software sono in realt\u00e0 prodotte dal sistema dei ports, rendendo FreeBSD una distribuzione source-first con pacchetti disponibili per comodit\u00e0. Il sistema pu\u00f2 essere composto sia da software compilato che preconfezionato e il sistema di gestione del software \u00e8 in grado di gestire adeguatamente una combinazione di questi due metodi di installazione. Vanilla vs Software personalizzato Una decisione che potrebbe sembrare un po 'strana agli utenti che hanno familiarit\u00e0 con alcune delle distribuzioni Linux pi\u00f9 popolari \u00e8 che FreeBSD di solito sceglie di fornire software upstream non modificato ove possibile. Molte distribuzioni Linux apportano modifiche al software per facilitare la connessione con altri componenti e per cercare di semplificare la gestione. Buoni esempi di questa tendenza sono la ristrutturazione delle comuni gerarchie di configurazione del server Web per rendere la configurazione del server pi\u00f9 modulare. Mentre molti utenti trovano utili queste modifiche, ci sono anche degli svantaggi in questo approccio. Un problema con l'apportare modifiche \u00e8 che si presume di sapere quale approccio funziona meglio per gli utenti. Rende inoltre il software pi\u00f9 imprevedibile per gli utenti provenienti da altre piattaforme, in quanto diverge dalle convenzioni a monte. I manutentori di FreeBSD spesso modificano il software con le patch, ma questi sono generalmente cambiamenti pi\u00f9 conservativi rispetto alle scelte dei pacchetti di alcune distribuzioni Linux. In generale, le modifiche al software nell'ecosistema FreeBSD sono quelle necessarie per far s\u00ec che il software sia compilato ed eseguito correttamente in un ambiente FreeBSD e quelle necessarie per definire alcune impostazioni predefinite ragionevoli. I file di configurazione che vengono inseriti nel filesystem in genere non vengono modificati pesantemente, quindi potrebbe essere necessario un po 'di lavoro extra per far s\u00ec che i componenti comunichino tra loro. FreeBSD Sapore di strumenti comuni Un altro aspetto dei sistemi FreeBSD che potrebbe causare confusione per gli utenti Linux \u00e8 la disponibilit\u00e0 di strumenti familiari che operano in modo leggermente diverso da quello che farebbero sui sistemi Linux. Il team di FreeBSD mantiene la propria versione di un gran numero di strumenti comuni. Mentre molti degli strumenti che si trovano sui sistemi Linux provengono dalla suite GNU, FreeBSD spesso lancia le proprie varianti per il suo sistema operativo. Ci sono alcune ragioni per questa decisione. Poich\u00e9 FreeBSD \u00e8 responsabile dello sviluppo e della manutenzione del sistema operativo di base, controllare lo sviluppo di queste applicazioni e metterle sotto una licenza BSD \u00e8 essenziale o utile. Alcuni di questi strumenti hanno anche stretti legami funzionali con gli strumenti BSD e Unix da cui sono stati derivati, a differenza della suite GNU, che in generale tende ad essere meno retrocompatibile. Queste differenze si manifestano spesso nelle opzioni e nella sintassi dei comandi. Potresti essere abituato a eseguire un comando in un certo modo sulle tue macchine Linux, ma questi potrebbero non funzionare allo stesso modo su un server FreeBSD. \u00c8 importante controllare sempre le pagine man dei comandi per familiarizzare con le opzioni per le varianti di FreeBSD. La Shell standard Un punto correlato che potrebbe causare una certa confusione \u00e8 che la shell predefinita in FreeBSD non \u00e8 la bash . FreeBSD usa la tcsh come shell predefinita. Questa shell \u00e8 una versione migliorata di csh, che \u00e8 la shell C sviluppata per BSD. La shell bash \u00e8 un componente GNU, il che la rende una scelta sbagliata come impostazione predefinita per FreeBSD. Mentre entrambe le shell generalmente funzionano in modo simile sulla riga di comando, lo scripting non dovrebbe essere fatto in tcsh. L'utilizzo della shell sh di base di Bourne \u00e8 pi\u00f9 affidabile ed evita alcune delle insidie ben documentate associate allo scripting tcsh e csh. Vale anche la pena notare che \u00e8 molto semplice cambiare la shell in quella che usi su linux se ti senti pi\u00f9 a tuo agio in quell'ambiente. Un filesystem pi\u00f9 stratificato Abbiamo menzionato pi\u00f9 volte sopra che FreeBSD distingue tra il sistema operativo di base e i componenti opzionali, o ports, che possono essere installati sopra a quel livello. Questo ha implicazioni nel modo in cui FreeBSD organizza i componenti nella struttura dei file. In Linux, gli eseguibili si trovano in genere nelle directory /bin , /sbin , /usr/sbin o /usr/bin a seconda del loro scopo e di quanto siano essenziali per le funzionalit\u00e0 di base. FreeBSD riconosce queste differenze, ma impone anche un altro livello di separazione tra i componenti installati come parte del sistema di base e quelli installati come ports. Il software di sistema di base risiede in una delle directory precedenti. Tutti i programmi installati come porta o pacchetto vengono inseriti in /usr/local/bin o /usr/local/sbin . La directory /usr/local contiene una struttura di directory che rispecchia principalmente la struttura trovata nella directory / o /usr . Questa \u00e8 la directory principale per il software installato tramite il sistema di ports. Quasi tutta la configurazione per i ports viene eseguita tramite file situati in /usr/local/etc mentre la configurazione del sistema di base viene mantenuta in /etc come al solito. In questo modo \u00e8 facile riconoscere se un'applicazione fa parte dei ports o del sistema di base e aiuta a mantenere pulito il filesystem. Considerazioni finali FreeBSD e Linux hanno molte cose in comune, ma se vieni da un background Linux, \u00e8 importante riconoscere e capire i modi in cui differiscono. Dove i loro percorsi divergono, entrambi i sistemi hanno i loro vantaggi, e i sostenitori di entrambi i campi possono indicare le ragioni delle scelte che sono state fatte. Trattare FreeBSD come un proprio sistema operativo invece di insistere nel visualizzarlo attraverso una lente Linux ti aiuter\u00e0 a evitare di combattere con il sistema operativo e generalmente si tradurr\u00e0 in un'esperienza migliore.","title":"Linux vs FreeBSD"},{"location":"freebsd/comparazione/#unintroduzione-comparativa-a-freebsd-per-gli-utenti-linux","text":"","title":"Un'introduzione comparativa a FreeBSD per gli utenti Linux"},{"location":"freebsd/comparazione/#introduzione","text":"FreeBSD \u00e8 un sistema operativo Unix-like gratuito e open source e una popolare piattaforma server. Mentre FreeBSD e altri sistemi basati su BSD condividono molto in comune con sistemi come Linux, ci sono punti in cui queste due famiglie divergono in modo importante. In questa guida, discuteremo brevemente alcuni punti in comune tra FreeBSD e Linux prima di passare a una discussione pi\u00f9 estesa sulle importanti differenze tra loro. Molti dei punti seguenti possono essere applicati con precisione alla pi\u00f9 grande famiglia dei sistemi derivati da BSD, ma come conseguenza del nostro focus, ci riferiremo principalmente a FreeBSD come rappresentante della famiglia.","title":"Introduzione"},{"location":"freebsd/comparazione/#tratti-che-freebsd-e-linux-condividono","text":"Prima di iniziare a esaminare le aree in cui FreeBSD e Linux differiscono, discutiamo in termini generali le cose che questi sistemi hanno in comune. Mentre le licenze specifiche che ogni famiglia impiega differiscono (ne parleremo pi\u00f9 avanti), entrambe queste famiglie di sistemi sono gratuite e open source. Gli utenti possono visualizzare e modificare la fonte come desiderano e lo sviluppo viene eseguito in modo aperto. Sia le distribuzioni FreeBSD che le distribuzioni basate su Linux sono di natura Unix-like. FreeBSD ha radici vicine ai sistemi Unix del passato, mentre Linux \u00e8 stato creato da zero come alternativa aperta simile a Unix. Questa aspetto influisce nelle decisioni sulla progettazione dei sistemi, su come i componenti debbano interagire e sulle aspettative generali su come il sistema debba apparire e lavorare. Il comportamento comune unix-like \u00e8 principalmente il risultato del fatto che entrambe le famiglie sono per lo pi\u00f9 conformi a POSIX. La sensazione generale e il design dei sistemi sono piuttosto standardizzati e utilizzano modelli simili. La gerarchia del filesystem \u00e8 divisa in modo simile, gli ambienti shell sono il metodo principale di interazione per entrambi i sistemi e le API di programmazione condividono caratteristiche simili. A causa di queste considerazioni, le distribuzioni FreeBSD e Linux sono in grado di condividere molti degli stessi strumenti e applicazioni. Alcuni casi impongono che le versioni o tipi di questi programmi differiscano tra i sistemi, ma le applicazioni possono essere trasferite pi\u00f9 facilmente di quanto non si possa fare con sistemi non Unix-like. Con questi punti in mente, passeremo ora a discutere le aree in cui queste due famiglie di sistemi operativi divergono. Speriamo che questi punti in comune ti aiutino a digerire pi\u00f9 accuratamente le informazioni relative alle loro differenze.","title":"Tratti che FreeBSD e Linux condividono"},{"location":"freebsd/comparazione/#differenze-di-licenza","text":"Una delle differenze fondamentali tra i sistemi FreeBSD e Linux \u00e8 una questione di licenze. Il kernel Linux, le applicazioni basate su GNU e molti pezzi di software originari del mondo Linux sono concessi in licenza sotto una qualche forma di GPL, o GNU General Public License. Questa licenza \u00e8 spesso descritta come una licenza \" copyleft \", che \u00e8 una forma di licenza che consente la libert\u00e0 di visualizzare, distribuire e modificare il codice sorgente, mentre richiede che qualsiasi opera derivata mantenga tale licenza. FreeBSD d'altra parte, incluso il kernel e tutti gli strumenti creati dai contributori di FreeBSD, concede in licenza il suo software sotto una licenza BSD. Questo tipo di licenza \u00e8 pi\u00f9 permissivo della GPL in quanto non richiede lavoro derivato per mantenere i termini di licenza. Ci\u00f2 significa che qualsiasi persona o organizzazione pu\u00f2 utilizzare, distribuire o modificare il programma senza la necessit\u00e0 di apportare modifiche o rilasciare la fonte del lavoro che sta creando. Gli unici requisiti sono che il copyright originale e una copia della licenza BSD siano inclusi nel codice sorgente o nella documentazione (a seconda del metodo di rilascio) dell'opera derivata e che sia incluso un disclaimer fornito che limiti la responsabilit\u00e0. La licenza principale \u00e8 molto breve e pu\u00f2 essere visionata qui . L'attrattiva di ciascuno di questi tipi di licenza dipende quasi interamente dalla filosofia e dalle esigenze dell'utente. Le licenze GPL promuovono la condivisione e un ecosistema aperto al di sopra di ogni altra considerazione. Il software proprietario deve stare molto attento a non fare affidamento su software basato su GPL. D'altra parte, il software con licenza BSD pu\u00f2 essere liberamente incorporato in applicazioni proprietarie e closed source. Ci\u00f2 lo rende pi\u00f9 attraente per molte aziende e individui che sperano di monetizzare il loro software perch\u00e9 \u00e8 possibile vendere il software direttamente e conservare la fonte. Gli sviluppatori tendono a preferire una filosofia di licenza rispetto all'altra, ma ognuna ha i suoi vantaggi. Comprendere le licenze di questi sistemi pu\u00f2 aiutarci a iniziare a capire alcune delle scelte e della filosofia che hanno nel loro sviluppo.","title":"Differenze di licenza"},{"location":"freebsd/comparazione/#il-lignaggio-freebsd-e-le-sue-implicazioni","text":"Un'altra importante differenza tra i sistemi FreeBSD e Linux \u00e8 il lignaggio e la storia di ciascun sistema. Insieme alle differenze di licenza discusse sopra, questo \u00e8 forse il pi\u00f9 grande influencer della filosofia a cui ogni campo aderisce. Linux \u00e8 un kernel sviluppato da Linus Torvalds come mezzo per sostituire il sistema MINIX orientato all'istruzione, ma restrittivo che stava usando all'Universit\u00e0 di Helsinki. Combinato con altri componenti, molti provenienti dalla suite GNU, un sistema operativo costruito sul kernel Linux ha molte propriet\u00e0 Unix-like, nonostante non sia direttamente derivato da un precedente sistema operativo Unix. Poich\u00e9 Linux \u00e8 stato avviato da zero senza alcune delle scelte di progettazione e considerazioni ereditate, pu\u00f2 differire in modo significativo dai sistemi con legami pi\u00f9 stretti con Unix. FreeBSD ha molti legami diretti con la sua eredit\u00e0 Unix. BSD, o Berkeley Software Distribution, era una distribuzione di Unix creata presso l'Universit\u00e0 della California, Berkeley, che estendeva il set di funzionalit\u00e0 del sistema operativo Unix di AT&T e aveva termini di licenza meno restrittivi. Successivamente, \u00e8 stata presa la decisione di cercare di sostituire il pi\u00f9 possibile il sistema operativo AT&T originale con alternative open source in modo che agli utenti non fosse richiesto di ottenere una licenza AT&T per utilizzare BSD. Alla fine, tutti i componenti dell'originale AT&T Unix furono riscritti sotto la licenza BSD e trasferiti sull'architettura i386 come 386BSD. FreeBSD \u00e8 stato biforcato da questa base nel tentativo di mantenere, migliorare e modernizzare il lavoro che era gi\u00e0 l\u00ec, e alla fine \u00e8 stato rifondato su una versione incompleta chiamata BSD-Lite per motivi di problemi di licenza. Attraverso il lungo e multi-stadio processo di derivazione, FreeBSD divenne libero in termini di licenze, ma mantenne stretti legami con il suo passato. Gli sviluppatori che lavoravano per creare il sistema sono rimasti aderenti al modo di operare di Unix, probabilmente perch\u00e9 FreeBSD \u00e8 sempre stato pensato per operare come un clone di Unix con licenza aperta. Queste radici hanno influenzato la direzione di ogni ulteriore sviluppo e sono la ragione dietro alcune delle scelte di cui parleremo.","title":"Il lignaggio FreeBSD e le sue implicazioni"},{"location":"freebsd/comparazione/#separazione-del-sistema-operativo-principale-dal-software-aggiuntivo","text":"Una differenza fondamentale in termini di sforzo di sviluppo e progettazione del sistema tra le distribuzioni FreeBSD e Linux \u00e8 la portata del sistema. Il team di FreeBSD sviluppa il kernel e il sistema operativo di base come un'unit\u00e0 coesa, mentre Linux si riferisce tecnicamente solo al kernel, con gli altri componenti provenienti da una variet\u00e0 di fonti. Questa potrebbe sembrare una piccola differenza, ma in realt\u00e0 influisce sul modo in cui interagisci e gestisci ciascun sistema. In Linux, una distribuzione potrebbe raggruppare insieme un gruppo selezionato di pacchetti, assicurando che interagiscano bene insieme. Tuttavia, la maggior parte dei componenti prorr\u00e0 da una vasta gamma di fonti e gli sviluppatori e i manutentori della distribuzione hanno il compito di modellarli in un sistema che funzioni correttamente. In questo senso, i componenti essenziali non sono molto diversi dai pacchetti opzionali disponibili attraverso i repository della distribuzione. Gli strumenti di gestione dei pacchetti della distribuzione vengono utilizzati per tracciare e gestire questi componenti esattamente allo stesso modo. Una distribuzione potrebbe mantenere repository diversi in base a quali team sono responsabili di determinati pacchetti in modo che il team di sviluppo principale debba preoccuparsi solo di un sottoinsieme del software disponibile, ma questa \u00e8 una differenza organizzativa e di messa a fuoco e generalmente non comporta differenze nella gestione del software dal punto di vista di un utente. Al contrario, FreeBSD mantiene un intero sistema operativo di base. Il kernel e una raccolta di software, molti dei quali sono creati dagli stessi sviluppatori di FreeBSD, sono mantenuti come un'unit\u00e0. Non \u00e8 cos\u00ec semplice sostituire i componenti che fanno parte di questa raccolta di base perch\u00e9 \u00e8, in un certo senso, un insieme monolitico di software. Ci\u00f2 consente al team di FreeBSD di gestire molto da vicino il sistema operativo principale, garantendo una stretta integrazione e una maggiore prevedibilit\u00e0. Il software incluso nel sistema operativo principale \u00e8 considerato completamente separato dai componenti offerti come aggiunte opzionali. FreeBSD offre una vasta collezione di software opzionale, proprio come fanno le distribuzioni Linux, ma questo \u00e8 gestito separatamente. Il sistema principale viene aggiornato come una singola unit\u00e0 in modo indipendente e il software opzionale pu\u00f2 essere aggiornato individualmente.","title":"Separazione del sistema operativo principale dal software aggiuntivo"},{"location":"freebsd/comparazione/#come-si-formano-i-rilasci","text":"La maggior parte delle versioni di Linux sono il risultato della raccolta di software da una variet\u00e0 di fonti e della sua modifica secondo necessit\u00e0. I manutentori della distribuzione decidono quali componenti includere nel supporto di installazione, quali componenti includere nei repository gestiti dalla distribuzione, ecc. Dopo aver testato i componenti insieme, viene creata una versione contenente il software testato. Nell'ultima sezione, abbiamo appreso che: Gran parte del sistema operativo FreeBSD \u00e8 sviluppato dal team di FreeBSD. Il sistema operativo di base \u00e8 l'output principale prodotto. Il software di base \u00e8 considerato un insieme coeso. Queste qualit\u00e0 portano ad un approccio diverso al rilascio di software rispetto alla maggior parte delle distribuzioni Linux. Poich\u00e9 FreeBSD organizza le cose a livello di sistema operativo, tutti i componenti di base sono mantenuti all'interno di un singolo repository di codice sorgente. Ci\u00f2 ha alcune importanti implicazioni. Prima di tutto, poich\u00e9 questi strumenti sono tutti sviluppati in tandem in un unico repository, una versione si forma semplicemente selezionando una revisione di uno dei rami del repository. Questo \u00e8 simile al modo in cui viene rilasciata la maggior parte del software in quanto un punto stabile viene selezionato da una base di codice organizzata. Poich\u00e9 il sistema operativo di base \u00e8 tutto sotto il controllo attivo della versione, ci\u00f2 significa anche che gli utenti possono \"tracciare\" diversi rami o livelli di stabilit\u00e0 a seconda di quanto stabili vogliano che siano i loro componenti di sistema. Gli utenti non devono aspettare che gli sviluppatori approvino le modifiche per inserirle nel loro sistema. Questo \u00e8 in qualche modo simile agli utenti che tracciano diversi repository organizzati per stabilit\u00e0 in alcune distribuzioni Linux. In Linux, si tiene traccia di un repository di pacchetti, mentre in FreeBSD, \u00e8 possibile tenere traccia di un ramo di un repository sorgente centralizzato.","title":"Come si formano i rilasci"},{"location":"freebsd/comparazione/#differenze-software-e-progettazione-del-sistema","text":"Le restanti differenze che discuteremo saranno legate al software stesso e alle qualit\u00e0 generali del sistema.","title":"Differenze software e progettazione del sistema"},{"location":"freebsd/comparazione/#installazioni-di-pacchetti-e-fonti-supportate","text":"Una delle principali differenze tra FreeBSD e la maggior parte delle distribuzioni Linux dal punto di vista dell'utente \u00e8 la disponibilit\u00e0 e il supporto sia del software confezionato che del software installato dal codice sorgente. Mentre la maggior parte delle distribuzioni Linux fornisce solo pacchetti binari precompilati del software supportato dalla distribuzione, FreeBSD contiene sia pacchetti pre-costruiti che un sistema di compilazione per la compilazione e l'installazione dal sorgente. Per la maggior parte dei software, questo consente di scegliere tra pacchetti precompilati costruiti con impostazioni predefinite ragionevoli e la possibilit\u00e0 di personalizzare il software durante il processo di compilazione costruendolo da soli. FreeBSD lo fa attraverso un sistema che chiama \"ports\". Il sistema dei ports FreeBSD \u00e8 una raccolta di software che FreeBSD \u00e8 in grado di costruire. Una gerarchia organizzata che rappresenta questo software \u00e8 disponibile all'interno della directory /usr/ports in cui gli utenti possono eseguire le ricerche nelle directory per ogni applicazione. Queste directory contengono alcuni file che specificano la posizione in cui \u00e8 possibile ottenere i file sorgente, cos\u00ec come le istruzioni per il compilatore su come applicare correttamente patch al sorgente per funzionare correttamente con FreeBSD. Le versioni pacchettizzate del software sono in realt\u00e0 prodotte dal sistema dei ports, rendendo FreeBSD una distribuzione source-first con pacchetti disponibili per comodit\u00e0. Il sistema pu\u00f2 essere composto sia da software compilato che preconfezionato e il sistema di gestione del software \u00e8 in grado di gestire adeguatamente una combinazione di questi due metodi di installazione.","title":"Installazioni di pacchetti e fonti supportate"},{"location":"freebsd/comparazione/#vanilla-vs-software-personalizzato","text":"Una decisione che potrebbe sembrare un po 'strana agli utenti che hanno familiarit\u00e0 con alcune delle distribuzioni Linux pi\u00f9 popolari \u00e8 che FreeBSD di solito sceglie di fornire software upstream non modificato ove possibile. Molte distribuzioni Linux apportano modifiche al software per facilitare la connessione con altri componenti e per cercare di semplificare la gestione. Buoni esempi di questa tendenza sono la ristrutturazione delle comuni gerarchie di configurazione del server Web per rendere la configurazione del server pi\u00f9 modulare. Mentre molti utenti trovano utili queste modifiche, ci sono anche degli svantaggi in questo approccio. Un problema con l'apportare modifiche \u00e8 che si presume di sapere quale approccio funziona meglio per gli utenti. Rende inoltre il software pi\u00f9 imprevedibile per gli utenti provenienti da altre piattaforme, in quanto diverge dalle convenzioni a monte. I manutentori di FreeBSD spesso modificano il software con le patch, ma questi sono generalmente cambiamenti pi\u00f9 conservativi rispetto alle scelte dei pacchetti di alcune distribuzioni Linux. In generale, le modifiche al software nell'ecosistema FreeBSD sono quelle necessarie per far s\u00ec che il software sia compilato ed eseguito correttamente in un ambiente FreeBSD e quelle necessarie per definire alcune impostazioni predefinite ragionevoli. I file di configurazione che vengono inseriti nel filesystem in genere non vengono modificati pesantemente, quindi potrebbe essere necessario un po 'di lavoro extra per far s\u00ec che i componenti comunichino tra loro.","title":"Vanilla vs Software personalizzato"},{"location":"freebsd/comparazione/#freebsd-sapore-di-strumenti-comuni","text":"Un altro aspetto dei sistemi FreeBSD che potrebbe causare confusione per gli utenti Linux \u00e8 la disponibilit\u00e0 di strumenti familiari che operano in modo leggermente diverso da quello che farebbero sui sistemi Linux. Il team di FreeBSD mantiene la propria versione di un gran numero di strumenti comuni. Mentre molti degli strumenti che si trovano sui sistemi Linux provengono dalla suite GNU, FreeBSD spesso lancia le proprie varianti per il suo sistema operativo. Ci sono alcune ragioni per questa decisione. Poich\u00e9 FreeBSD \u00e8 responsabile dello sviluppo e della manutenzione del sistema operativo di base, controllare lo sviluppo di queste applicazioni e metterle sotto una licenza BSD \u00e8 essenziale o utile. Alcuni di questi strumenti hanno anche stretti legami funzionali con gli strumenti BSD e Unix da cui sono stati derivati, a differenza della suite GNU, che in generale tende ad essere meno retrocompatibile. Queste differenze si manifestano spesso nelle opzioni e nella sintassi dei comandi. Potresti essere abituato a eseguire un comando in un certo modo sulle tue macchine Linux, ma questi potrebbero non funzionare allo stesso modo su un server FreeBSD. \u00c8 importante controllare sempre le pagine man dei comandi per familiarizzare con le opzioni per le varianti di FreeBSD.","title":"FreeBSD Sapore  di strumenti comuni"},{"location":"freebsd/comparazione/#la-shell-standard","text":"Un punto correlato che potrebbe causare una certa confusione \u00e8 che la shell predefinita in FreeBSD non \u00e8 la bash . FreeBSD usa la tcsh come shell predefinita. Questa shell \u00e8 una versione migliorata di csh, che \u00e8 la shell C sviluppata per BSD. La shell bash \u00e8 un componente GNU, il che la rende una scelta sbagliata come impostazione predefinita per FreeBSD. Mentre entrambe le shell generalmente funzionano in modo simile sulla riga di comando, lo scripting non dovrebbe essere fatto in tcsh. L'utilizzo della shell sh di base di Bourne \u00e8 pi\u00f9 affidabile ed evita alcune delle insidie ben documentate associate allo scripting tcsh e csh. Vale anche la pena notare che \u00e8 molto semplice cambiare la shell in quella che usi su linux se ti senti pi\u00f9 a tuo agio in quell'ambiente.","title":"La Shell standard"},{"location":"freebsd/comparazione/#un-filesystem-piu-stratificato","text":"Abbiamo menzionato pi\u00f9 volte sopra che FreeBSD distingue tra il sistema operativo di base e i componenti opzionali, o ports, che possono essere installati sopra a quel livello. Questo ha implicazioni nel modo in cui FreeBSD organizza i componenti nella struttura dei file. In Linux, gli eseguibili si trovano in genere nelle directory /bin , /sbin , /usr/sbin o /usr/bin a seconda del loro scopo e di quanto siano essenziali per le funzionalit\u00e0 di base. FreeBSD riconosce queste differenze, ma impone anche un altro livello di separazione tra i componenti installati come parte del sistema di base e quelli installati come ports. Il software di sistema di base risiede in una delle directory precedenti. Tutti i programmi installati come porta o pacchetto vengono inseriti in /usr/local/bin o /usr/local/sbin . La directory /usr/local contiene una struttura di directory che rispecchia principalmente la struttura trovata nella directory / o /usr . Questa \u00e8 la directory principale per il software installato tramite il sistema di ports. Quasi tutta la configurazione per i ports viene eseguita tramite file situati in /usr/local/etc mentre la configurazione del sistema di base viene mantenuta in /etc come al solito. In questo modo \u00e8 facile riconoscere se un'applicazione fa parte dei ports o del sistema di base e aiuta a mantenere pulito il filesystem.","title":"Un filesystem pi\u00f9 stratificato"},{"location":"freebsd/comparazione/#considerazioni-finali","text":"FreeBSD e Linux hanno molte cose in comune, ma se vieni da un background Linux, \u00e8 importante riconoscere e capire i modi in cui differiscono. Dove i loro percorsi divergono, entrambi i sistemi hanno i loro vantaggi, e i sostenitori di entrambi i campi possono indicare le ragioni delle scelte che sono state fatte. Trattare FreeBSD come un proprio sistema operativo invece di insistere nel visualizzarlo attraverso una lente Linux ti aiuter\u00e0 a evitare di combattere con il sistema operativo e generalmente si tradurr\u00e0 in un'esperienza migliore.","title":"Considerazioni finali"},{"location":"freebsd/freebsd_ipfw/","tags":["freebsd","firewall"],"text":"FreeBSD ha tre firewall integrati nel sistema di base: PF, IPFW e IPFILTER, noto anche come IPF. FreeBSD fornisce pi\u00f9 firewall per soddisfare i diversi requisiti e preferenze per un'ampia variet\u00e0 di utenti. Ogni utente dovrebbe valutare quale firewall soddisfa meglio le proprie esigenze. In questo articolo tratteremo nello specifico il firewall IPFW. Concetti relativi al firewall Un set di regole contiene un gruppo di regole che lasciano passare o bloccano i pacchetti in base ai valori contenuti nel pacchetto. Lo scambio bidirezionale di pacchetti tra host comprende una conversazione di sessione. Il set di regole del firewall elabora sia i pacchetti che arrivano dalla rete Internet, sia i pacchetti prodotti dal sistema come risposta ad essi. Ogni servizio TCP/IP \u00e8 predefinito dal protocollo e dalla porta di ascolto. I pacchetti destinati a un servizio specifico provengono dall'indirizzo di origine utilizzando una porta senza privilegi e sono destinati alla porta del servizio specifica sull'indirizzo di destinazione. Tutti i parametri di cui sopra possono essere utilizzati come criteri di selezione per creare regole che permetteranno o bloccheranno i servizi. Un set di regole del firewall pu\u00f2 essere \"esclusivo\" o \"inclusivo\". Un firewall esclusivo consente tutto il traffico ad eccezione del traffico corrispondente al set di regole. Un firewall inclusivo fa il contrario in quanto consente solo il traffico che corrisponde alle regole e blocca tutto il resto. Un firewall inclusivo offre un migliore controllo del traffico in uscita, rendendolo una scelta migliore per i sistemi che offrono servizi verso Internet. Controlla anche il tipo di traffico proveniente da Internet che pu\u00f2 accedere ad una rete privata. Tutto il traffico che non corrisponde alle regole viene bloccato e registrato. I firewall inclusivi sono generalmente pi\u00f9 sicuri dei firewall esclusivi perch\u00e9 riducono significativamente il rischio di consentire il traffico indesiderato. La sicurezza pu\u00f2 essere ulteriormente rafforzata utilizzando un \" firewall stateful \". Questo tipo di firewall tiene traccia delle connessioni aperte e consente solo il traffico che corrisponde a una connessione esistente o apre una nuova connessione consentita. Il filtro con stato considera il traffico come uno scambio bidirezionale di pacchetti di sessione. Quando lo stato viene specificato in una regola di corrispondenza, il firewall genera dinamicamente regole interne per ogni pacchetto previsto che viene scambiato durante la sessione. Dispone di funzionalit\u00e0 di corrispondenza sufficienti per determinare se un pacchetto \u00e8 valido per la sessione. Tutti i pacchetti che non si adattano correttamente al modello di sessione vengono automaticamente rifiutati. Al termine della sessione, questa viene rimossa dalla tabella degli stati dinamici. Il filtro stateful consente di concentrarsi sul blocco/passaggio di nuove sessioni. Se la nuova sessione viene superata, tutti i pacchetti successivi vengono consentiti automaticamente e tutti i pacchetti impostore vengono automaticamente rifiutati. Se una nuova sessione viene bloccata, a nessuno dei pacchetti successivi \u00e8 consentito passare. Il filtro stateful fornisce funzionalit\u00e0 di corrispondenza avanzate in grado di difendersi dal flusso di diversi metodi di attacco impiegati dagli aggressori. NAT \u00e8 l'acronimo di Network Address Translation. La funzione NAT consente alla LAN privata dietro il firewall di condividere un singolo indirizzo IP assegnato dall'ISP, anche se tale indirizzo viene assegnato dinamicamente. NAT consente a ciascun computer della LAN di avere accesso a Internet. NAT tradurr\u00e0 automaticamente l'indirizzo IP LAN privato per ciascun sistema nella LAN nel singolo indirizzo IP pubblico quando i pacchetti escono dal firewall verso Internet. Esegue anche la traduzione inversa per la restituzione dei pacchetti. Secondo l'RFC 1918, i seguenti intervalli di indirizzi IP sono riservati alle reti private che non verranno mai instradate direttamente a Internet e quindi sono disponibili per l'uso con NAT: 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 Attenzione Quando si lavora con le regole del firewall, fare molta attenzione. Alcune configurazioni possono bloccare l'amministratore fuori dal server. Per andare sul sicuro, considera di eseguire la configurazione iniziale del firewall dalla console locale piuttosto che farlo in remoto su ssh. IPFW IPFW \u00e8 un firewall stateful scritto per FreeBSD che supporta sia IPv4 che IPv6. \u00c8 composto da diversi componenti: il processore di regole del filtro firewall del kernel e la sua struttura di amministrazione dei pacchetti integrata, la funzione di registrazione, NAT, lo shaper del traffico dummynet , una struttura in avanti, una struttura bridge e una struttura ipstealth. FreeBSD fornisce un set di regole di esempio in /etc/rc.firewall che definisce diversi tipi di firewall per scenari comuni, questo per aiutare gli utenti inesperti a generare un set di regole appropriato. IPFW fornisce una potente sintassi che gli utenti avanzati possono utilizzare per creare set di regole personalizzate che soddisfano i requisiti di sicurezza di un determinato ambiente. Abilitazione di IPFW IPFW \u00e8 incluso nell'installazione di base di FreeBSD come modulo caricabile del kernel, il che significa che non \u00e8 necessario un kernel personalizzato per abilitare IPFW. Per configurare il sistema in modo da abilitare IPFW al momento dell'avvio, aggiungere firewall_enable=\"YES\" a /etc/rc.conf : sysrc firewall_enable = \"YES\" Per utilizzare uno dei tipi di firewall predefiniti forniti da FreeBSD, aggiungi un'altra riga che specifica il tipo: sysrc firewall_type = \"client\" Le tipologie disponibili sono: aperto: passa tutto il traffico. client: protegge solo questa macchina. semplice: protegge l'intera rete. chiuso: disabilita completamente il traffico IP ad eccezione dell'interfaccia di loopback. workstation: protegge solo questa macchina utilizzando regole stateful. UNKNOWN: disabilita il caricamento delle regole del firewall. nomefile: percorso completo del file contenente il set di regole del firewall. Se il tipo di firewall \u00e8 impostato su client o semplice , modificare le regole predefinite presenti in /etc/rc.firewall per adattarle alla configurazione del sistema. Nota Con la selezione nomefile il nome del file viene utilizzato per caricare un set di regole personalizzate. Per abilitare la registrazione tramite syslogd , includere questa riga: sysrc firewall_logging = \"YES\" Attenzione Verranno registrate solo le regole del firewall con l'opzione di registro. Le regole predefinite non includono questa opzione e devono essere aggiunte manualmente. Pertanto \u00e8 consigliabile modificare il set di regole predefinito per la registrazione. Inoltre, se i registri sono memorizzati in un file separato \u00e8 consigliata la rotazione dei registri. Non esiste una variabile /etc/rc.conf per impostare i limiti di registrazione. Per limitare il numero di volte in cui una regola viene registrata per tentativo di connessione, specificare il numero utilizzando questa riga in /etc/sysctl.conf : echo \"net.inet.ip.fw.verbose_limit=5\" >> /etc/sysctl.conf Dopo aver salvato le modifiche necessarie, avviare il firewall. Per abilitare ora i limiti di registrazione, impostare anche il valore sysctl specificato sopra: service ipfw start sysctl net.inet.ip.fw.verbose_limit = 5 Il comando IPFW Ipfw pu\u00f2 essere utilizzato per effettuare aggiunte o eliminazioni manuali di singole regole al firewall attivo mentre \u00e8 in esecuzione. Il problema con l'utilizzo di questo metodo \u00e8 che tutte le modifiche vengono perse al riavvio del sistema. Si consiglia invece di scrivere tutte le regole in un file e di utilizzare tale file per caricare le regole al momento dell'avvio e per sostituire le regole del firewall attualmente in esecuzione ogni volta che il file cambia. ipfw \u00e8 un modo utile per visualizzare le regole del firewall in esecuzione sullo schermo della console. La funzione di amministrazione di IPFW crea dinamicamente un contatore per ogni regola che conta ogni pacchetto che corrisponde alla regola. Durante il processo di test di una regola, elencare la regola con il relativo contatore \u00e8 un modo per determinare se la regola funziona come previsto. Per elencare tutte le regole di esecuzione in sequenza: ipfw list Per elencare tutte le regole in esecuzione con un timestamp di quando \u00e8 stata abbinata l'ultima volta che la regola \u00e8 stata riscontrata: ipfw -t list Firewall in Sintesi Dopo aver esplorato gli aspetti tecnici e teorici del firewall BSD possiamo passare a configurare la nostra macchina server con una configurazione base che per\u00f2 permette gi\u00e0 un livello di sicurezza discreto: Per rendere il firewall attivo all'avvio: sysrc firewall_enable = \"YES\" Per renderlo \"silenzioso\", in modo che non richieda ai messaggi di eseguire azioni nella shell: sysrc firewall_quiet = \"YES\" Per proteggere solo il nostro server con un firewall statefull digiteremo: sysrc firewall_type = \"workstation\" Per consentire i servizi di cui abbiamo bisogno, SSH e HTTP ad esempio, imposteremo quanto segue: sysrc firewall_myservices = \"22/tcp 80/tcp\" \u00c8 possibile aggiungere pi\u00f9 servizi, come HTTPS, utilizzando una voce come \"443/tcp\" o anche impostandola per nome \"https\". Per consentire a qualsiasi IP esterno di utilizzare i servizi di cui sopra, digiteremo: sysrc firewall_allowservices = \"any\" Per registrare gli accessi negati, sia perch\u00e9 mancanti della chiave ssh, o perch\u00e9 stanno tentando di aprire una porta che non abbiamo abilitato, ecc., eseguiremo il seguente comando: sysrc firewall_logdeny = \"YES\" Per verificare che le righe siano state correttamente aggiunte al file /etc/rc.conf possiamo usare il seguente comando: cat /etc/rc.conf | grep firewall Come output dovremmo ottenere quanto segue: firewall_enable = \"YES\" firewall_quiet = \"YES\" firewall_type = \"workstation\" firewall_myservices = \"22/tcp 443/tcp\" firewall_allowservices = \"any\" firewall_logdeny = \"YES\" Ora siamo pronti per avviare il firewall IPFW. service ipfw start Per verificare che funzioni useremo: service ipfw status Come output dovremmo ottenere qualcosa del genere: ipfw is enabled Se tutto \u00e8 andato per il verso giusto la nostra macchina ora ha il firewall attivato e configurato.","title":"Firewall IPFW su FreeBSD"},{"location":"freebsd/freebsd_ipfw/#concetti-relativi-al-firewall","text":"Un set di regole contiene un gruppo di regole che lasciano passare o bloccano i pacchetti in base ai valori contenuti nel pacchetto. Lo scambio bidirezionale di pacchetti tra host comprende una conversazione di sessione. Il set di regole del firewall elabora sia i pacchetti che arrivano dalla rete Internet, sia i pacchetti prodotti dal sistema come risposta ad essi. Ogni servizio TCP/IP \u00e8 predefinito dal protocollo e dalla porta di ascolto. I pacchetti destinati a un servizio specifico provengono dall'indirizzo di origine utilizzando una porta senza privilegi e sono destinati alla porta del servizio specifica sull'indirizzo di destinazione. Tutti i parametri di cui sopra possono essere utilizzati come criteri di selezione per creare regole che permetteranno o bloccheranno i servizi. Un set di regole del firewall pu\u00f2 essere \"esclusivo\" o \"inclusivo\". Un firewall esclusivo consente tutto il traffico ad eccezione del traffico corrispondente al set di regole. Un firewall inclusivo fa il contrario in quanto consente solo il traffico che corrisponde alle regole e blocca tutto il resto. Un firewall inclusivo offre un migliore controllo del traffico in uscita, rendendolo una scelta migliore per i sistemi che offrono servizi verso Internet. Controlla anche il tipo di traffico proveniente da Internet che pu\u00f2 accedere ad una rete privata. Tutto il traffico che non corrisponde alle regole viene bloccato e registrato. I firewall inclusivi sono generalmente pi\u00f9 sicuri dei firewall esclusivi perch\u00e9 riducono significativamente il rischio di consentire il traffico indesiderato. La sicurezza pu\u00f2 essere ulteriormente rafforzata utilizzando un \" firewall stateful \". Questo tipo di firewall tiene traccia delle connessioni aperte e consente solo il traffico che corrisponde a una connessione esistente o apre una nuova connessione consentita. Il filtro con stato considera il traffico come uno scambio bidirezionale di pacchetti di sessione. Quando lo stato viene specificato in una regola di corrispondenza, il firewall genera dinamicamente regole interne per ogni pacchetto previsto che viene scambiato durante la sessione. Dispone di funzionalit\u00e0 di corrispondenza sufficienti per determinare se un pacchetto \u00e8 valido per la sessione. Tutti i pacchetti che non si adattano correttamente al modello di sessione vengono automaticamente rifiutati. Al termine della sessione, questa viene rimossa dalla tabella degli stati dinamici. Il filtro stateful consente di concentrarsi sul blocco/passaggio di nuove sessioni. Se la nuova sessione viene superata, tutti i pacchetti successivi vengono consentiti automaticamente e tutti i pacchetti impostore vengono automaticamente rifiutati. Se una nuova sessione viene bloccata, a nessuno dei pacchetti successivi \u00e8 consentito passare. Il filtro stateful fornisce funzionalit\u00e0 di corrispondenza avanzate in grado di difendersi dal flusso di diversi metodi di attacco impiegati dagli aggressori. NAT \u00e8 l'acronimo di Network Address Translation. La funzione NAT consente alla LAN privata dietro il firewall di condividere un singolo indirizzo IP assegnato dall'ISP, anche se tale indirizzo viene assegnato dinamicamente. NAT consente a ciascun computer della LAN di avere accesso a Internet. NAT tradurr\u00e0 automaticamente l'indirizzo IP LAN privato per ciascun sistema nella LAN nel singolo indirizzo IP pubblico quando i pacchetti escono dal firewall verso Internet. Esegue anche la traduzione inversa per la restituzione dei pacchetti. Secondo l'RFC 1918, i seguenti intervalli di indirizzi IP sono riservati alle reti private che non verranno mai instradate direttamente a Internet e quindi sono disponibili per l'uso con NAT: 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 Attenzione Quando si lavora con le regole del firewall, fare molta attenzione. Alcune configurazioni possono bloccare l'amministratore fuori dal server. Per andare sul sicuro, considera di eseguire la configurazione iniziale del firewall dalla console locale piuttosto che farlo in remoto su ssh.","title":"Concetti relativi al firewall"},{"location":"freebsd/freebsd_ipfw/#ipfw","text":"IPFW \u00e8 un firewall stateful scritto per FreeBSD che supporta sia IPv4 che IPv6. \u00c8 composto da diversi componenti: il processore di regole del filtro firewall del kernel e la sua struttura di amministrazione dei pacchetti integrata, la funzione di registrazione, NAT, lo shaper del traffico dummynet , una struttura in avanti, una struttura bridge e una struttura ipstealth. FreeBSD fornisce un set di regole di esempio in /etc/rc.firewall che definisce diversi tipi di firewall per scenari comuni, questo per aiutare gli utenti inesperti a generare un set di regole appropriato. IPFW fornisce una potente sintassi che gli utenti avanzati possono utilizzare per creare set di regole personalizzate che soddisfano i requisiti di sicurezza di un determinato ambiente.","title":"IPFW"},{"location":"freebsd/freebsd_ipfw/#abilitazione-di-ipfw","text":"IPFW \u00e8 incluso nell'installazione di base di FreeBSD come modulo caricabile del kernel, il che significa che non \u00e8 necessario un kernel personalizzato per abilitare IPFW. Per configurare il sistema in modo da abilitare IPFW al momento dell'avvio, aggiungere firewall_enable=\"YES\" a /etc/rc.conf : sysrc firewall_enable = \"YES\" Per utilizzare uno dei tipi di firewall predefiniti forniti da FreeBSD, aggiungi un'altra riga che specifica il tipo: sysrc firewall_type = \"client\" Le tipologie disponibili sono: aperto: passa tutto il traffico. client: protegge solo questa macchina. semplice: protegge l'intera rete. chiuso: disabilita completamente il traffico IP ad eccezione dell'interfaccia di loopback. workstation: protegge solo questa macchina utilizzando regole stateful. UNKNOWN: disabilita il caricamento delle regole del firewall. nomefile: percorso completo del file contenente il set di regole del firewall. Se il tipo di firewall \u00e8 impostato su client o semplice , modificare le regole predefinite presenti in /etc/rc.firewall per adattarle alla configurazione del sistema. Nota Con la selezione nomefile il nome del file viene utilizzato per caricare un set di regole personalizzate. Per abilitare la registrazione tramite syslogd , includere questa riga: sysrc firewall_logging = \"YES\" Attenzione Verranno registrate solo le regole del firewall con l'opzione di registro. Le regole predefinite non includono questa opzione e devono essere aggiunte manualmente. Pertanto \u00e8 consigliabile modificare il set di regole predefinito per la registrazione. Inoltre, se i registri sono memorizzati in un file separato \u00e8 consigliata la rotazione dei registri. Non esiste una variabile /etc/rc.conf per impostare i limiti di registrazione. Per limitare il numero di volte in cui una regola viene registrata per tentativo di connessione, specificare il numero utilizzando questa riga in /etc/sysctl.conf : echo \"net.inet.ip.fw.verbose_limit=5\" >> /etc/sysctl.conf Dopo aver salvato le modifiche necessarie, avviare il firewall. Per abilitare ora i limiti di registrazione, impostare anche il valore sysctl specificato sopra: service ipfw start sysctl net.inet.ip.fw.verbose_limit = 5","title":"Abilitazione di IPFW"},{"location":"freebsd/freebsd_ipfw/#il-comando-ipfw","text":"Ipfw pu\u00f2 essere utilizzato per effettuare aggiunte o eliminazioni manuali di singole regole al firewall attivo mentre \u00e8 in esecuzione. Il problema con l'utilizzo di questo metodo \u00e8 che tutte le modifiche vengono perse al riavvio del sistema. Si consiglia invece di scrivere tutte le regole in un file e di utilizzare tale file per caricare le regole al momento dell'avvio e per sostituire le regole del firewall attualmente in esecuzione ogni volta che il file cambia. ipfw \u00e8 un modo utile per visualizzare le regole del firewall in esecuzione sullo schermo della console. La funzione di amministrazione di IPFW crea dinamicamente un contatore per ogni regola che conta ogni pacchetto che corrisponde alla regola. Durante il processo di test di una regola, elencare la regola con il relativo contatore \u00e8 un modo per determinare se la regola funziona come previsto. Per elencare tutte le regole di esecuzione in sequenza: ipfw list Per elencare tutte le regole in esecuzione con un timestamp di quando \u00e8 stata abbinata l'ultima volta che la regola \u00e8 stata riscontrata: ipfw -t list","title":"Il comando IPFW"},{"location":"freebsd/freebsd_ipfw/#firewall-in-sintesi","text":"Dopo aver esplorato gli aspetti tecnici e teorici del firewall BSD possiamo passare a configurare la nostra macchina server con una configurazione base che per\u00f2 permette gi\u00e0 un livello di sicurezza discreto: Per rendere il firewall attivo all'avvio: sysrc firewall_enable = \"YES\" Per renderlo \"silenzioso\", in modo che non richieda ai messaggi di eseguire azioni nella shell: sysrc firewall_quiet = \"YES\" Per proteggere solo il nostro server con un firewall statefull digiteremo: sysrc firewall_type = \"workstation\" Per consentire i servizi di cui abbiamo bisogno, SSH e HTTP ad esempio, imposteremo quanto segue: sysrc firewall_myservices = \"22/tcp 80/tcp\" \u00c8 possibile aggiungere pi\u00f9 servizi, come HTTPS, utilizzando una voce come \"443/tcp\" o anche impostandola per nome \"https\". Per consentire a qualsiasi IP esterno di utilizzare i servizi di cui sopra, digiteremo: sysrc firewall_allowservices = \"any\" Per registrare gli accessi negati, sia perch\u00e9 mancanti della chiave ssh, o perch\u00e9 stanno tentando di aprire una porta che non abbiamo abilitato, ecc., eseguiremo il seguente comando: sysrc firewall_logdeny = \"YES\" Per verificare che le righe siano state correttamente aggiunte al file /etc/rc.conf possiamo usare il seguente comando: cat /etc/rc.conf | grep firewall Come output dovremmo ottenere quanto segue: firewall_enable = \"YES\" firewall_quiet = \"YES\" firewall_type = \"workstation\" firewall_myservices = \"22/tcp 443/tcp\" firewall_allowservices = \"any\" firewall_logdeny = \"YES\" Ora siamo pronti per avviare il firewall IPFW. service ipfw start Per verificare che funzioni useremo: service ipfw status Come output dovremmo ottenere qualcosa del genere: ipfw is enabled Se tutto \u00e8 andato per il verso giusto la nostra macchina ora ha il firewall attivato e configurato.","title":"Firewall in Sintesi"},{"location":"freebsd/FreeBSD_su_RPI4/01_installazione/","tags":["freebsd","raspberry"],"text":"Introduzione FreeBSD \u00e8 uno dei sistemi operativi che potete installare su Raspberry Pi per sperimentare un po' al di fuori di Linux. FreeBSD \u00e8 un sistema operativo open-source, disponibile su Raspberry Pi dal 2014, ed \u00e8 una buona soluzione per un uso server, un p\u00f2 meno per uso desktop, visto la mancanza tutt'ora di un driver per il modulo WiFi. Se installata e avviata da disco SSD permette di avere un server in grado di compiere tutti i compiti pi\u00f9 comuni. Per installare un sistema FreeBSD di base sul vostro Raspberry Pi i passaggi da eseguire sono: Scaricare l'ultima versione ufficiale (immagine 13.x RELEASE). Scrivere l'immagine sul disco SSD. Avviare il Raspberry Pi 4 e iniziare la configurazione del sistema. Nota Il Raspberry Pi 4 non \u00e8 supportato nelle versione 12.x e precedenti. Download FreeBSD offre immagini pre-costruite per l'architettura ARM e ARM64. La versione ARM64 funziona bene su Pi 3B+ e 4. Ecco il link generale al server FTP: https://download.freebsd.org/ftp/ La versione da scaricare al momento \u00e8: FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img.xz Per scaricare dal mirror italiano del consorzio GARR usate questo link diretto e scaricate anche il CHECKSUM per verificare il corretto scaricamento dell'immagine. Verifica dell'Immagine Una volta scaricata possiamo verificare l'integrit\u00e0 dell'immagine con il comando sh256sum . sha256sum -c CHECKSUM.SHA256-FreeBSD-13.0-RELEASE-arm64-aarch64-RPI FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img.xz: OK Preparazione del disco SSD Decompressione dell'immagine Una volta ottenuta l'immagine compressa del disco (compressa con 'xz'), \u00e8 necessario estrarla in un'immagine binaria. Usa l'utilit\u00e0 'xz' (in Linux o FreeBSD) come segue: xz --decompress FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img.xz . \u251c\u2500\u2500 CHECKSUM.SHA256-FreeBSD-13.0-RELEASE-arm64-aarch64-RPI \u2514\u2500\u2500 FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img Questo vi dar\u00e0 il file immagine raw, FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img . Scrittura sul supporto Successivamente, dovrai collegare il tuo disco sd al tuo computer Linux o FreeBSD, ma NON permettere che venga 'montato automaticamente' (potresti doverlo smontare forzatamente se la tua GUI lo monta in automatico). Poi, una volta che il disco appare nell'albero dei dispositivi '/dev/', dovrai sovrascrivere la partizione primaria con il contenuto del file '.img' che hai estratto prima. ll /dev/d* ... crw-r----- 1 root operator 0x5f Apr 9 23 :00 /dev/da0 crw-r----- 1 root operator 0x60 Apr 9 23 :00 /dev/da0s1 crw-r----- 1 root operator 0x61 Apr 9 23 :00 /dev/da0s2 ... Su un sistema FreeBSD, se c'\u00e8 un solo disco di sistema il disco SSD che avete collegato probabilmente avr\u00e0 un nome di dispositivo simile a '/dev/da0'. Se il disco ha gi\u00e0 un file system, potrebbero esserci anche altre voci come '/dev/da0s1' o come nell'esempio delle partizioni Linux. La voce che vuoi sovrascrivere \u00e8 il dispositivo 'root', '/dev/da0'. Su Linux la denominazione dei dispositivi \u00e8 simile (dovrebbe somigliare a qualcosa di simile a sdb ). Se non sei sicuro di quale dispositivo usare, puoi utilizzare il comando gpart show per visualizzare la geometria dei dischi sul sistema. gpart show = > 40 500118112 ada0 GPT ( 238G ) 40 532480 1 efi ( 260M ) 532520 1024 2 freebsd-boot ( 512K ) 533544 984 - free - ( 492K ) 534528 4194304 3 freebsd-swap ( 2 .0G ) 4728832 495388672 4 freebsd-zfs ( 236G ) 500117504 648 - free - ( 324K ) = > 34 234441581 da0 GPT ( 112G ) 34 2014 - free - ( 1 .0M ) 2048 1228800 1 efi ( 600M ) 1230848 2097152 2 linux-data ( 1 .0G ) 3328000 231112704 3 linux-lvm ( 110G ) 234440704 911 - free - ( 456K ) Assumendo che tu stia usando FreeBSD e che il disco sia '/dev/da0', usa il seguente comando per scrivere l'immagine: dd if = FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img of = /dev/da0 bs = 1M conv = noerror,sync Il parametro conv=noerror,sync riempie il resto dell'immagine con una sequenza di zeri, necessari quando si specifica una dimensione di blocco non predefinita. E la dimensione del blocco di 1M in realt\u00e0 accelera abbastanza il processo. A questo punto dovreste avere il vostro disco SSD con FeeBSD pronta all'uso. Smontate se necessario e scollegate il disco dal computer utilizzato per la scrittura dell'immagine. Primo avvio Colleghiamo il disco SSD ad una porta USB della RPI4 e il cavo di rete. A questo punto per accedere al sistema abbiamo due possibilit\u00e0, collegare alla nostra Raspberry un monitor con tastiera e mouse ed accedere localmente o utilizzare una connessione SSH (headless) per accedervi in remoto da qualche altra postazione di lavoro. FreeBSD ha l'accesso SSH abilitato per impostazione predefinita. Il primo avvio richieder\u00e0 del tempo aggiuntivo poich\u00e8 l'immagine di FreeBSD per aarch64 ha impostato di default l'opzione per espandere la partizione root alla dimensione massima. growfs_enable = \"YES\" Accedere al sistema Nell'installazione standard su RPI4 sono disponibili due utenti: freebsd \u00e8 l'utente predefinito, la password \u00e8 'freebsd' root \u00e8 l'amministratore, la password \u00e8 'root' Importante L'installazione crea gli utenti in maniera standardizzata e chiaramente la prima cosa da fare \u00e8 mettere in sicurezza gli accessi modificando la password di root . In bsdconfig c'\u00e8 una voce specifica per la modifica della password di root. All'avvio se avete scelto la configurazione locale, apparir\u00e0 un prompt del terminale dove vi verr\u00e0 richiesto di effettuare il login. Connettevi come amministratore root per continuare la configurazione. Se invece state accedendo da remoto con SSH dovrete necessariamente accedere con l'utenza predefinita freebsd e successivamente ottenere i privilegi di amministratore con su ssh -l freebsd ip_della_RPI4 freebsd@freebsd:~ % su Password: root@dfreebsd:/home/freebsd # Sudo in FreeBSD Non c'\u00e8 nessun comando sudo disponibile su una installazione FreeBSD, e anche se disponibile all'installazione nei ports non \u00e8 consigliata dagli sviluppatori di FreeBSD. A questo punto possiamo iniziare la configurazione .","title":"Installazione"},{"location":"freebsd/FreeBSD_su_RPI4/01_installazione/#introduzione","text":"FreeBSD \u00e8 uno dei sistemi operativi che potete installare su Raspberry Pi per sperimentare un po' al di fuori di Linux. FreeBSD \u00e8 un sistema operativo open-source, disponibile su Raspberry Pi dal 2014, ed \u00e8 una buona soluzione per un uso server, un p\u00f2 meno per uso desktop, visto la mancanza tutt'ora di un driver per il modulo WiFi. Se installata e avviata da disco SSD permette di avere un server in grado di compiere tutti i compiti pi\u00f9 comuni. Per installare un sistema FreeBSD di base sul vostro Raspberry Pi i passaggi da eseguire sono: Scaricare l'ultima versione ufficiale (immagine 13.x RELEASE). Scrivere l'immagine sul disco SSD. Avviare il Raspberry Pi 4 e iniziare la configurazione del sistema. Nota Il Raspberry Pi 4 non \u00e8 supportato nelle versione 12.x e precedenti.","title":"Introduzione"},{"location":"freebsd/FreeBSD_su_RPI4/01_installazione/#download","text":"FreeBSD offre immagini pre-costruite per l'architettura ARM e ARM64. La versione ARM64 funziona bene su Pi 3B+ e 4. Ecco il link generale al server FTP: https://download.freebsd.org/ftp/ La versione da scaricare al momento \u00e8: FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img.xz Per scaricare dal mirror italiano del consorzio GARR usate questo link diretto e scaricate anche il CHECKSUM per verificare il corretto scaricamento dell'immagine.","title":"Download"},{"location":"freebsd/FreeBSD_su_RPI4/01_installazione/#verifica-dellimmagine","text":"Una volta scaricata possiamo verificare l'integrit\u00e0 dell'immagine con il comando sh256sum . sha256sum -c CHECKSUM.SHA256-FreeBSD-13.0-RELEASE-arm64-aarch64-RPI FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img.xz: OK","title":"Verifica dell'Immagine"},{"location":"freebsd/FreeBSD_su_RPI4/01_installazione/#preparazione-del-disco-ssd","text":"","title":"Preparazione del disco SSD"},{"location":"freebsd/FreeBSD_su_RPI4/01_installazione/#decompressione-dellimmagine","text":"Una volta ottenuta l'immagine compressa del disco (compressa con 'xz'), \u00e8 necessario estrarla in un'immagine binaria. Usa l'utilit\u00e0 'xz' (in Linux o FreeBSD) come segue: xz --decompress FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img.xz . \u251c\u2500\u2500 CHECKSUM.SHA256-FreeBSD-13.0-RELEASE-arm64-aarch64-RPI \u2514\u2500\u2500 FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img Questo vi dar\u00e0 il file immagine raw, FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img .","title":"Decompressione dell'immagine"},{"location":"freebsd/FreeBSD_su_RPI4/01_installazione/#scrittura-sul-supporto","text":"Successivamente, dovrai collegare il tuo disco sd al tuo computer Linux o FreeBSD, ma NON permettere che venga 'montato automaticamente' (potresti doverlo smontare forzatamente se la tua GUI lo monta in automatico). Poi, una volta che il disco appare nell'albero dei dispositivi '/dev/', dovrai sovrascrivere la partizione primaria con il contenuto del file '.img' che hai estratto prima. ll /dev/d* ... crw-r----- 1 root operator 0x5f Apr 9 23 :00 /dev/da0 crw-r----- 1 root operator 0x60 Apr 9 23 :00 /dev/da0s1 crw-r----- 1 root operator 0x61 Apr 9 23 :00 /dev/da0s2 ... Su un sistema FreeBSD, se c'\u00e8 un solo disco di sistema il disco SSD che avete collegato probabilmente avr\u00e0 un nome di dispositivo simile a '/dev/da0'. Se il disco ha gi\u00e0 un file system, potrebbero esserci anche altre voci come '/dev/da0s1' o come nell'esempio delle partizioni Linux. La voce che vuoi sovrascrivere \u00e8 il dispositivo 'root', '/dev/da0'. Su Linux la denominazione dei dispositivi \u00e8 simile (dovrebbe somigliare a qualcosa di simile a sdb ). Se non sei sicuro di quale dispositivo usare, puoi utilizzare il comando gpart show per visualizzare la geometria dei dischi sul sistema. gpart show = > 40 500118112 ada0 GPT ( 238G ) 40 532480 1 efi ( 260M ) 532520 1024 2 freebsd-boot ( 512K ) 533544 984 - free - ( 492K ) 534528 4194304 3 freebsd-swap ( 2 .0G ) 4728832 495388672 4 freebsd-zfs ( 236G ) 500117504 648 - free - ( 324K ) = > 34 234441581 da0 GPT ( 112G ) 34 2014 - free - ( 1 .0M ) 2048 1228800 1 efi ( 600M ) 1230848 2097152 2 linux-data ( 1 .0G ) 3328000 231112704 3 linux-lvm ( 110G ) 234440704 911 - free - ( 456K ) Assumendo che tu stia usando FreeBSD e che il disco sia '/dev/da0', usa il seguente comando per scrivere l'immagine: dd if = FreeBSD-13.0-RELEASE-arm64-aarch64-RPI.img of = /dev/da0 bs = 1M conv = noerror,sync Il parametro conv=noerror,sync riempie il resto dell'immagine con una sequenza di zeri, necessari quando si specifica una dimensione di blocco non predefinita. E la dimensione del blocco di 1M in realt\u00e0 accelera abbastanza il processo. A questo punto dovreste avere il vostro disco SSD con FeeBSD pronta all'uso. Smontate se necessario e scollegate il disco dal computer utilizzato per la scrittura dell'immagine.","title":"Scrittura sul supporto"},{"location":"freebsd/FreeBSD_su_RPI4/01_installazione/#primo-avvio","text":"Colleghiamo il disco SSD ad una porta USB della RPI4 e il cavo di rete. A questo punto per accedere al sistema abbiamo due possibilit\u00e0, collegare alla nostra Raspberry un monitor con tastiera e mouse ed accedere localmente o utilizzare una connessione SSH (headless) per accedervi in remoto da qualche altra postazione di lavoro. FreeBSD ha l'accesso SSH abilitato per impostazione predefinita. Il primo avvio richieder\u00e0 del tempo aggiuntivo poich\u00e8 l'immagine di FreeBSD per aarch64 ha impostato di default l'opzione per espandere la partizione root alla dimensione massima. growfs_enable = \"YES\"","title":"Primo avvio"},{"location":"freebsd/FreeBSD_su_RPI4/01_installazione/#accedere-al-sistema","text":"Nell'installazione standard su RPI4 sono disponibili due utenti: freebsd \u00e8 l'utente predefinito, la password \u00e8 'freebsd' root \u00e8 l'amministratore, la password \u00e8 'root' Importante L'installazione crea gli utenti in maniera standardizzata e chiaramente la prima cosa da fare \u00e8 mettere in sicurezza gli accessi modificando la password di root . In bsdconfig c'\u00e8 una voce specifica per la modifica della password di root. All'avvio se avete scelto la configurazione locale, apparir\u00e0 un prompt del terminale dove vi verr\u00e0 richiesto di effettuare il login. Connettevi come amministratore root per continuare la configurazione. Se invece state accedendo da remoto con SSH dovrete necessariamente accedere con l'utenza predefinita freebsd e successivamente ottenere i privilegi di amministratore con su ssh -l freebsd ip_della_RPI4 freebsd@freebsd:~ % su Password: root@dfreebsd:/home/freebsd # Sudo in FreeBSD Non c'\u00e8 nessun comando sudo disponibile su una installazione FreeBSD, e anche se disponibile all'installazione nei ports non \u00e8 consigliata dagli sviluppatori di FreeBSD. A questo punto possiamo iniziare la configurazione .","title":"Accedere al sistema"},{"location":"freebsd/FreeBSD_su_RPI4/02_configurazione/","tags":["freebsd","raspberry"],"text":"Interfaccia di amministrazione Per configurare le impostazioni principali del sistema FreeBSD fornisce un'interfaccia ncurses che pu\u00f2 essere richiamata con il comando bsdconfig . Usate le frecce per scorrere fino alla parte che dovete cambiare, e seguite le istruzioni per configurarla (se siete connessi con SSH, il mouse funziona). Gestione degli utenti Modificare la password di root Selezioniamo la voce e inseriamo la nuova password. Ripetiamo la password per verifica. Se le due coincidono ci verr\u00e0 data conferma dell'avvenuta modifica. A questo punto il sistema \u00e8 parzialmente in sicurezza in quanto sullo stesso c'\u00e8 ancora un utente (anche se senza privilegi di amministratore) con un nome utente e password pubblici, che se dimenticato potrebbe essere usato per l'acceso alla vostra RPI4. Per risolvere questo si consiglia di creare il proprio utente standard e successivamente eliminare l'utente freebsd . Possiamo farlo comodamente dalla nostra interfaccia di amministrazione bsdconfig . Accediamo alla sezione Login/Group Management E selezioniamo Add Login , inseriamo il nome utente e alla prossima schermata selezioniamo 'No' per i valori predefiniti per il nuovo account, inseriamo il nome completo, la password, ripetiamo la password per verifica, lasciamo invariati i valori UID e Group ID , nella sezione Members of Groups selezioniamo Select Groups from a list e selezioniamo il gruppo wheel , l'inserimento dell'utente in questo gruppo permetter\u00e0 all'utente standard di accedere ai privilegi di amministratore. Lasciamo invariato il Login class e le altre impostazioni (scadenza della password scadenza dell'account, home directory, Dotfiles), per quanto riguarda la scelta della shell, questo \u00e8 soggettivo, non troviamo la shell bash in quanto questa \u00e8 un'applicazione dell'ambiente GNU/Linux. Finita la configurazione del nuovo utente, alla schermata di riepilogo possiamo controllare quanto inserito e se tutto \u00e8 come desiderato selezionando 'OK' aggiungeremo il nostro nuovo utente. A questo punto possiamo eliminare l'utente predefinito freebsd sempre della schermata Login/Group selezionando questa volta Delete Login . Ora che abbiamo messo in sicurezza l'accesso possiamo passare all'aggiornamento del sistema. Aggiornamento In FreeBSD il sistema \u00e8 separato dalle applicazioni quindi ci sono due procedure separate, una per il sistema e una per le applicazioni. Secondo il seguente schema: graph LR A[\"Aggiornamento\"] --> B(Sistema) --> C(freebsd-update fetch); B --> D(freebsd-update install) A --> E(Appicazioni); E --> F(pkg update); E --> G(pkg upgrade) Aggiornamento del Sistema Per aggiornare il sistema si utilizzano i seguenti comandi: root@freebsd:~ # freebsd-update fetch src component not installed, skipped Looking up update.FreeBSD.org mirrors... 2 mirrors found. Fetching metadata signature for 13 .0-RELEASE from update1.freebsd.org... done . Fetching metadata index... done . Inspecting system... done . Preparing to download files... done . .... Installazione delle Patch root@freeabsd:~ # freebsd-update install src component not installed, skipped No updates are available to install. Il primo comando scarica dal server FreeBSD le patch di sicurezza mentre il secondo le installa. Se le patch di sicurezza interessano anche il kernel allora dopo aver scaricato le patch con freebsd-update fetch \u00e8 necessario un riavvio prima dell'installazione con freebsd-update install . Aggiornamento delle Applicazioni FreeBSD \u00e8 fornito con una ricca collezione di strumenti di sistema come parte del sistema di base. Inoltre, FreeBSD fornisce due tecnologie complementari per l'installazione di software di terze parti: la FreeBSD Ports Collection, per l'installazione dai sorgenti, e i pacchetti, per l'installazione da binari pre-costruiti. Nel nostro esempio utilizzeremo il sistema dei pacchetti pre-costruiti, in quanto la compilazione da sorgente richiede un tempo e una capacit\u00e0 di calcolo notevoli, cosa che sulla RPI4 non \u00e8 consigliabile. Un pacchetto FreeBSD contiene copie precompilate di tutti i comandi per un'applicazione, cos\u00ec come qualsiasi file di configurazione e documentazione. Un pacchetto pu\u00f2 essere manipolato con i comandi pkg(8) , come pkg install . FreeBSD include un'utilit\u00e0 di bootstrap che pu\u00f2 essere usata per scaricare e installare pkg e le sue pagine di manuale. Questa utilit\u00e0 \u00e8 progettata per funzionare con le versioni di FreeBSD a partire dalla 10.X. Per avviare il bootstrap, esegui: /usr/sbin/pkg Devi avere una connessione Internet funzionante perch\u00e9 il processo di bootstrap abbia successo. I comandi principali di pkg per la gestione delle applicazioni sono: pkg update aggiorna i sorgenti dal repository pkg upgrade aggiorna i pacchetti che stai gi\u00e0 usando sul sistema pkg search 'string' trova il pacchetto che vuoi installare, esempio: pkg install 'package' installa il pacchetto richiesto, esempio: pkg install vim pkg remove 'package' disinstalla il pacchetto dal sistema pkg help ottieni una lista di tutte le altre opzioni disponibili Il metodo pi\u00f9 semplice per cercare e trovare un'applicazione in FreeBSD \u00e8 tramite la riga di comando. Per cercare i pacchetti binari di un'applicazione, per esempio il software nginx , inserisci il seguente comando. pkg search nginx modsecurity3-nginx-1.0.2_1 Instruction detection and prevention engine / nginx Wrapper nginx-1.20.2_9,2 Robust and small WWW server nginx-devel-1.21.6_7 Robust and small WWW server nginx-lite-1.20.2_9,2 Robust and small WWW server ( lite package ) nginx-naxsi-1.20.2_9,2 Robust and small WWW server ( plus NAXSI ) .... Se volete vedere a quale categoria appartiene il pacchetto, eseguite lo stesso comando di cui sopra con la flag -o , come illustrato nell'esempio seguente. pkg search -o nginx security/modsecurity3-nginx Instruction detection and prevention engine / nginx Wrapper www/nginx Robust and small WWW server www/nginx-devel Robust and small WWW server www/nginx-lite Robust and small WWW server ( lite package ) www/nginx-naxsi Robust and small WWW server ( plus NAXSI ) .... Per installare un pacchetto precompilato (es. nginx) dai repository dei Ports, usa il seguente comando. pkg install nginx Updating FreeBSD repository catalogue... FreeBSD repository is up to date. All repositories are up to date. The following 2 package ( s ) will be affected ( of 0 checked ) : New packages to be INSTALLED: nginx: 1 .20.2_9,2 pcre: 8 .45_1 Number of packages to be installed: 2 The process will require 7 MiB more space. 1 MiB to be downloaded. Proceed with this action? [ y/N ] : Per interrogare le informazioni su uno specifico pacchetto installato nel sistema, si utilizza la flag info . Il comando pkg info mostrer\u00e0 il messaggio \"No packages(s) matching package_name\" se il pacchetto software non \u00e8 ancora installato nel tuo sistema pkg info nginx pkg: No package ( s ) matching nginx pkg info git git-2.35.1 Name : git Version : 2 .35.1 Installed on : Thu Apr 14 09 :52:39 2022 CEST Origin : devel/git Architecture : FreeBSD:13:aarch64 Prefix : /usr/local Categories : devel Licenses : GPLv2 Maintainer : garga@FreeBSD.org WWW : https://git-scm.com/ Comment : Distributed source code management tool Options : CONTRIB : on CURL : on GITWEB : on HTMLDOCS : off ICONV : on NLS : on PCRE2 : on PERL : on SEND_EMAIL : on SUBTREE : on Shared Libs required: libexpat.so.1 libpcre2-8.so.0 libintl.so.8 libcurl.so.4 Annotations : FreeBSD_version: 1300139 cpe : cpe:2.3:a:git-scm:git:2.35.1:::::freebsd13:aarch64 flavor : default repo_type : binary repository : FreeBSD Flat size : 28 .6MiB Description : Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. Per elencare tutti i pacchetti software installati in FreeBSD, esegui il comando pkg info senza alcuna opzione o switch.","title":"Configurazione"},{"location":"freebsd/FreeBSD_su_RPI4/02_configurazione/#interfaccia-di-amministrazione","text":"Per configurare le impostazioni principali del sistema FreeBSD fornisce un'interfaccia ncurses che pu\u00f2 essere richiamata con il comando bsdconfig . Usate le frecce per scorrere fino alla parte che dovete cambiare, e seguite le istruzioni per configurarla (se siete connessi con SSH, il mouse funziona).","title":"Interfaccia di amministrazione"},{"location":"freebsd/FreeBSD_su_RPI4/02_configurazione/#gestione-degli-utenti","text":"","title":"Gestione degli utenti"},{"location":"freebsd/FreeBSD_su_RPI4/02_configurazione/#modificare-la-password-di-root","text":"Selezioniamo la voce e inseriamo la nuova password. Ripetiamo la password per verifica. Se le due coincidono ci verr\u00e0 data conferma dell'avvenuta modifica. A questo punto il sistema \u00e8 parzialmente in sicurezza in quanto sullo stesso c'\u00e8 ancora un utente (anche se senza privilegi di amministratore) con un nome utente e password pubblici, che se dimenticato potrebbe essere usato per l'acceso alla vostra RPI4. Per risolvere questo si consiglia di creare il proprio utente standard e successivamente eliminare l'utente freebsd . Possiamo farlo comodamente dalla nostra interfaccia di amministrazione bsdconfig . Accediamo alla sezione Login/Group Management E selezioniamo Add Login , inseriamo il nome utente e alla prossima schermata selezioniamo 'No' per i valori predefiniti per il nuovo account, inseriamo il nome completo, la password, ripetiamo la password per verifica, lasciamo invariati i valori UID e Group ID , nella sezione Members of Groups selezioniamo Select Groups from a list e selezioniamo il gruppo wheel , l'inserimento dell'utente in questo gruppo permetter\u00e0 all'utente standard di accedere ai privilegi di amministratore. Lasciamo invariato il Login class e le altre impostazioni (scadenza della password scadenza dell'account, home directory, Dotfiles), per quanto riguarda la scelta della shell, questo \u00e8 soggettivo, non troviamo la shell bash in quanto questa \u00e8 un'applicazione dell'ambiente GNU/Linux. Finita la configurazione del nuovo utente, alla schermata di riepilogo possiamo controllare quanto inserito e se tutto \u00e8 come desiderato selezionando 'OK' aggiungeremo il nostro nuovo utente. A questo punto possiamo eliminare l'utente predefinito freebsd sempre della schermata Login/Group selezionando questa volta Delete Login . Ora che abbiamo messo in sicurezza l'accesso possiamo passare all'aggiornamento del sistema.","title":"Modificare la password di root"},{"location":"freebsd/FreeBSD_su_RPI4/02_configurazione/#aggiornamento","text":"In FreeBSD il sistema \u00e8 separato dalle applicazioni quindi ci sono due procedure separate, una per il sistema e una per le applicazioni. Secondo il seguente schema: graph LR A[\"Aggiornamento\"] --> B(Sistema) --> C(freebsd-update fetch); B --> D(freebsd-update install) A --> E(Appicazioni); E --> F(pkg update); E --> G(pkg upgrade)","title":"Aggiornamento"},{"location":"freebsd/FreeBSD_su_RPI4/02_configurazione/#aggiornamento-del-sistema","text":"Per aggiornare il sistema si utilizzano i seguenti comandi: root@freebsd:~ # freebsd-update fetch src component not installed, skipped Looking up update.FreeBSD.org mirrors... 2 mirrors found. Fetching metadata signature for 13 .0-RELEASE from update1.freebsd.org... done . Fetching metadata index... done . Inspecting system... done . Preparing to download files... done . ....","title":"Aggiornamento del Sistema"},{"location":"freebsd/FreeBSD_su_RPI4/02_configurazione/#installazione-delle-patch","text":"root@freeabsd:~ # freebsd-update install src component not installed, skipped No updates are available to install. Il primo comando scarica dal server FreeBSD le patch di sicurezza mentre il secondo le installa. Se le patch di sicurezza interessano anche il kernel allora dopo aver scaricato le patch con freebsd-update fetch \u00e8 necessario un riavvio prima dell'installazione con freebsd-update install .","title":"Installazione delle Patch"},{"location":"freebsd/FreeBSD_su_RPI4/02_configurazione/#aggiornamento-delle-applicazioni","text":"FreeBSD \u00e8 fornito con una ricca collezione di strumenti di sistema come parte del sistema di base. Inoltre, FreeBSD fornisce due tecnologie complementari per l'installazione di software di terze parti: la FreeBSD Ports Collection, per l'installazione dai sorgenti, e i pacchetti, per l'installazione da binari pre-costruiti. Nel nostro esempio utilizzeremo il sistema dei pacchetti pre-costruiti, in quanto la compilazione da sorgente richiede un tempo e una capacit\u00e0 di calcolo notevoli, cosa che sulla RPI4 non \u00e8 consigliabile. Un pacchetto FreeBSD contiene copie precompilate di tutti i comandi per un'applicazione, cos\u00ec come qualsiasi file di configurazione e documentazione. Un pacchetto pu\u00f2 essere manipolato con i comandi pkg(8) , come pkg install . FreeBSD include un'utilit\u00e0 di bootstrap che pu\u00f2 essere usata per scaricare e installare pkg e le sue pagine di manuale. Questa utilit\u00e0 \u00e8 progettata per funzionare con le versioni di FreeBSD a partire dalla 10.X. Per avviare il bootstrap, esegui: /usr/sbin/pkg Devi avere una connessione Internet funzionante perch\u00e9 il processo di bootstrap abbia successo. I comandi principali di pkg per la gestione delle applicazioni sono: pkg update aggiorna i sorgenti dal repository pkg upgrade aggiorna i pacchetti che stai gi\u00e0 usando sul sistema pkg search 'string' trova il pacchetto che vuoi installare, esempio: pkg install 'package' installa il pacchetto richiesto, esempio: pkg install vim pkg remove 'package' disinstalla il pacchetto dal sistema pkg help ottieni una lista di tutte le altre opzioni disponibili Il metodo pi\u00f9 semplice per cercare e trovare un'applicazione in FreeBSD \u00e8 tramite la riga di comando. Per cercare i pacchetti binari di un'applicazione, per esempio il software nginx , inserisci il seguente comando. pkg search nginx modsecurity3-nginx-1.0.2_1 Instruction detection and prevention engine / nginx Wrapper nginx-1.20.2_9,2 Robust and small WWW server nginx-devel-1.21.6_7 Robust and small WWW server nginx-lite-1.20.2_9,2 Robust and small WWW server ( lite package ) nginx-naxsi-1.20.2_9,2 Robust and small WWW server ( plus NAXSI ) .... Se volete vedere a quale categoria appartiene il pacchetto, eseguite lo stesso comando di cui sopra con la flag -o , come illustrato nell'esempio seguente. pkg search -o nginx security/modsecurity3-nginx Instruction detection and prevention engine / nginx Wrapper www/nginx Robust and small WWW server www/nginx-devel Robust and small WWW server www/nginx-lite Robust and small WWW server ( lite package ) www/nginx-naxsi Robust and small WWW server ( plus NAXSI ) .... Per installare un pacchetto precompilato (es. nginx) dai repository dei Ports, usa il seguente comando. pkg install nginx Updating FreeBSD repository catalogue... FreeBSD repository is up to date. All repositories are up to date. The following 2 package ( s ) will be affected ( of 0 checked ) : New packages to be INSTALLED: nginx: 1 .20.2_9,2 pcre: 8 .45_1 Number of packages to be installed: 2 The process will require 7 MiB more space. 1 MiB to be downloaded. Proceed with this action? [ y/N ] : Per interrogare le informazioni su uno specifico pacchetto installato nel sistema, si utilizza la flag info . Il comando pkg info mostrer\u00e0 il messaggio \"No packages(s) matching package_name\" se il pacchetto software non \u00e8 ancora installato nel tuo sistema pkg info nginx pkg: No package ( s ) matching nginx pkg info git git-2.35.1 Name : git Version : 2 .35.1 Installed on : Thu Apr 14 09 :52:39 2022 CEST Origin : devel/git Architecture : FreeBSD:13:aarch64 Prefix : /usr/local Categories : devel Licenses : GPLv2 Maintainer : garga@FreeBSD.org WWW : https://git-scm.com/ Comment : Distributed source code management tool Options : CONTRIB : on CURL : on GITWEB : on HTMLDOCS : off ICONV : on NLS : on PCRE2 : on PERL : on SEND_EMAIL : on SUBTREE : on Shared Libs required: libexpat.so.1 libpcre2-8.so.0 libintl.so.8 libcurl.so.4 Annotations : FreeBSD_version: 1300139 cpe : cpe:2.3:a:git-scm:git:2.35.1:::::freebsd13:aarch64 flavor : default repo_type : binary repository : FreeBSD Flat size : 28 .6MiB Description : Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. Per elencare tutti i pacchetti software installati in FreeBSD, esegui il comando pkg info senza alcuna opzione o switch.","title":"Aggiornamento delle Applicazioni"},{"location":"freebsd/Tutorial/05_git_server/","tags":"freebsd server git","text":"Eseguire un semplice server Git su FreeBSD usando SSH Creare l'utente git La prima cosa da fare \u00e8 creare l'utente git sul server FreeBSD remoto, che sar\u00e0 proprietario di tutte le directory e i file del repository remoto: [ root@freebsd ~ ] $ adduser Username: git Full name: git remote user Uid ( Leave empty for default ) : Login group [ git ] : Login group is git. Invite git into other groups? [] : Login class [ default ] : Shell ( sh csh tcsh bash rbash git-shell nologin ) [ sh ] : git-shell Home directory [ /home/git ] : Home directory permissions ( Leave empty for default ) : Use password-based authentication? [ yes ] : Use an empty password? ( yes/no ) [ no ] : Use a random password? ( yes/no ) [ no ] : Enter password: Enter password again: Lock out the account after creation? [ no ] : Username : git Password : Full Name : git remote user Uid : 1004 Class : Groups : git Home : /home/git Home Mode : Shell : /usr/local/libexec/git-core/git-shell Locked : no OK? ( yes/no ) : yes adduser: INFO: Successfully added ( git ) to the user database. Add another user? ( yes/no ) : no Goodbye! Si noti che \u00e8 stata assegnata la git-shell come shell dell'utente, invece di una shell di sistema come sh o tcsh . Questo ci permetter\u00e0 di accedere a SSH per eseguire i comandi di Git, ma in modo limitato per una maggiore sicurezza. Configurazione dei repository remoti Ora \u00e8 venuto il momento di creare le directory per ospitare i repository remoti e configurare le autorizzazioni appropriate: [ root@freebsd ~ ] $ mkdir -p /home/git/repos/repo_test [ root@freebsd ~ ] $ sudo git init --bare /home/git/repos/repo_test/ hint: Using 'master' as the name for the initial branch. This default branch name hint: is subject to change. To configure the initial branch name to use in all hint: of your new repositories, which will suppress this warning, call: hint: hint: git config --global init.defaultBranch hint: hint: Names commonly chosen instead of 'master' are 'main' , 'trunk' and hint: 'development' . The just-created branch can be renamed via this command: hint: hint: git branch -m Initialized empty Git repository in /usr/home/git/repos/repo_test/ [ root@freebsd ~ ] $ sudo chown -R git:git /usr/home/git/repos A questo punto se si vuole, si pu\u00f2 anche aggiornare la descrizione del repo nel file /home/git/repos/repo_test/description. Abilitare l'accesso SSH Sulla macchina remota, dobbiamo eseguire i seguenti passi: [ remoteuser@freebsd ~ ] $ mkdir -p /home/git/.ssh [ remoteuser@freebsd ~ ] $ touch /home/git/.ssh/authorized_keys [ remoteuser@freebsd ~ ] $ chown -R git:git /home/git/.ssh [ remoteuser@freebsd ~ ] $ chmod -R 700 /home/git/.ssh Abbiamo quindi creato la cartella .ssh e vi abbiamo creato un file chiamato authorized_keys , abbiamo impostato l'utente git come utente proprietario della cartella e successivamente abbiamo cambiato i permessi del file in modo che solo il proprietario possa modificarlo. Significato chmod 700 Chmod 700 (chmod u+rwx,g-rwx,o-rwx) imposta i permessi in modo che (U)ser/proprietario possa leggere, scrivere ed eseguire. (G)roup/gruppo non pu\u00f2 leggere, scrivere ed eseguire. (O)thers/altri non possono leggere, scrivere ed eseguire.","title":"Git Server Minimale"},{"location":"freebsd/Tutorial/05_git_server/#eseguire-un-semplice-server-git-su-freebsd-usando-ssh","text":"","title":"Eseguire un semplice server Git su FreeBSD usando SSH"},{"location":"freebsd/Tutorial/05_git_server/#creare-lutente-git","text":"La prima cosa da fare \u00e8 creare l'utente git sul server FreeBSD remoto, che sar\u00e0 proprietario di tutte le directory e i file del repository remoto: [ root@freebsd ~ ] $ adduser Username: git Full name: git remote user Uid ( Leave empty for default ) : Login group [ git ] : Login group is git. Invite git into other groups? [] : Login class [ default ] : Shell ( sh csh tcsh bash rbash git-shell nologin ) [ sh ] : git-shell Home directory [ /home/git ] : Home directory permissions ( Leave empty for default ) : Use password-based authentication? [ yes ] : Use an empty password? ( yes/no ) [ no ] : Use a random password? ( yes/no ) [ no ] : Enter password: Enter password again: Lock out the account after creation? [ no ] : Username : git Password : Full Name : git remote user Uid : 1004 Class : Groups : git Home : /home/git Home Mode : Shell : /usr/local/libexec/git-core/git-shell Locked : no OK? ( yes/no ) : yes adduser: INFO: Successfully added ( git ) to the user database. Add another user? ( yes/no ) : no Goodbye! Si noti che \u00e8 stata assegnata la git-shell come shell dell'utente, invece di una shell di sistema come sh o tcsh . Questo ci permetter\u00e0 di accedere a SSH per eseguire i comandi di Git, ma in modo limitato per una maggiore sicurezza.","title":"Creare l'utente git"},{"location":"freebsd/Tutorial/05_git_server/#configurazione-dei-repository-remoti","text":"Ora \u00e8 venuto il momento di creare le directory per ospitare i repository remoti e configurare le autorizzazioni appropriate: [ root@freebsd ~ ] $ mkdir -p /home/git/repos/repo_test [ root@freebsd ~ ] $ sudo git init --bare /home/git/repos/repo_test/ hint: Using 'master' as the name for the initial branch. This default branch name hint: is subject to change. To configure the initial branch name to use in all hint: of your new repositories, which will suppress this warning, call: hint: hint: git config --global init.defaultBranch hint: hint: Names commonly chosen instead of 'master' are 'main' , 'trunk' and hint: 'development' . The just-created branch can be renamed via this command: hint: hint: git branch -m Initialized empty Git repository in /usr/home/git/repos/repo_test/ [ root@freebsd ~ ] $ sudo chown -R git:git /usr/home/git/repos A questo punto se si vuole, si pu\u00f2 anche aggiornare la descrizione del repo nel file /home/git/repos/repo_test/description.","title":"Configurazione dei repository remoti"},{"location":"freebsd/Tutorial/05_git_server/#abilitare-laccesso-ssh","text":"Sulla macchina remota, dobbiamo eseguire i seguenti passi: [ remoteuser@freebsd ~ ] $ mkdir -p /home/git/.ssh [ remoteuser@freebsd ~ ] $ touch /home/git/.ssh/authorized_keys [ remoteuser@freebsd ~ ] $ chown -R git:git /home/git/.ssh [ remoteuser@freebsd ~ ] $ chmod -R 700 /home/git/.ssh Abbiamo quindi creato la cartella .ssh e vi abbiamo creato un file chiamato authorized_keys , abbiamo impostato l'utente git come utente proprietario della cartella e successivamente abbiamo cambiato i permessi del file in modo che solo il proprietario possa modificarlo. Significato chmod 700 Chmod 700 (chmod u+rwx,g-rwx,o-rwx) imposta i permessi in modo che (U)ser/proprietario possa leggere, scrivere ed eseguire. (G)roup/gruppo non pu\u00f2 leggere, scrivere ed eseguire. (O)thers/altri non possono leggere, scrivere ed eseguire.","title":"Abilitare l'accesso SSH"},{"location":"git/set_enviroment/","tags":["git","programmazione","versioning"],"text":"Impostazione del nome utente e dell'e-mail globale di Git Il nome utente e l'indirizzo e-mail globali di git sono associati ai commit su tutti i repository del sistema che non hanno valori specifici per il repository. Per impostare il nome e l'indirizzo email del commit globale, eseguire il comando git config con l'opzione --global: git config --global user.name \"Tuo Nome\" git config --global user.email \"tuaemail@tuodominio.com\" Una volta fatto, si pu\u00f2 confermare che le informazioni sono state impostate eseguendo: git config --list user.name=Tuo Nome user.email=tua_email@tuodominio.com I due comandi hanno modificato il file .gitconfig presente nella cartella home dell'utente. Questo file contiene la configurazione globale. cat ~/.gitconfig [ user ] name = Tuo Nome email = tua_email@tuodominio.com \u00c8 possibile modificare il file anche con il proprio editor di testo, ma si consiglia di usare il comando git config . Impostazione del nome utente e dell'e-mail di Git per un singolo repository Se si vuole usare un nome utente o un indirizzo e-mail diverso per un repository specifico, eseguire il comando git config senza l'opzione --global dalla directory del repository. Supponiamo di voler impostare un nome utente e un indirizzo email specifici per un repository memorizzato nella directory ~/lab/repo_test. Per prima cosa, passaiamo alla directory principale del repository: cd ~/lab/repo_test Impostare un nome utente e un indirizzo e-mail Git: git config user.name \"Tuo Nome\" git config user.email \"tua_email@tuodominio.com\" Le impostazioni specifiche del repository sono conservate nel file .git/config nella directory principale del repository. tree -f -L 2 .git/ .git \u251c\u2500\u2500 .git/branches \u251c\u2500\u2500 .git/COMMIT_EDITMSG \u251c\u2500\u2500 .git/config \u251c\u2500\u2500 .git/description \u251c\u2500\u2500 .git/FETCH_HEAD \u251c\u2500\u2500 .git/HEAD \u251c\u2500\u2500 .git/hooks \u2502 \u251c\u2500\u2500 .git/hooks/applypatch-msg.sample \u2502 \u251c\u2500\u2500 .git/hooks/commit-msg.sample \u2502 \u251c\u2500\u2500 .git/hooks/fsmonitor-watchman.sample .... git config --global user.signingkey BEBF01E9BB652FC2 [ user ] name = Tuo Nome email = tua_email@tuodominio.com signingkey = BEBF01E9BB652FC2 git config commit.gpgsign true [commit] gpgsign = true","title":"Ambiente Git"},{"location":"git/set_enviroment/#impostazione-del-nome-utente-e-delle-mail-globale-di-git","text":"Il nome utente e l'indirizzo e-mail globali di git sono associati ai commit su tutti i repository del sistema che non hanno valori specifici per il repository. Per impostare il nome e l'indirizzo email del commit globale, eseguire il comando git config con l'opzione --global: git config --global user.name \"Tuo Nome\" git config --global user.email \"tuaemail@tuodominio.com\" Una volta fatto, si pu\u00f2 confermare che le informazioni sono state impostate eseguendo: git config --list user.name=Tuo Nome user.email=tua_email@tuodominio.com I due comandi hanno modificato il file .gitconfig presente nella cartella home dell'utente. Questo file contiene la configurazione globale. cat ~/.gitconfig [ user ] name = Tuo Nome email = tua_email@tuodominio.com \u00c8 possibile modificare il file anche con il proprio editor di testo, ma si consiglia di usare il comando git config .","title":"Impostazione del nome utente e dell'e-mail globale di Git"},{"location":"git/set_enviroment/#impostazione-del-nome-utente-e-delle-mail-di-git-per-un-singolo-repository","text":"Se si vuole usare un nome utente o un indirizzo e-mail diverso per un repository specifico, eseguire il comando git config senza l'opzione --global dalla directory del repository. Supponiamo di voler impostare un nome utente e un indirizzo email specifici per un repository memorizzato nella directory ~/lab/repo_test. Per prima cosa, passaiamo alla directory principale del repository: cd ~/lab/repo_test Impostare un nome utente e un indirizzo e-mail Git: git config user.name \"Tuo Nome\" git config user.email \"tua_email@tuodominio.com\" Le impostazioni specifiche del repository sono conservate nel file .git/config nella directory principale del repository. tree -f -L 2 .git/ .git \u251c\u2500\u2500 .git/branches \u251c\u2500\u2500 .git/COMMIT_EDITMSG \u251c\u2500\u2500 .git/config \u251c\u2500\u2500 .git/description \u251c\u2500\u2500 .git/FETCH_HEAD \u251c\u2500\u2500 .git/HEAD \u251c\u2500\u2500 .git/hooks \u2502 \u251c\u2500\u2500 .git/hooks/applypatch-msg.sample \u2502 \u251c\u2500\u2500 .git/hooks/commit-msg.sample \u2502 \u251c\u2500\u2500 .git/hooks/fsmonitor-watchman.sample .... git config --global user.signingkey BEBF01E9BB652FC2 [ user ] name = Tuo Nome email = tua_email@tuodominio.com signingkey = BEBF01E9BB652FC2 git config commit.gpgsign true [commit] gpgsign = true","title":"Impostazione del nome utente e dell'e-mail di Git per un singolo repository"},{"location":"mkdocs/01_mkdocs_intro.it/","tags":["mkdocs","markdown"],"text":"MkDocs - Generatore di Documentazione MkDocs \u00e8 un generatore di siti statici. Questo significa che uno sviluppatore web non si deve preoccupare di codificare la struttura o l'aspetto del sito web, e si pu\u00f2 concentrare solo sulla scrittura di alcuni file di testo semplici ma strutturati. Il generatore di siti statici converte poi questi file di testo in contenuti del sito web. In questo processo, la maggior parte delle caratteristiche del sito web sono gi\u00e0 impostate, e quindi la quantit\u00e0 di tempo speso per personalizzarle \u00e8 ridotta al minimo. Scritto nel linguaggio di programmazione Python, MkDocs \u00e8 un progetto open-source con un sacco di supporto dalla comunit\u00e0. In termini di supporto Markdown, MkDocs fa un ottimo lavoro supportando gli elementi di sintassi di base, ma manca il supporto per alcuni elementi di sintassi estesa. L'applicazione utilizza il processore Markdown Python-Markdown , ed \u00e8 possibile abilitare estensioni aggiuntive. I file sorgente della documentazione sono scritti in Markdown e configurati con un singolo file di configurazione YAML. Comincia leggendo il tutorial introduttivo, poi controlla la guida utente per ulteriori informazioni. Caratteristiche Molti temi disponibili Ci sono molti temi disponibili per MkDocs. Puoi scegliere tra i temi integrati: mkdocs e readthedocs , o selezionare uno dei temi di terze parti elencati nella pagina wiki di MkDocs Themes , o creare il tuo. Facile da personalizzare Fai in modo che la documentazione del tuo progetto abbia l'aspetto che desideri personalizzando il tuo tema e/o installando alcuni plugin . Modifica il comportamento del Markdown con le Estensioni Markdown . Sono disponibili molte opzioni di configurazione. Anteprima del tuo sito mentre lavori Il dev-server integrato ti permette di vedere in anteprima la tua documentazione mentre la stai scrivendo. Si ricaricher\u00e0 anche automaticamente e aggiorner\u00e0 il tuo browser ogni volta che salvi le tue modifiche. Ospitare ovunque MkDocs costruisce siti HTML completamente statici che puoi ospitare su pagine GitHub, Amazon S3, o in qualsiasi altro posto tu scelga. Tutorial Introduttivo Guida Utente","title":"Introduzione"},{"location":"mkdocs/01_mkdocs_intro.it/#mkdocs-generatore-di-documentazione","text":"MkDocs \u00e8 un generatore di siti statici. Questo significa che uno sviluppatore web non si deve preoccupare di codificare la struttura o l'aspetto del sito web, e si pu\u00f2 concentrare solo sulla scrittura di alcuni file di testo semplici ma strutturati. Il generatore di siti statici converte poi questi file di testo in contenuti del sito web. In questo processo, la maggior parte delle caratteristiche del sito web sono gi\u00e0 impostate, e quindi la quantit\u00e0 di tempo speso per personalizzarle \u00e8 ridotta al minimo. Scritto nel linguaggio di programmazione Python, MkDocs \u00e8 un progetto open-source con un sacco di supporto dalla comunit\u00e0. In termini di supporto Markdown, MkDocs fa un ottimo lavoro supportando gli elementi di sintassi di base, ma manca il supporto per alcuni elementi di sintassi estesa. L'applicazione utilizza il processore Markdown Python-Markdown , ed \u00e8 possibile abilitare estensioni aggiuntive. I file sorgente della documentazione sono scritti in Markdown e configurati con un singolo file di configurazione YAML. Comincia leggendo il tutorial introduttivo, poi controlla la guida utente per ulteriori informazioni.","title":"MkDocs - Generatore di Documentazione"},{"location":"mkdocs/01_mkdocs_intro.it/#caratteristiche","text":"","title":"Caratteristiche"},{"location":"mkdocs/01_mkdocs_intro.it/#molti-temi-disponibili","text":"Ci sono molti temi disponibili per MkDocs. Puoi scegliere tra i temi integrati: mkdocs e readthedocs , o selezionare uno dei temi di terze parti elencati nella pagina wiki di MkDocs Themes , o creare il tuo.","title":"Molti temi disponibili"},{"location":"mkdocs/01_mkdocs_intro.it/#facile-da-personalizzare","text":"Fai in modo che la documentazione del tuo progetto abbia l'aspetto che desideri personalizzando il tuo tema e/o installando alcuni plugin . Modifica il comportamento del Markdown con le Estensioni Markdown . Sono disponibili molte opzioni di configurazione.","title":"Facile da personalizzare"},{"location":"mkdocs/01_mkdocs_intro.it/#anteprima-del-tuo-sito-mentre-lavori","text":"Il dev-server integrato ti permette di vedere in anteprima la tua documentazione mentre la stai scrivendo. Si ricaricher\u00e0 anche automaticamente e aggiorner\u00e0 il tuo browser ogni volta che salvi le tue modifiche.","title":"Anteprima del tuo sito mentre lavori"},{"location":"mkdocs/01_mkdocs_intro.it/#ospitare-ovunque","text":"MkDocs costruisce siti HTML completamente statici che puoi ospitare su pagine GitHub, Amazon S3, o in qualsiasi altro posto tu scelga. Tutorial Introduttivo Guida Utente","title":"Ospitare ovunque"},{"location":"mkdocs/02_mkdocs_starter.it/","tags":["mkdocs","markdown"],"text":"Installazione Per installare MkDocs, eseguite il seguente comando dalla riga di comando: pip install mkdocs Per maggiori dettagli, vedere la Guida all'installazione . Creare un nuovo progetto Iniziare \u00e8 super facile. Per creare un nuovo progetto, eseguire il seguente comando dalla riga di comando: mkdocs new my-project cd my-project Prenditi un momento per rivedere il progetto iniziale che \u00e8 stato creato per te. Il layout iniziale di MkDocs C'\u00e8 un singolo file di configurazione chiamato mkdocs.yml, e una cartella chiamata docs che conterr\u00e0 i file sorgente della documentazione (docs \u00e8 il valore predefinito per l'impostazione di configurazione docs_dir). In questo momento la cartella docs contiene solo una singola pagina di documentazione, chiamata index.md. MkDocs \u00e8 dotato di un dev-server integrato che ti permette di vedere l'anteprima della tua documentazione mentre ci lavori. Assicurati di essere nella stessa directory del file di configurazione mkdocs.yml, e poi avvia il server eseguendo il comando mkdocs serve: $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [ I 160402 15 :50:43 server:271 ] Serving on http://127.0.0.1:8000 [ I 160402 15 :50:43 handlers:58 ] Start watching changes [ I 160402 15 :50:43 handlers:60 ] Start detecting changes Aprite http://127.0.0.1:8000/ nel vostro browser, e vedrete la home page di default: Il dev-server supporta anche l'auto-reloading, e ricostruir\u00e0 la tua documentazione ogni volta che qualcosa nel file di configurazione, nella directory della documentazione o nella directory del tema cambia. Aprite il documento docs/index.md nel vostro editor di testo preferito, cambiate il titolo iniziale in MkLorum e salvate le modifiche. Il vostro browser si ricaricher\u00e0 automaticamente e dovreste vedere immediatamente la vostra documentazione aggiornata. Ora provate a modificare il file di configurazione: mkdocs.yml. Cambia l'impostazione site_name in MkLorum e salva il file. site_name : MkLorum site_url : https://example.com/ Il tuo browser dovrebbe ricaricarsi immediatamente, e vedrai il tuo nuovo nome del sito avere effetto. Nota Le opzioni di configurazione site_name e site_url sono le uniche due opzioni richieste nel tuo file di configurazione. Quando si crea un nuovo progetto, all'opzione site_url viene assegnato il valore segnaposto: https://example.com. Se la posizione finale \u00e8 nota, puoi cambiare l'impostazione ora per puntare ad essa. Oppure puoi scegliere di lasciar perdere per ora. Assicurati solo di modificarla prima di distribuire il tuo sito su un server di produzione. Aggiungere pagine Ora aggiungi una seconda pagina alla tua documentazione: curl 'https://jaspervdj.be/lorem-markdownum/markdown.txt' > docs/about.md Dato che il nostro sito di documentazione includer\u00e0 alcune intestazioni di navigazione, potresti voler modificare il file di configurazione e aggiungere alcune informazioni sull'ordine, il titolo e l'annidamento di ogni pagina nell'intestazione di navigazione aggiungendo un'impostazione nav: site_name : MkLorum site_url : https://example.com/ nav : - Home : index.md - About : about.md Salva le tue modifiche e ora vedrai una barra di navigazione con le voci Home e About a sinistra e le voci Search, Previous e Next a destra. Prova le voci del menu e naviga avanti e indietro tra le pagine. Poi clicca su Cerca. Apparir\u00e0 una finestra di ricerca che ti permetter\u00e0 di cercare qualsiasi testo in qualsiasi pagina. Notate che i risultati della ricerca includono ogni occorrenza del termine di ricerca sul sito e i link direttamente alla sezione della pagina in cui appare il termine di ricerca. Ottieni tutto questo senza alcuno sforzo o configurazione da parte tua! Personalizzare la nostra documentazione Ora cambiate il file di configurazione per alterare la visualizzazione della documentazione cambiando il tema. Modifica il file mkdocs.yml e aggiungi un'impostazione del tema: site_name : MkLorum site_url : https://example.com/ nav : - Home : index.md - About : about.md theme : readthedocs Salva le tue modifiche, e vedrai il tema ReadTheDocs utilizzato. Cambiare l'icona della Favicon Per default, MkDocs usa l'icona favicon di MkDocs. Per usare un'icona diversa, crea una sottodirectory img nella directory docs e copia il tuo file favicon.ico personalizzato in quella directory. MkDocs rilever\u00e0 e user\u00e0 automaticamente quel file come icona della tua favicon. Costruire il sito Sembra tutto a posto. Siete pronti a distribuire il primo passaggio della vostra documentazione MkLorum. Prima costruite la documentazione: mkdocs build Questo creer\u00e0 una nuova directory, chiamata site. Date un'occhiata all'interno della directory: tree site/ site/ \u251c\u2500\u2500 404 .html \u251c\u2500\u2500 about \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 css \u2502 \u251c\u2500\u2500 base.css \u2502 \u251c\u2500\u2500 bootstrap.min.css \u2502 \u2514\u2500\u2500 font-awesome.min.css \u251c\u2500\u2500 fonts \u2502 \u251c\u2500\u2500 fontawesome-webfont.eot \u2502 \u251c\u2500\u2500 fontawesome-webfont.svg \u2502 \u251c\u2500\u2500 fontawesome-webfont.ttf \u2502 \u251c\u2500\u2500 fontawesome-webfont.woff \u2502 \u2514\u2500\u2500 fontawesome-webfont.woff2 \u251c\u2500\u2500 img \u2502 \u251c\u2500\u2500 favicon.ico \u2502 \u2514\u2500\u2500 grid.png \u251c\u2500\u2500 index.html \u251c\u2500\u2500 js \u2502 \u251c\u2500\u2500 base.js \u2502 \u251c\u2500\u2500 bootstrap.min.js \u2502 \u2514\u2500\u2500 jquery-1.10.2.min.js \u251c\u2500\u2500 search \u2502 \u251c\u2500\u2500 lunr.js \u2502 \u251c\u2500\u2500 main.js \u2502 \u251c\u2500\u2500 search_index.json \u2502 \u2514\u2500\u2500 worker.js \u251c\u2500\u2500 sitemap.xml \u2514\u2500\u2500 sitemap.xml.gz Notate che la vostra documentazione sorgente \u00e8 stata emessa come due file HTML chiamati index.html e about/index.html. Hai anche vari altri media che sono stati copiati nella directory del sito come parte del tema della documentazione. Hai anche un file sitemap.xml e mkdocs/search_index.json. Se state usando il controllo del codice sorgente come git, probabilmente non volete controllare la vostra documentazione costruita nel repository. Aggiungete una linea contenente site/ al vostro file .gitignore. echo \"site/\" >> .gitignore Se stai usando un altro strumento di controllo del codice sorgente vorrai controllare la sua documentazione su come ignorare specifiche directory. Altri comandi e opzioni Ci sono vari altri comandi e opzioni disponibili. Per una lista completa dei comandi, usate il flag --help : mkdocs --help Usage: mkdocs [ OPTIONS ] COMMAND [ ARGS ] ... MkDocs - Project documentation with Markdown. Options: -V, --version Show the version and exit. -q, --quiet Silence warnings -v, --verbose Enable verbose output -h, --help Show this message and exit. Commands: build Build the MkDocs documentation gh-deploy Deploy your documentation to GitHub Pages new Create a new MkDocs project serve Run the builtin development serve Per visualizzare un elenco di opzioni disponibili per un dato comando, usate il flag --help con quel comando. Per esempio, per ottenere un elenco di tutte le opzioni disponibili per il comando build esegui quanto segue: mkdocs build --help Usage: mkdocs build [ OPTIONS ] Build the MkDocs documentation Options: -c, --clean / --dirty Remove old files from the site_dir before building ( the default ) . -f, --config-file FILENAME Provide a specific MkDocs config -s, --strict Enable strict mode. This will cause MkDocs to abort the build on any warnings. -t, --theme [ mkdocs | material | readthedocs ] The theme to use when building your documentation. --use-directory-urls / --no-directory-urls Use directory URLs when building pages ( the default ) . -d, --site-dir PATH The directory to output the result of the documentation build. -q, --quiet Silence warnings -v, --verbose Enable verbose output -h, --help Show this message and exit. Distribuzione Il sito di documentazione che hai appena costruito usa solo file statici quindi sarai in grado di ospitarlo praticamente ovunque. Basta caricare il contenuto dell'intera directory del sito su qualsiasi host che ospita il tuo sito web e il gioco \u00e8 fatto. Per istruzioni specifiche su un certo numero di host comuni, vedi la pagina Distribuire i tuoi documenti. Ottenere aiuto Vedi la Guida utente per una documentazione pi\u00f9 completa di tutte le caratteristiche di MkDocs. Per ottenere aiuto con MkDocs, usa le discussioni su GitHub o la risoluzione dei problemi su GitHub.","title":"Mkdocs tutorial"},{"location":"mkdocs/02_mkdocs_starter.it/#installazione","text":"Per installare MkDocs, eseguite il seguente comando dalla riga di comando: pip install mkdocs Per maggiori dettagli, vedere la Guida all'installazione .","title":"Installazione"},{"location":"mkdocs/02_mkdocs_starter.it/#creare-un-nuovo-progetto","text":"Iniziare \u00e8 super facile. Per creare un nuovo progetto, eseguire il seguente comando dalla riga di comando: mkdocs new my-project cd my-project Prenditi un momento per rivedere il progetto iniziale che \u00e8 stato creato per te.","title":"Creare un nuovo progetto"},{"location":"mkdocs/02_mkdocs_starter.it/#il-layout-iniziale-di-mkdocs","text":"C'\u00e8 un singolo file di configurazione chiamato mkdocs.yml, e una cartella chiamata docs che conterr\u00e0 i file sorgente della documentazione (docs \u00e8 il valore predefinito per l'impostazione di configurazione docs_dir). In questo momento la cartella docs contiene solo una singola pagina di documentazione, chiamata index.md. MkDocs \u00e8 dotato di un dev-server integrato che ti permette di vedere l'anteprima della tua documentazione mentre ci lavori. Assicurati di essere nella stessa directory del file di configurazione mkdocs.yml, e poi avvia il server eseguendo il comando mkdocs serve: $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [ I 160402 15 :50:43 server:271 ] Serving on http://127.0.0.1:8000 [ I 160402 15 :50:43 handlers:58 ] Start watching changes [ I 160402 15 :50:43 handlers:60 ] Start detecting changes Aprite http://127.0.0.1:8000/ nel vostro browser, e vedrete la home page di default: Il dev-server supporta anche l'auto-reloading, e ricostruir\u00e0 la tua documentazione ogni volta che qualcosa nel file di configurazione, nella directory della documentazione o nella directory del tema cambia. Aprite il documento docs/index.md nel vostro editor di testo preferito, cambiate il titolo iniziale in MkLorum e salvate le modifiche. Il vostro browser si ricaricher\u00e0 automaticamente e dovreste vedere immediatamente la vostra documentazione aggiornata. Ora provate a modificare il file di configurazione: mkdocs.yml. Cambia l'impostazione site_name in MkLorum e salva il file. site_name : MkLorum site_url : https://example.com/ Il tuo browser dovrebbe ricaricarsi immediatamente, e vedrai il tuo nuovo nome del sito avere effetto. Nota Le opzioni di configurazione site_name e site_url sono le uniche due opzioni richieste nel tuo file di configurazione. Quando si crea un nuovo progetto, all'opzione site_url viene assegnato il valore segnaposto: https://example.com. Se la posizione finale \u00e8 nota, puoi cambiare l'impostazione ora per puntare ad essa. Oppure puoi scegliere di lasciar perdere per ora. Assicurati solo di modificarla prima di distribuire il tuo sito su un server di produzione.","title":"Il layout iniziale di MkDocs"},{"location":"mkdocs/02_mkdocs_starter.it/#aggiungere-pagine","text":"Ora aggiungi una seconda pagina alla tua documentazione: curl 'https://jaspervdj.be/lorem-markdownum/markdown.txt' > docs/about.md Dato che il nostro sito di documentazione includer\u00e0 alcune intestazioni di navigazione, potresti voler modificare il file di configurazione e aggiungere alcune informazioni sull'ordine, il titolo e l'annidamento di ogni pagina nell'intestazione di navigazione aggiungendo un'impostazione nav: site_name : MkLorum site_url : https://example.com/ nav : - Home : index.md - About : about.md Salva le tue modifiche e ora vedrai una barra di navigazione con le voci Home e About a sinistra e le voci Search, Previous e Next a destra. Prova le voci del menu e naviga avanti e indietro tra le pagine. Poi clicca su Cerca. Apparir\u00e0 una finestra di ricerca che ti permetter\u00e0 di cercare qualsiasi testo in qualsiasi pagina. Notate che i risultati della ricerca includono ogni occorrenza del termine di ricerca sul sito e i link direttamente alla sezione della pagina in cui appare il termine di ricerca. Ottieni tutto questo senza alcuno sforzo o configurazione da parte tua!","title":"Aggiungere pagine"},{"location":"mkdocs/02_mkdocs_starter.it/#personalizzare-la-nostra-documentazione","text":"Ora cambiate il file di configurazione per alterare la visualizzazione della documentazione cambiando il tema. Modifica il file mkdocs.yml e aggiungi un'impostazione del tema: site_name : MkLorum site_url : https://example.com/ nav : - Home : index.md - About : about.md theme : readthedocs Salva le tue modifiche, e vedrai il tema ReadTheDocs utilizzato.","title":"Personalizzare la nostra documentazione"},{"location":"mkdocs/02_mkdocs_starter.it/#cambiare-licona-della-favicon","text":"Per default, MkDocs usa l'icona favicon di MkDocs. Per usare un'icona diversa, crea una sottodirectory img nella directory docs e copia il tuo file favicon.ico personalizzato in quella directory. MkDocs rilever\u00e0 e user\u00e0 automaticamente quel file come icona della tua favicon.","title":"Cambiare l'icona della Favicon"},{"location":"mkdocs/02_mkdocs_starter.it/#costruire-il-sito","text":"Sembra tutto a posto. Siete pronti a distribuire il primo passaggio della vostra documentazione MkLorum. Prima costruite la documentazione: mkdocs build Questo creer\u00e0 una nuova directory, chiamata site. Date un'occhiata all'interno della directory: tree site/ site/ \u251c\u2500\u2500 404 .html \u251c\u2500\u2500 about \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 css \u2502 \u251c\u2500\u2500 base.css \u2502 \u251c\u2500\u2500 bootstrap.min.css \u2502 \u2514\u2500\u2500 font-awesome.min.css \u251c\u2500\u2500 fonts \u2502 \u251c\u2500\u2500 fontawesome-webfont.eot \u2502 \u251c\u2500\u2500 fontawesome-webfont.svg \u2502 \u251c\u2500\u2500 fontawesome-webfont.ttf \u2502 \u251c\u2500\u2500 fontawesome-webfont.woff \u2502 \u2514\u2500\u2500 fontawesome-webfont.woff2 \u251c\u2500\u2500 img \u2502 \u251c\u2500\u2500 favicon.ico \u2502 \u2514\u2500\u2500 grid.png \u251c\u2500\u2500 index.html \u251c\u2500\u2500 js \u2502 \u251c\u2500\u2500 base.js \u2502 \u251c\u2500\u2500 bootstrap.min.js \u2502 \u2514\u2500\u2500 jquery-1.10.2.min.js \u251c\u2500\u2500 search \u2502 \u251c\u2500\u2500 lunr.js \u2502 \u251c\u2500\u2500 main.js \u2502 \u251c\u2500\u2500 search_index.json \u2502 \u2514\u2500\u2500 worker.js \u251c\u2500\u2500 sitemap.xml \u2514\u2500\u2500 sitemap.xml.gz Notate che la vostra documentazione sorgente \u00e8 stata emessa come due file HTML chiamati index.html e about/index.html. Hai anche vari altri media che sono stati copiati nella directory del sito come parte del tema della documentazione. Hai anche un file sitemap.xml e mkdocs/search_index.json. Se state usando il controllo del codice sorgente come git, probabilmente non volete controllare la vostra documentazione costruita nel repository. Aggiungete una linea contenente site/ al vostro file .gitignore. echo \"site/\" >> .gitignore Se stai usando un altro strumento di controllo del codice sorgente vorrai controllare la sua documentazione su come ignorare specifiche directory.","title":"Costruire il sito"},{"location":"mkdocs/02_mkdocs_starter.it/#altri-comandi-e-opzioni","text":"Ci sono vari altri comandi e opzioni disponibili. Per una lista completa dei comandi, usate il flag --help : mkdocs --help Usage: mkdocs [ OPTIONS ] COMMAND [ ARGS ] ... MkDocs - Project documentation with Markdown. Options: -V, --version Show the version and exit. -q, --quiet Silence warnings -v, --verbose Enable verbose output -h, --help Show this message and exit. Commands: build Build the MkDocs documentation gh-deploy Deploy your documentation to GitHub Pages new Create a new MkDocs project serve Run the builtin development serve Per visualizzare un elenco di opzioni disponibili per un dato comando, usate il flag --help con quel comando. Per esempio, per ottenere un elenco di tutte le opzioni disponibili per il comando build esegui quanto segue: mkdocs build --help Usage: mkdocs build [ OPTIONS ] Build the MkDocs documentation Options: -c, --clean / --dirty Remove old files from the site_dir before building ( the default ) . -f, --config-file FILENAME Provide a specific MkDocs config -s, --strict Enable strict mode. This will cause MkDocs to abort the build on any warnings. -t, --theme [ mkdocs | material | readthedocs ] The theme to use when building your documentation. --use-directory-urls / --no-directory-urls Use directory URLs when building pages ( the default ) . -d, --site-dir PATH The directory to output the result of the documentation build. -q, --quiet Silence warnings -v, --verbose Enable verbose output -h, --help Show this message and exit.","title":"Altri comandi e opzioni"},{"location":"mkdocs/02_mkdocs_starter.it/#distribuzione","text":"Il sito di documentazione che hai appena costruito usa solo file statici quindi sarai in grado di ospitarlo praticamente ovunque. Basta caricare il contenuto dell'intera directory del sito su qualsiasi host che ospita il tuo sito web e il gioco \u00e8 fatto. Per istruzioni specifiche su un certo numero di host comuni, vedi la pagina Distribuire i tuoi documenti.","title":"Distribuzione"},{"location":"mkdocs/02_mkdocs_starter.it/#ottenere-aiuto","text":"Vedi la Guida utente per una documentazione pi\u00f9 completa di tutte le caratteristiche di MkDocs. Per ottenere aiuto con MkDocs, usa le discussioni su GitHub o la risoluzione dei problemi su GitHub.","title":"Ottenere aiuto"},{"location":"mkdocs/10_virtualenv/","tags":["python","mkdocs"],"text":"Le applicazioni Python (come mkdocs ) usano spesso pacchetti e moduli che non fanno parte delle librerie standard. Questo pu\u00f2 introdurre problemi di compatibilit\u00e0 se viene utilizzata l'installazione di sistema di Python, per evitarlo si dovrebbe cercare di tenere separato l'ambiente Python di sistema dall'ambiente di sviluppo. La soluzione a questo problema \u00e8 quello di creare un ambiente virtuale, un albero di directory autonomo che contiene un'installazione Python per una particolare versione di Python, pi\u00f9 un certo numero di pacchetti aggiuntivi. Applicazioni diverse possono quindi utilizzare diversi ambienti virtuali. In questo modo ogni installazione ha la sua versione Python (e possono essere diverse per ambiente di sviluppo) e i suoi pacchetti aggiuntivi che sono richiesti dall'applicazione che vogliamo sviluppare. La guida presentata qui \u00e8 pensata per lo sviluppo e la distribuzione di servizi di rete (incluse le applicazioni web), ma \u00e8 adatta anche alla gestione di ambienti di sviluppo e di test per qualsiasi tipo di progetto. Vi mostrer\u00e0 come installare e usare gli strumenti necessari e vi introdurr\u00e0 alle pratiche migliori da osservare. Assicuratevi di avere Python e pip Prima di andare avanti, assicurati di avere Python e che sia disponibile dalla tua riga di comando. python --version Python 3 .10.4 Inoltre, assicuratevi di avere pip disponibile. pip --version pip 21 .2.3 from /usr/lib/python3.10/site-packages/pip ( python 3 .10 ) Se avete Python versione 3.4 o successiva, pip \u00e8 incluso di default. Se invece stai utilizzando FreeBSD avrai bisogno di installarlo con il comando: pkg install py38-pip Questo per python 3.8 (adattalo alle tue esigenze). Importante Come evidenziato in questo messaggio del pacchetto in FreeBSD: pip MUST ONLY be used: With the --user flag, OR To install or manage Python packages in virtual environments Failure to follow this warning can and will result in an inconsistent system-wide Python environment ( LOCALBASE/lib/pythonX.Y/site-packages ) and cause errors. L'uso di pip deve essere limitato all'installazione come utente o negli ambienti virtuali. Creare ambienti virtuali Il modulo usato per creare e gestire gli ambienti virtuali si chiama venv . venv di solito installa la versione pi\u00f9 recente di Python che avete a disposizione. Se hai pi\u00f9 versioni di Python sul tuo sistema, puoi selezionare una specifica versione di Python eseguendo python3 o qualsiasi altra versione sia necessaria. Per creare un ambiente virtuale, crea una directory dove creare l'ambiente virtuale, ed esegui il modulo venv come script con il percorso della directory: mkdir -p ~/lab/test_venv python3 -m venv ~/lab/test_venv Questo creer\u00e0 la directory test_venv se non esiste, e creer\u00e0 anche delle directory al suo interno contenenti una copia dell'interprete Python e vari file di supporto. test_venv/ \u251c\u2500\u2500 bin \u251c\u2500\u2500 include \u251c\u2500\u2500 lib \u251c\u2500\u2500 lib64 -> lib \u2514\u2500\u2500 pyvenv.cfg Una posizione comune della directory per un ambiente virtuale \u00e8 .venv . Questo nome mantiene la directory nascosta nella vostra shell, mentre il nome \u00e8 esplicativo del contenuto della directory. Previene anche i conflitti con i file di definizione delle variabili d'ambiente .env che alcuni strumenti supportano. Attivare l'ambiente virtuale Una volta creato l'ambiente virtuale, \u00e8 arrivato il momento di attivarlo, questo significa passare ad un ambiente Python completamente separato da quello di sistema, nel quale verr\u00e0 confinato tutto lo sviluppo che faremo con la nostra applicazione (installazione dei pacchetti necessari, configurazione dell'applicazione, distribuzione, etc.). L'attivazione avviene eseguendo il source della script dall'interno della cartella. cd ~/lab/test_venv source ./bin/activate Questa script \u00e8 scritta per la shell bash. Se usi altre shell come csh o fish , ci sono rispettivamente gli script alternativi activate.csh e activate.fish da usare all'occorrenza. Attivare l'ambiente virtuale cambier\u00e0 il prompt della vostra shell per mostrare quale ambiente virtuale state usando, e modificher\u00e0 l'ambiente in modo che eseguendo python otterrete quella particolare versione e installazione di Python. Per esempio: [ rocky@rockylinux test_venv ] $ source ./bin/activate ( test_venv ) [ rocky@rockylinux test_venv ] $ ( test_venv ) [ rocky@rockylinux test_venv ] $ python Python 3 .10.4 ( main, Mar 25 2022 , 00 :00:00 ) [ GCC 11 .2.1 20220127 ( Red Hat 11 .2.1-9 )] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> Gestire i pacchetti con pip Potete installare, aggiornare e rimuovere i pacchetti usando pip . Per default pip installer\u00e0 i pacchetti dal Python Package Index, https://pypi.org . Potete consultare il Python Package Index aprendolo nel vostro browser web. Pip ha un certo numero di sottocomandi: \"install\", \"uninstall\", \"freeze\", ecc. (consultate la guida Installing Python Modules per la documentazione completa di pip). Per prima cosa \u00e8 buona pratica aggiornate il pacchetto pip con il comando: python -m pip install --upgrade pip Requirement already satisfied: pip in ./lib/python3.10/site-packages ( 21 .2.3 ) Collecting pip Using cached pip-22.0.4-py3-none-any.whl ( 2 .1 MB ) Installing collected packages: pip Attempting uninstall: pip Found existing installation: pip 21 .2.3 Uninstalling pip-21.2.3: Successfully uninstalled pip-21.2.3 Successfully installed pip-22.0.4 Ora potete installare l'ultima versione di un pacchetto specificandone il nome: python -m pip install mkdocs Collecting mkdocs Using cached mkdocs-1.3.0-py3-none-any.whl ( 3 .7 MB ) Collecting click> = 3 .3 Using cached click-8.1.2-py3-none-any.whl ( 96 kB ) Collecting pyyaml-env-tag> = 0 .1 Using cached pyyaml_env_tag-0.1-py3-none-any.whl ( 3 .9 kB ) Collecting watchdog> = 2 .0 .... Puoi anche installare una versione specifica di un pacchetto fornendo a pip il nome del pacchetto seguito da == e il numero di versione: python -m pip install mkdocs == 1 .3.0 pip uninstall seguito da uno o pi\u00f9 nomi di pacchetti rimuover\u00e0 i pacchetti dall'ambiente virtuale. pip show mostrer\u00e0 informazioni su un particolare pacchetto: pip show mkdocs Name: mkdocs Version: 1 .3.0 Summary: Project documentation with Markdown. Home-page: https://www.mkdocs.org Author: Tom Christie Author-email: tom@tomchristie.com License: BSD Location: /home/rocky/lab/test_venv/lib/python3.10/site-packages Requires: click, ghp-import, importlib-metadata, Jinja2, Markdown, mergedeep, packaging, PyYAML, pyyaml-env-tag, watchdog Required-by: pip list mostrer\u00e0 tutti i pacchetti installati nell'ambiente virtuale: python -m pip list Package Version ------------------ ------- click 8 .1.2 ghp-import 2 .0.2 importlib-metadata 4 .11.3 Jinja2 3 .1.1 Markdown 3 .3.6 MarkupSafe 2 .1.1 mergedeep 1 .3.4 mkdocs 1 .3.0 packaging 21 .3 pip 22 .0.4 pyparsing 3 .0.8 python-dateutil 2 .8.2 PyYAML 6 .0 pyyaml_env_tag 0 .1 setuptools 57 .4.0 six 1 .16.0 watchdog 2 .1.7 zipp 3 .8.0 pip freeze produrr\u00e0 una lista simile a quella dei pacchetti installati, ma l'output utilizza il formato che pu\u00f2 essere interpretato da pip install . Una convenzione comune \u00e8 quella di mettere questo elenco in un file requirements.txt : python -m pip freeze > requirements.txt cat requirements.txt click == 8 .1.2 ghp-import == 2 .0.2 importlib-metadata == 4 .11.3 Jinja2 == 3 .1.1 Markdown == 3 .3.6 MarkupSafe == 2 .1.1 mergedeep == 1 .3.4 mkdocs == 1 .3.0 packaging == 21 .3 pyparsing == 3 .0.8 python-dateutil == 2 .8.2 PyYAML == 6 .0 pyyaml_env_tag == 0 .1 six == 1 .16.0 watchdog == 2 .1.7 zipp == 3 .8.0 In seguito sar\u00e0 pi\u00f9 facile per un diverso sviluppatore (o per te, se hai bisogno di ricreare l'ambiente) installare gli stessi pacchetti usando le stesse versioni con il comando: python -m pip install -r requirements.txt Uscire dall'ambiente virtuale Per uscire dall'ambiente virtuale \u00e8 sufficiente richiamare la script deactivate . Questo vi riporta all'interprete Python di default del sistema con tutte le sue librerie installate. ( test_venv ) [ rocky@rockylinux test_venv ] $ deactivate [ rocky@rockylinux test_venv ] $ Rimuovere un ambiente virtuale Per cancellare un ambiente virtuale, basta cancellare la sua cartella. rm -rf ~/lab/test_venv Conclusione L'utilizzo degli ambienti virtuali di Python permette di sviluppare varie applicazioni ognuna con le sue dipendenze e con i suoi pacchetti. Questo previene i possibili problemi di incompatibilit\u00e0 che possono derivare dall'uso dell'installazione Python di default.","title":"Ambienti Virtuali Python"},{"location":"mkdocs/10_virtualenv/#assicuratevi-di-avere-python-e-pip","text":"Prima di andare avanti, assicurati di avere Python e che sia disponibile dalla tua riga di comando. python --version Python 3 .10.4 Inoltre, assicuratevi di avere pip disponibile. pip --version pip 21 .2.3 from /usr/lib/python3.10/site-packages/pip ( python 3 .10 ) Se avete Python versione 3.4 o successiva, pip \u00e8 incluso di default. Se invece stai utilizzando FreeBSD avrai bisogno di installarlo con il comando: pkg install py38-pip Questo per python 3.8 (adattalo alle tue esigenze). Importante Come evidenziato in questo messaggio del pacchetto in FreeBSD: pip MUST ONLY be used: With the --user flag, OR To install or manage Python packages in virtual environments Failure to follow this warning can and will result in an inconsistent system-wide Python environment ( LOCALBASE/lib/pythonX.Y/site-packages ) and cause errors. L'uso di pip deve essere limitato all'installazione come utente o negli ambienti virtuali.","title":"Assicuratevi di avere Python e pip"},{"location":"mkdocs/10_virtualenv/#creare-ambienti-virtuali","text":"Il modulo usato per creare e gestire gli ambienti virtuali si chiama venv . venv di solito installa la versione pi\u00f9 recente di Python che avete a disposizione. Se hai pi\u00f9 versioni di Python sul tuo sistema, puoi selezionare una specifica versione di Python eseguendo python3 o qualsiasi altra versione sia necessaria. Per creare un ambiente virtuale, crea una directory dove creare l'ambiente virtuale, ed esegui il modulo venv come script con il percorso della directory: mkdir -p ~/lab/test_venv python3 -m venv ~/lab/test_venv Questo creer\u00e0 la directory test_venv se non esiste, e creer\u00e0 anche delle directory al suo interno contenenti una copia dell'interprete Python e vari file di supporto. test_venv/ \u251c\u2500\u2500 bin \u251c\u2500\u2500 include \u251c\u2500\u2500 lib \u251c\u2500\u2500 lib64 -> lib \u2514\u2500\u2500 pyvenv.cfg Una posizione comune della directory per un ambiente virtuale \u00e8 .venv . Questo nome mantiene la directory nascosta nella vostra shell, mentre il nome \u00e8 esplicativo del contenuto della directory. Previene anche i conflitti con i file di definizione delle variabili d'ambiente .env che alcuni strumenti supportano.","title":"Creare ambienti virtuali"},{"location":"mkdocs/10_virtualenv/#attivare-lambiente-virtuale","text":"Una volta creato l'ambiente virtuale, \u00e8 arrivato il momento di attivarlo, questo significa passare ad un ambiente Python completamente separato da quello di sistema, nel quale verr\u00e0 confinato tutto lo sviluppo che faremo con la nostra applicazione (installazione dei pacchetti necessari, configurazione dell'applicazione, distribuzione, etc.). L'attivazione avviene eseguendo il source della script dall'interno della cartella. cd ~/lab/test_venv source ./bin/activate Questa script \u00e8 scritta per la shell bash. Se usi altre shell come csh o fish , ci sono rispettivamente gli script alternativi activate.csh e activate.fish da usare all'occorrenza. Attivare l'ambiente virtuale cambier\u00e0 il prompt della vostra shell per mostrare quale ambiente virtuale state usando, e modificher\u00e0 l'ambiente in modo che eseguendo python otterrete quella particolare versione e installazione di Python. Per esempio: [ rocky@rockylinux test_venv ] $ source ./bin/activate ( test_venv ) [ rocky@rockylinux test_venv ] $ ( test_venv ) [ rocky@rockylinux test_venv ] $ python Python 3 .10.4 ( main, Mar 25 2022 , 00 :00:00 ) [ GCC 11 .2.1 20220127 ( Red Hat 11 .2.1-9 )] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>>","title":"Attivare l'ambiente virtuale"},{"location":"mkdocs/10_virtualenv/#gestire-i-pacchetti-con-pip","text":"Potete installare, aggiornare e rimuovere i pacchetti usando pip . Per default pip installer\u00e0 i pacchetti dal Python Package Index, https://pypi.org . Potete consultare il Python Package Index aprendolo nel vostro browser web. Pip ha un certo numero di sottocomandi: \"install\", \"uninstall\", \"freeze\", ecc. (consultate la guida Installing Python Modules per la documentazione completa di pip). Per prima cosa \u00e8 buona pratica aggiornate il pacchetto pip con il comando: python -m pip install --upgrade pip Requirement already satisfied: pip in ./lib/python3.10/site-packages ( 21 .2.3 ) Collecting pip Using cached pip-22.0.4-py3-none-any.whl ( 2 .1 MB ) Installing collected packages: pip Attempting uninstall: pip Found existing installation: pip 21 .2.3 Uninstalling pip-21.2.3: Successfully uninstalled pip-21.2.3 Successfully installed pip-22.0.4 Ora potete installare l'ultima versione di un pacchetto specificandone il nome: python -m pip install mkdocs Collecting mkdocs Using cached mkdocs-1.3.0-py3-none-any.whl ( 3 .7 MB ) Collecting click> = 3 .3 Using cached click-8.1.2-py3-none-any.whl ( 96 kB ) Collecting pyyaml-env-tag> = 0 .1 Using cached pyyaml_env_tag-0.1-py3-none-any.whl ( 3 .9 kB ) Collecting watchdog> = 2 .0 .... Puoi anche installare una versione specifica di un pacchetto fornendo a pip il nome del pacchetto seguito da == e il numero di versione: python -m pip install mkdocs == 1 .3.0 pip uninstall seguito da uno o pi\u00f9 nomi di pacchetti rimuover\u00e0 i pacchetti dall'ambiente virtuale. pip show mostrer\u00e0 informazioni su un particolare pacchetto: pip show mkdocs Name: mkdocs Version: 1 .3.0 Summary: Project documentation with Markdown. Home-page: https://www.mkdocs.org Author: Tom Christie Author-email: tom@tomchristie.com License: BSD Location: /home/rocky/lab/test_venv/lib/python3.10/site-packages Requires: click, ghp-import, importlib-metadata, Jinja2, Markdown, mergedeep, packaging, PyYAML, pyyaml-env-tag, watchdog Required-by: pip list mostrer\u00e0 tutti i pacchetti installati nell'ambiente virtuale: python -m pip list Package Version ------------------ ------- click 8 .1.2 ghp-import 2 .0.2 importlib-metadata 4 .11.3 Jinja2 3 .1.1 Markdown 3 .3.6 MarkupSafe 2 .1.1 mergedeep 1 .3.4 mkdocs 1 .3.0 packaging 21 .3 pip 22 .0.4 pyparsing 3 .0.8 python-dateutil 2 .8.2 PyYAML 6 .0 pyyaml_env_tag 0 .1 setuptools 57 .4.0 six 1 .16.0 watchdog 2 .1.7 zipp 3 .8.0 pip freeze produrr\u00e0 una lista simile a quella dei pacchetti installati, ma l'output utilizza il formato che pu\u00f2 essere interpretato da pip install . Una convenzione comune \u00e8 quella di mettere questo elenco in un file requirements.txt : python -m pip freeze > requirements.txt cat requirements.txt click == 8 .1.2 ghp-import == 2 .0.2 importlib-metadata == 4 .11.3 Jinja2 == 3 .1.1 Markdown == 3 .3.6 MarkupSafe == 2 .1.1 mergedeep == 1 .3.4 mkdocs == 1 .3.0 packaging == 21 .3 pyparsing == 3 .0.8 python-dateutil == 2 .8.2 PyYAML == 6 .0 pyyaml_env_tag == 0 .1 six == 1 .16.0 watchdog == 2 .1.7 zipp == 3 .8.0 In seguito sar\u00e0 pi\u00f9 facile per un diverso sviluppatore (o per te, se hai bisogno di ricreare l'ambiente) installare gli stessi pacchetti usando le stesse versioni con il comando: python -m pip install -r requirements.txt","title":"Gestire i pacchetti con pip"},{"location":"mkdocs/10_virtualenv/#uscire-dallambiente-virtuale","text":"Per uscire dall'ambiente virtuale \u00e8 sufficiente richiamare la script deactivate . Questo vi riporta all'interprete Python di default del sistema con tutte le sue librerie installate. ( test_venv ) [ rocky@rockylinux test_venv ] $ deactivate [ rocky@rockylinux test_venv ] $","title":"Uscire dall'ambiente virtuale"},{"location":"mkdocs/10_virtualenv/#rimuovere-un-ambiente-virtuale","text":"Per cancellare un ambiente virtuale, basta cancellare la sua cartella. rm -rf ~/lab/test_venv","title":"Rimuovere un ambiente virtuale"},{"location":"mkdocs/10_virtualenv/#conclusione","text":"L'utilizzo degli ambienti virtuali di Python permette di sviluppare varie applicazioni ognuna con le sue dipendenze e con i suoi pacchetti. Questo previene i possibili problemi di incompatibilit\u00e0 che possono derivare dall'uso dell'installazione Python di default.","title":"Conclusione"},{"location":"nvchad/additional_software_en/","tags":["nvchad","coding"],"text":"Additional Software Required RipGrep ripgrep is a line-oriented search tool that recursively searches the current directory for a regex (regular expression) pattern. By default, ripgrep respects the rules of gitignore and automatically skips hidden files/directories and binaries. Ripgrep offers excellent support on Windows, macOS and Linux, with binaries available at the for each release. Ripgrep is a software written in Rust and is installable with the cargo utility. Note, however, that cargo is not installed by the default installation of rust so you have to install it explicitly. dnf install rust cargo Once the necessary software is installed, we can install it with: cargo install ripgrep The installation will save the rg executable in the ~/.cargo/bin folder which is outside the PATH, to use it at the user level we will move it to ~/.local.bin/ . mv ~/.cargo/bin/rg ~/.local/bin/ At this point we can verify that everything is in place with: rg --version ripgrep 13 .0.0 -SIMD -AVX ( compiled ) +SIMD +AVX ( runtime ) RipGrep is needed for recursive searches with :Telescope . Lazygit LazyGit is an ncurses-style interface that allows you to perform all git operations in a more user-friendly way, it is required by the nvim.lazygit plugin, this plugin makes it possible to use LazyGit directly from NvChad, it opens a floating window from where you can perform all operations on your repositories, thus allowing you to make all changes to the repository git without leaving the editor. To install it we can use the repository for Fedora, on Rocky Linux 9 it works perfectly. sudo dnf copr enable atim/lazygit -y sudo dnf install lazygit Once installed we open a terminal and type the command lazygit and an interface similar to this will appear, with the x key we can bring up the menu with all available commands. LSP What is the Language Server protocol? It is a server service that provides support for advanced editing functions, such as automatic source code completion or the \"Go to Definition\" function for a programming language in an editor or IDE. The Language Server Protocol (LSP) is the product of standardizing the messages exchanged between a development tool and a language server process. The goal of LSP is to simplify this type of integration and to provide a useful framework for exposing language features to a variety of tools. LSP in NvChad NvChad provides an automatic mechanism for installing language servers through the nvim.lspconfig plugin. Introduction to nvim.lspconfig nvim-lspconfig is a collection of configurations, provided by the community, for the language client server built into the Nvim core. This plugin provides four main features: default startup commands, initialization options, and settings for each server. a root directory resolver that attempts to locate the root of the project an automatic command mapping that launches either a new language server or a language server for each open buffer if it is part of a traced project. utility commands such as LspInfo, LspStart, LspStop, and LspRestart for managing language server instances. Installation with npm npm is a powerful package manager and the key to the success of Node.js. It allows you to query, install, update packages. In the default installation on Rocky Linux the installation path of npm is /usr/local/ and thus requires administrator privileges to write into it, in order to use npm at user level we need to make some changes to its configuration. The modification allows us to use the full functionality of language servers while keeping the operating system tree clean. First, let's update npm : npm install -g npm@latest npm --version 8.15.1 Now we check the default path of npm with: npm config get prefix /usr/local What we want to do is change the directory set in the prefix variable to be able to install global packages in our home directory . We then change the variable and verify that the change has been registered with: npm config set prefix=$HOME/.local npm config get prefix /home/your_username/.local your_username clearly is an arbitrary name, instead there should be the username of the currently logged in user. Now we need to install npm again since the one currently installed is still owned by root . The new installation will also create all the directories and files needed for user-level management. npm install npm@latest -g From now on, all requested installations even if requested globally will be installed in .local/bin , the path is already in the user's PATH and this will make the executables immediately available. vscode-langserver-extracted The package is a cumulative package that contains language servers for HTML, CSS, JSON, Markdown and ESLint, to install it we use the following command: npm install vscode-langserver-extracted -g Once the installation is finished, we can verify that the language servers have been properly installed with: ls .local/bin/vscode* .local/bin/vscode-css-language-server .local/bin/vscode-eslint-language-server .local/bin/vscode-html-language-server .local/bin/vscode-json-language-server .local/bin/vscode-markdown-language-server In order to give NvChad a way to register them as local servers and load them as needed, we need to put them in the lspconfig.lua configuration file. local servers = { \"html\" , \"cssls\" , \"jsonls\" } SumnekoLua Another very important component is the lua-language-server executable, which completely changes the experience of writing lua code, and consequently also the editing of NvChad configuration files that are written in this language. This is also the default LSP for lua in Nvchad. L'eseguibile \u00e8 fornito dal progetto SumnekoLua e pu\u00f2 essere scaricato a questo indirizzo: https://github.com/sumneko/lua-language-server/releases/download/3.5.1/lua-language-server-3.5.1-linux-x64.tar.gz Once downloaded we need to unzip it somewhere and create a symbolic link of the executable in some specified folder in the PATH. To do this we unpack the file in ~/.local/share/ : mkdir -p ~/.local/share/lua-language-server tar xvzf lua-language-server-3.5.1-linux-x64.tar.gz -C ~/.local/share/lua-language-server And then from the folder ~/.local/bin/ we create a symbolic link to lua-language-server cd ~/.local/bin/ ln -s ~/.local/share/lua-language-server/bin/lua-language-server lua-language-server At this point you will have an assistant while writing and editing files written in lua . It should be noted that the lua server does not need to be configured in the lspconfig.lua configuration file as it being the default server for NvChad works without the need for any additional configuration. And if we use the <escape> key followed by the q key we get the list of errors found in the open file. Marksman Marksman is a language server for Markdown that provides auto-completion, go-to definitions, reference searching, diagnostics, etc. All types of links support completion, hover, and goto/reference definition. In addition, Marksman provides diagnostics for wiki links to detect broken references and duplicate/ambiguous titles. The language server is provided as an executable for various architectures, in this case we will need the linux version which can be downloaded at this address: https://github.com/artempyanykh/marksman/releases In order to have the support we have to move it to some PATH location which in our case will be ~/.local/bin/ and rename it by removing the -linux suffix and making it executable, assuming we have downloaded it to /home/user/downloads/ the command will be as follows: mv /home/user/downloads/marksman-linux ~/.local/bin/ chmod +x ~/.local/bin/marksman Ora \u00e8 il momento di inserirlo nei local server del file di configurazione lspconfig.lua , la riga da modificare \u00e8 la seguente: local servers = { \"html\" , \"cssls\" , \"jsonls\" , \"marksman\" } Having done this by opening a file written in Markdown we will have all the advanced features. And if we try to create some errors, in our example we will create a few blank lines that in markdown are not an error but are considered to be poor formatting we will get a visual warning (the pink squares to the left of the line number) that will alert us of the problem. yamlls 'yamlls` provides the functions of validating the entire yaml file, checking for errors and warnings regarding the code, autocompletion of commands, and hovering over a node displays the description, if available. The language server is provided by the package yaml-language-server that can be installed with npm : npm install -g yaml-language-server As with the other language servers we need to add it to the local servers of our plugin: local servers = { \"html\" , \"cssls\" , \"jsonls\" , \"marksman\" , \"yamlls\" } Once installed it will spring into action whenever we open a .yaml file by making a valuable contribution to writing and debugging code.","title":"Additional Software"},{"location":"nvchad/additional_software_en/#additional-software-required","text":"","title":"Additional Software Required"},{"location":"nvchad/additional_software_en/#ripgrep","text":"ripgrep is a line-oriented search tool that recursively searches the current directory for a regex (regular expression) pattern. By default, ripgrep respects the rules of gitignore and automatically skips hidden files/directories and binaries. Ripgrep offers excellent support on Windows, macOS and Linux, with binaries available at the for each release. Ripgrep is a software written in Rust and is installable with the cargo utility. Note, however, that cargo is not installed by the default installation of rust so you have to install it explicitly. dnf install rust cargo Once the necessary software is installed, we can install it with: cargo install ripgrep The installation will save the rg executable in the ~/.cargo/bin folder which is outside the PATH, to use it at the user level we will move it to ~/.local.bin/ . mv ~/.cargo/bin/rg ~/.local/bin/ At this point we can verify that everything is in place with: rg --version ripgrep 13 .0.0 -SIMD -AVX ( compiled ) +SIMD +AVX ( runtime ) RipGrep is needed for recursive searches with :Telescope .","title":"RipGrep"},{"location":"nvchad/additional_software_en/#lazygit","text":"LazyGit is an ncurses-style interface that allows you to perform all git operations in a more user-friendly way, it is required by the nvim.lazygit plugin, this plugin makes it possible to use LazyGit directly from NvChad, it opens a floating window from where you can perform all operations on your repositories, thus allowing you to make all changes to the repository git without leaving the editor. To install it we can use the repository for Fedora, on Rocky Linux 9 it works perfectly. sudo dnf copr enable atim/lazygit -y sudo dnf install lazygit Once installed we open a terminal and type the command lazygit and an interface similar to this will appear, with the x key we can bring up the menu with all available commands.","title":"Lazygit"},{"location":"nvchad/additional_software_en/#lsp","text":"What is the Language Server protocol? It is a server service that provides support for advanced editing functions, such as automatic source code completion or the \"Go to Definition\" function for a programming language in an editor or IDE. The Language Server Protocol (LSP) is the product of standardizing the messages exchanged between a development tool and a language server process. The goal of LSP is to simplify this type of integration and to provide a useful framework for exposing language features to a variety of tools.","title":"LSP"},{"location":"nvchad/additional_software_en/#lsp-in-nvchad","text":"NvChad provides an automatic mechanism for installing language servers through the nvim.lspconfig plugin.","title":"LSP in NvChad"},{"location":"nvchad/additional_software_en/#introduction-to-nvimlspconfig","text":"nvim-lspconfig is a collection of configurations, provided by the community, for the language client server built into the Nvim core. This plugin provides four main features: default startup commands, initialization options, and settings for each server. a root directory resolver that attempts to locate the root of the project an automatic command mapping that launches either a new language server or a language server for each open buffer if it is part of a traced project. utility commands such as LspInfo, LspStart, LspStop, and LspRestart for managing language server instances.","title":"Introduction to nvim.lspconfig"},{"location":"nvchad/additional_software_en/#installation-with-npm","text":"npm is a powerful package manager and the key to the success of Node.js. It allows you to query, install, update packages. In the default installation on Rocky Linux the installation path of npm is /usr/local/ and thus requires administrator privileges to write into it, in order to use npm at user level we need to make some changes to its configuration. The modification allows us to use the full functionality of language servers while keeping the operating system tree clean. First, let's update npm : npm install -g npm@latest npm --version 8.15.1 Now we check the default path of npm with: npm config get prefix /usr/local What we want to do is change the directory set in the prefix variable to be able to install global packages in our home directory . We then change the variable and verify that the change has been registered with: npm config set prefix=$HOME/.local npm config get prefix /home/your_username/.local your_username clearly is an arbitrary name, instead there should be the username of the currently logged in user. Now we need to install npm again since the one currently installed is still owned by root . The new installation will also create all the directories and files needed for user-level management. npm install npm@latest -g From now on, all requested installations even if requested globally will be installed in .local/bin , the path is already in the user's PATH and this will make the executables immediately available.","title":"Installation with npm"},{"location":"nvchad/additional_software_en/#vscode-langserver-extracted","text":"The package is a cumulative package that contains language servers for HTML, CSS, JSON, Markdown and ESLint, to install it we use the following command: npm install vscode-langserver-extracted -g Once the installation is finished, we can verify that the language servers have been properly installed with: ls .local/bin/vscode* .local/bin/vscode-css-language-server .local/bin/vscode-eslint-language-server .local/bin/vscode-html-language-server .local/bin/vscode-json-language-server .local/bin/vscode-markdown-language-server In order to give NvChad a way to register them as local servers and load them as needed, we need to put them in the lspconfig.lua configuration file. local servers = { \"html\" , \"cssls\" , \"jsonls\" }","title":"vscode-langserver-extracted"},{"location":"nvchad/additional_software_en/#sumnekolua","text":"Another very important component is the lua-language-server executable, which completely changes the experience of writing lua code, and consequently also the editing of NvChad configuration files that are written in this language. This is also the default LSP for lua in Nvchad. L'eseguibile \u00e8 fornito dal progetto SumnekoLua e pu\u00f2 essere scaricato a questo indirizzo: https://github.com/sumneko/lua-language-server/releases/download/3.5.1/lua-language-server-3.5.1-linux-x64.tar.gz Once downloaded we need to unzip it somewhere and create a symbolic link of the executable in some specified folder in the PATH. To do this we unpack the file in ~/.local/share/ : mkdir -p ~/.local/share/lua-language-server tar xvzf lua-language-server-3.5.1-linux-x64.tar.gz -C ~/.local/share/lua-language-server And then from the folder ~/.local/bin/ we create a symbolic link to lua-language-server cd ~/.local/bin/ ln -s ~/.local/share/lua-language-server/bin/lua-language-server lua-language-server At this point you will have an assistant while writing and editing files written in lua . It should be noted that the lua server does not need to be configured in the lspconfig.lua configuration file as it being the default server for NvChad works without the need for any additional configuration. And if we use the <escape> key followed by the q key we get the list of errors found in the open file.","title":"SumnekoLua"},{"location":"nvchad/additional_software_en/#marksman","text":"Marksman is a language server for Markdown that provides auto-completion, go-to definitions, reference searching, diagnostics, etc. All types of links support completion, hover, and goto/reference definition. In addition, Marksman provides diagnostics for wiki links to detect broken references and duplicate/ambiguous titles. The language server is provided as an executable for various architectures, in this case we will need the linux version which can be downloaded at this address: https://github.com/artempyanykh/marksman/releases In order to have the support we have to move it to some PATH location which in our case will be ~/.local/bin/ and rename it by removing the -linux suffix and making it executable, assuming we have downloaded it to /home/user/downloads/ the command will be as follows: mv /home/user/downloads/marksman-linux ~/.local/bin/ chmod +x ~/.local/bin/marksman Ora \u00e8 il momento di inserirlo nei local server del file di configurazione lspconfig.lua , la riga da modificare \u00e8 la seguente: local servers = { \"html\" , \"cssls\" , \"jsonls\" , \"marksman\" } Having done this by opening a file written in Markdown we will have all the advanced features. And if we try to create some errors, in our example we will create a few blank lines that in markdown are not an error but are considered to be poor formatting we will get a visual warning (the pink squares to the left of the line number) that will alert us of the problem.","title":"Marksman"},{"location":"nvchad/additional_software_en/#yamlls","text":"'yamlls` provides the functions of validating the entire yaml file, checking for errors and warnings regarding the code, autocompletion of commands, and hovering over a node displays the description, if available. The language server is provided by the package yaml-language-server that can be installed with npm : npm install -g yaml-language-server As with the other language servers we need to add it to the local servers of our plugin: local servers = { \"html\" , \"cssls\" , \"jsonls\" , \"marksman\" , \"yamlls\" } Once installed it will spring into action whenever we open a .yaml file by making a valuable contribution to writing and debugging code.","title":"yamlls"},{"location":"nvchad/install/","tags":["lua","nvchad","programmazione"],"text":"Pre-requisiti Neovim 0.7.0 - Se la versione di neovim per il vostro sistema operativo \u00e8 molto datata, allora considerate di provare questo gestore di versioni di neovim. Utilizzare un carattere Nerd nell'emulatore di terminale. Semi-opzionale ripgrep \u00e8 necessario per la ricerca grep con Telescope Installazione Linux/macos (UNIX) git clone https://github.com/NvChad/NvChad ~/.config/nvim --depth 1 ; nvim Windows git clone https://github.com/NvChad/NvChad $HOMEAppData\\Local\\nvim --depth 1 ; nvim (Nota: gli utenti Windows devono avere mingw installato e impostato sul percorso) Aggiornamento NvChad ha un meccanismo di aggiornamento incorporato, che porter\u00e0 ogni nuovo aggiornamento al repository git. Aggiornare nvchad premendo <leader> + uu Nota: per impostazione predefinita di NvChad, <leader> \u00e8 il tasto <spazio>. Questo aprir\u00e0 un prompt in NeoVim che vi avvertir\u00e0 che sta per fare un git reset --hard e perderete tutte le personalizzazioni che avete fatto a NvChad al di fuori della cartella personalizzata. Rimozione linux/macos (unix) rm -rf ~/.config/nvim rm -rf ~/.local/share/nvim rm -rf ~/.cache/nvim windows rd -r ~AppData\\Local\\nvim rd -r ~AppData\\Local\\nvim-data","title":"Installazione"},{"location":"nvchad/install/#pre-requisiti","text":"Neovim 0.7.0 - Se la versione di neovim per il vostro sistema operativo \u00e8 molto datata, allora considerate di provare questo gestore di versioni di neovim. Utilizzare un carattere Nerd nell'emulatore di terminale.","title":"Pre-requisiti"},{"location":"nvchad/install/#semi-opzionale","text":"ripgrep \u00e8 necessario per la ricerca grep con Telescope","title":"Semi-opzionale"},{"location":"nvchad/install/#installazione","text":"","title":"Installazione"},{"location":"nvchad/install/#linuxmacos-unix","text":"git clone https://github.com/NvChad/NvChad ~/.config/nvim --depth 1 ; nvim","title":"Linux/macos (UNIX)"},{"location":"nvchad/install/#windows","text":"git clone https://github.com/NvChad/NvChad $HOMEAppData\\Local\\nvim --depth 1 ; nvim (Nota: gli utenti Windows devono avere mingw installato e impostato sul percorso)","title":"Windows"},{"location":"nvchad/install/#aggiornamento","text":"NvChad ha un meccanismo di aggiornamento incorporato, che porter\u00e0 ogni nuovo aggiornamento al repository git. Aggiornare nvchad premendo <leader> + uu Nota: per impostazione predefinita di NvChad, <leader> \u00e8 il tasto <spazio>. Questo aprir\u00e0 un prompt in NeoVim che vi avvertir\u00e0 che sta per fare un git reset --hard e perderete tutte le personalizzazioni che avete fatto a NvChad al di fuori della cartella personalizzata.","title":"Aggiornamento"},{"location":"nvchad/install/#rimozione","text":"","title":"Rimozione"},{"location":"nvchad/install/#linuxmacos-unix_1","text":"rm -rf ~/.config/nvim rm -rf ~/.local/share/nvim rm -rf ~/.cache/nvim","title":"linux/macos (unix)"},{"location":"nvchad/install/#windows_1","text":"rd -r ~AppData\\Local\\nvim rd -r ~AppData\\Local\\nvim-data","title":"windows"},{"location":"nvchad/post_install/","tags":["lua","nvchad","programmazione"],"text":"Vi invitiamo caldamente a imparare a usare NeoVim/Vim . Se siete totalmente inesperti di vim, non potete usare nvchad, dovete avere almeno una conoscenza di base. Documentazione Questi sono altamente raccomandati e sono un must per ogni nuovo Vimmer Tutorial di Vim :Tutor Documenti di aiuto incorporati :h <cmd> :h autocommand :h vim.api :h inserisci Documentazione Online Cerca su un motore di ricerca il tuo problema Esempio di ricerca: neovim come cancellare 10 righe Riferimento rapido a NeoVim Giochi di movimento in Vim Avventure di Vim Vim Genius Dopo l'installazione iniziale, si consiglia di impostare la configurazione in base alle proprie esigenze. Impostazione della configurazione personalizzata NvChad esclude dalla gestione git la cartella lua/custom, in modo che quando nvchad si aggiorna non la modifichi, ma la conservi e conservi tutte le modifiche fatte in questa cartella. custom/init.lua viene caricato alla fine nel file init.lua principale, aggiungere qui i comandi, gli autocmd, ecc. custom/chadrc.lua \u00e8 usato per sovrascrivere core/default_config.lua e in pratica controllare l'intero nvchad , basta includere i valori che si desiderano cambiare del file predefinito. Pu\u00f2 essere usato per sovrascrivere e aggiungere opzioni vim, mappature, gestione dei plugin ecc. NvChad fornisce init.lua e chadrc.lua all'interno della cartella examples . Per iniziare a configurare NvChad secondo le proprie esigenze, copiare questi file modello: mkdir lua/custom cp examples/init.lua lua/custom/init.lua cp examples/chadrc.lua lua/custom/chadrc.lua Installare i parser Treesitter L'obiettivo di nvim-treesitter \u00e8 quello di fornire funzionalit\u00e0 di base come l'evidenziazione della sintassi per vari linguaggi. Per maggiori informazioni, consultare il loro repository all'indirizzo nvim-treesitter . Per esempio, per installare il parser treesitter per css e html : :TSInstall css html Per un elenco delle lingue supportate, consultare la documentazione .","title":"Post Installazione"},{"location":"nvchad/post_install/#documentazione","text":"Questi sono altamente raccomandati e sono un must per ogni nuovo Vimmer","title":"Documentazione"},{"location":"nvchad/post_install/#tutorial-di-vim","text":":Tutor","title":"Tutorial di Vim"},{"location":"nvchad/post_install/#documenti-di-aiuto-incorporati","text":":h <cmd> :h autocommand :h vim.api :h inserisci","title":"Documenti di aiuto incorporati"},{"location":"nvchad/post_install/#documentazione-online","text":"Cerca su un motore di ricerca il tuo problema Esempio di ricerca: neovim come cancellare 10 righe Riferimento rapido a NeoVim Giochi di movimento in Vim Avventure di Vim Vim Genius Dopo l'installazione iniziale, si consiglia di impostare la configurazione in base alle proprie esigenze.","title":"Documentazione Online"},{"location":"nvchad/post_install/#impostazione-della-configurazione-personalizzata","text":"NvChad esclude dalla gestione git la cartella lua/custom, in modo che quando nvchad si aggiorna non la modifichi, ma la conservi e conservi tutte le modifiche fatte in questa cartella. custom/init.lua viene caricato alla fine nel file init.lua principale, aggiungere qui i comandi, gli autocmd, ecc. custom/chadrc.lua \u00e8 usato per sovrascrivere core/default_config.lua e in pratica controllare l'intero nvchad , basta includere i valori che si desiderano cambiare del file predefinito. Pu\u00f2 essere usato per sovrascrivere e aggiungere opzioni vim, mappature, gestione dei plugin ecc. NvChad fornisce init.lua e chadrc.lua all'interno della cartella examples . Per iniziare a configurare NvChad secondo le proprie esigenze, copiare questi file modello: mkdir lua/custom cp examples/init.lua lua/custom/init.lua cp examples/chadrc.lua lua/custom/chadrc.lua","title":"Impostazione della configurazione personalizzata"},{"location":"nvchad/post_install/#installare-i-parser-treesitter","text":"L'obiettivo di nvim-treesitter \u00e8 quello di fornire funzionalit\u00e0 di base come l'evidenziazione della sintassi per vari linguaggi. Per maggiori informazioni, consultare il loro repository all'indirizzo nvim-treesitter . Per esempio, per installare il parser treesitter per css e html : :TSInstall css html Per un elenco delle lingue supportate, consultare la documentazione .","title":"Installare i parser Treesitter"},{"location":"nvchad/config/","tags":["lua","nvchad","programmazione"],"text":"Struttura (NOTA: assicurarsi di conoscere le basi di lua, se non le si conosce controllare). NvChad viene fornito con la seguente struttura di file/cartelle. Una struttura completa e aggiornata pu\u00f2 essere visualizzata nel repo . \u251c\u2500\u2500 init.lua \u2502 \u251c\u2500\u2500 lua \u2502 \u2502 \u2502 \u251c\u2500\u2500 core \u2502 \u2502 \u251c\u2500\u2500 autocmds.lua \u2502 \u2502 \u251c\u2500\u2500 default_config.lua \u2502 \u2502 \u251c\u2500\u2500 mappings.lua \u2502 \u2502 \u251c\u2500\u2500 options.lua \u2502 \u2502 \u2514\u2500\u2500 utils.lua (i) \u2502 \u2502 \u2502 \u251c\u2500\u2500 plugins \u2502 \u2502 \u251c\u2500\u2500 init.lua \u2502 \u2502 \u251c\u2500\u2500 packerInit.lua \u2502 \u2502 \u2514\u2500\u2500 configs \u2502 \u2502 \u251c\u2500\u2500 bufferline.lua \u2502 \u2502 \u251c\u2500\u2500 others.lua \u2502 \u2502 \u2514\u2500\u2500 many more plugin configs \u2502 \u2502 \u2502 \u251c\u2500\u2500 custom * \u2502 \u2502 \u251c\u2500\u2500 chadrc.lua \u2502 \u2502 \u251c\u2500\u2500 init.lua \u2502 \u2502 \u251c\u2500\u2500 more files, dirs I nomi dei file nell'albero contrassegnati con (i) sono da ignorare, l'utente non ha bisogno di guardarli in quanto il codice lua in quei file potrebbe spaventare o sembrare molto complesso. (*) : la cartella personalizzata custom deve essere creata dall'utente. Init.lua La configurazione di NvChad ha una cartella lua e il file init.lua . Il file init.lua carica fondamentalmente la configurazione principale e quella personalizzata. pcall \u00e8 solitamente usato per la gestione degli errori. Controllare la documentazione di lua per maggiori informazioni. Temi Per prima cosa copiare examples/chadrc.lua in lua/custom /chadrc.lua, assicurandosi che contenga la tabella dei temi <leader> + th (<leader> \u00e8 <space> nella nostra configurazione) Mappature :Telescope keymaps Opzioni generali predefinite Questo file \u00e8 lua/core/default_config.lua La tabella sottostante contiene tutte le opzioni predefinite per varie impostazioni in NvChad. Per esempio : M . options = {} M . ui = {} M . plugins = {} M . mappings = {} ha mappature generali I plugin La cartella lua/plugins contiene tre file, init.lua , packerInit.lua . packerInit.lua : questo file \u00e8 usato per definire l'avvio del packer, quindi cose come clone_timeout, compile_on_sync, ecc. e altre opzioni relative al packer sono menzionate qui. init.lua : \u00e8 fondamentalmente la configurazione di packer che elenca i vari plugin, chiama prima packerInit e poi segue con le definizioni degli altri plugin e le loro configurazioni. [ \"org or username/reponame\" ] = { config = function () path to config ( require it ) end } -- example [ \"max397574/better-escape.nvim\" ] = { config = function () require ( \"plugins.configs.better_escape\" ) end } -- packer's original way of defining plugins : use { \"max397574/better-escape.nvim\" , config = function () require ( \"plugins.configs.better_escape\" ) end }","title":"Introduzione"},{"location":"nvchad/config/#struttura","text":"(NOTA: assicurarsi di conoscere le basi di lua, se non le si conosce controllare). NvChad viene fornito con la seguente struttura di file/cartelle. Una struttura completa e aggiornata pu\u00f2 essere visualizzata nel repo . \u251c\u2500\u2500 init.lua \u2502 \u251c\u2500\u2500 lua \u2502 \u2502 \u2502 \u251c\u2500\u2500 core \u2502 \u2502 \u251c\u2500\u2500 autocmds.lua \u2502 \u2502 \u251c\u2500\u2500 default_config.lua \u2502 \u2502 \u251c\u2500\u2500 mappings.lua \u2502 \u2502 \u251c\u2500\u2500 options.lua \u2502 \u2502 \u2514\u2500\u2500 utils.lua (i) \u2502 \u2502 \u2502 \u251c\u2500\u2500 plugins \u2502 \u2502 \u251c\u2500\u2500 init.lua \u2502 \u2502 \u251c\u2500\u2500 packerInit.lua \u2502 \u2502 \u2514\u2500\u2500 configs \u2502 \u2502 \u251c\u2500\u2500 bufferline.lua \u2502 \u2502 \u251c\u2500\u2500 others.lua \u2502 \u2502 \u2514\u2500\u2500 many more plugin configs \u2502 \u2502 \u2502 \u251c\u2500\u2500 custom * \u2502 \u2502 \u251c\u2500\u2500 chadrc.lua \u2502 \u2502 \u251c\u2500\u2500 init.lua \u2502 \u2502 \u251c\u2500\u2500 more files, dirs I nomi dei file nell'albero contrassegnati con (i) sono da ignorare, l'utente non ha bisogno di guardarli in quanto il codice lua in quei file potrebbe spaventare o sembrare molto complesso. (*) : la cartella personalizzata custom deve essere creata dall'utente.","title":"Struttura"},{"location":"nvchad/config/#initlua","text":"La configurazione di NvChad ha una cartella lua e il file init.lua . Il file init.lua carica fondamentalmente la configurazione principale e quella personalizzata. pcall \u00e8 solitamente usato per la gestione degli errori. Controllare la documentazione di lua per maggiori informazioni.","title":"Init.lua"},{"location":"nvchad/config/#temi","text":"Per prima cosa copiare examples/chadrc.lua in lua/custom /chadrc.lua, assicurandosi che contenga la tabella dei temi <leader> + th (<leader> \u00e8 <space> nella nostra configurazione)","title":"Temi"},{"location":"nvchad/config/#mappature","text":":Telescope keymaps","title":"Mappature"},{"location":"nvchad/config/#opzioni-generali-predefinite","text":"Questo file \u00e8 lua/core/default_config.lua La tabella sottostante contiene tutte le opzioni predefinite per varie impostazioni in NvChad. Per esempio : M . options = {} M . ui = {} M . plugins = {} M . mappings = {} ha mappature generali","title":"Opzioni generali predefinite"},{"location":"nvchad/config/#i-plugin","text":"La cartella lua/plugins contiene tre file, init.lua , packerInit.lua . packerInit.lua : questo file \u00e8 usato per definire l'avvio del packer, quindi cose come clone_timeout, compile_on_sync, ecc. e altre opzioni relative al packer sono menzionate qui. init.lua : \u00e8 fondamentalmente la configurazione di packer che elenca i vari plugin, chiama prima packerInit e poi segue con le definizioni degli altri plugin e le loro configurazioni. [ \"org or username/reponame\" ] = { config = function () path to config ( require it ) end } -- example [ \"max397574/better-escape.nvim\" ] = { config = function () require ( \"plugins.configs.better_escape\" ) end } -- packer's original way of defining plugins : use { \"max397574/better-escape.nvim\" , config = function () require ( \"plugins.configs.better_escape\" ) end }","title":"I plugin"},{"location":"nvchad/config/custom_config/","tags":["lua","nvchad","programmazione"],"text":"Configurazione personalizzata Creare la propria configurazione: Creare una cartella personalizzata in lua/ Copiare i file della cartella /examples in questa cartella personalizzata. Controlla la configurazione personalizzata di siduck come riferimento! Quelli che seguono sono solo esempi Cambiare le opzioni predefinite M . options = { user = function () vim . opt . number = false end , } -- or just load the module with your options M . options = { user = function () require ( \"custom.myoptions\" ) end , } Aggiungere plugin -- custom/plugins/init.lua return { [ \"elkowar/yuck.vim\" ] = { ft = \"yuck\" }, [ \"NvChad/nvterm\" ] = { config = function () require \"plugins.configs.nvterm\" end , }, } \u00e8 possibile utilizzare anche una tabella o semplicemente collegare il percorso della tabella per organizzare una configurazione ordinata! -- chadrc.lua M . plugins = { user = require \"custom.plugins\" } Sostituire la configurazione predefinita di un plugin Utilizzare la tabella default_plugin_config_replace in chadrc.lua M . plugins = { user = { [ \"NvChad/nvterm\" ] = { config = function () require \"custom.nvterm\" end } }, } Eseguire :PackerSync Sovrascrivere la configurazione predefinita di un plugin Questa funzione \u00e8 utile quando si vuole cambiare qualche impostazione della configurazione predefinita di un plugin, ma senza copiare e incollare l'intera configurazione! M . plugins = { override = { [ \"nvim-treesitter/nvim-treesitter\" ] = { ensure_installed = { \"html\" , \"css\" , }, } } } Nota: la parola 'nvim_treesitter' \u00e8 presa dalla funzione di sovrascrittura della tabella 'use' di treesitter di /lua/plugins/init.lua . Il metodo di cui sopra potrebbe diventare disordinato se si sovrascrivono molte configurazioni di plugin, quindi di seguito \u00e8 riportato un esempio di base per mantenerlo pulito: local pluginConfs = require \"custom.plugins.configs\" M . plugins = { override = { [ \"nvim-treesitter/nvim-treesitter\" ] = pluginConfs . treesitter , [ \"kyazdani42/nvim-tree.lua\" ] = pluginConfs . nvimtree , }, } -- custom/plugins/configs.lua file local M = {} M . treesitter = { ensure_installed = { \"lua\" , \"html\" , \"css\" , }, } M . nvimtree = { git = { enable = true , }, view = { side = \"right\" , width = 20 , }, } return M Temi locali I temi predefiniti si trovano nella cartella hl_themes del nostro repo nvim-base16. La struttura di qualsiasi tema nvchad \u00e8 simile a: -- siduck.lua = theme name local M = {} M . base_30 = { -- my colors } M . base_16 = { -- my base16 colors } return M Assicuratevi di usare i nomi esatti delle variabili! Poi mettere il file del tema in /custom/themes dir, es: custom/themes/siduck.lua M . ui = { theme = \"siduck\" , } NOTA: Il selettore di temi del Telescope \u00e8 ancora in fase di sviluppo, quindi per ora \u00e8 necessario aggiungere manualmente il nome del tema in chadrc. Sovrascrivere colori specifici nei temi M . ui = { changed_themes = { onedark = { base_16 = { base00 = \"#mycol\" , }, base_30 = { red = \"#mycol\" , white = \"#mycol\" , }, }, nord = { -- and so on! }, }, } Sovrascrivere le evidenziazioni predefinite Questo metodo pu\u00f2 essere utilizzato anche per aggiungere i propri gruppi di evidenziazione. Assicuratevi di utilizzare un gruppo di evidenziazione valido! controllare il proprio tema in: ~/.local/share/nvim/site/pack/packer/opt/base46/lua/hl_themes Nel file del tema, ad esempio: onedark.lua, solo le variabili di base_30 possono essere utilizzate per sovrascrivere i gruppi di evidenziazione personalizzati. Si possono anche usare i colori esadecimali nel campo fg/bg, ma \u00e8 preferibile usare i nomi delle variabili, ad esempio: blue, darker_black, one_bg ecc. dal file del tema, perch\u00e9 si integreranno meglio. Non \u00e8 quindi necessario importare una tabella di colori ecc. M . ui = { hl_override = { --override default highlights Pmenu = { bg = \"white\" }, MyHighlightGroup = { fg = \"red\" , bg = \"darker_black\" } }, } NOTA: controllare la sezione di integrazione del nostro repo base16 per conoscere i gruppi hl predefiniti utilizzati. Si pu\u00f2 anche usare il percorso della tabella nella tabella hl_override (assicurandosi di caricarla prima nella variabile), in questo modo: -- custom.highlights return { Pmenu = { bg = \"#ffffff\" }, MyHighlightGroup = { fg = \"blue\" , bg = \"grey\" } } -- chadrc local my_highlights = require ( \"custom.highlights\" ) M . ui = { hl_override = my_highlights } Rimuovere i plugin M . plugins = { remove = { \"andymass/vim-matchup\" , \"NvChad/nvterm\" , }, } Eseguire: PackerSync Modificare le opzioni di definizione dei plugin Ad esempio, questa \u00e8 la definizione di nvimtree [ \"kyazdani42/nvim-tree.lua\" ] = { cmd = { \"NvimTreeToggle\" , \"NvimTreeFocus\" }, setup = function () require ( \"core.mappings\" ). nvimtree () end , config = function () require \"plugins.configs.nvimtree\" end , } Now to change cmd, setup or any option defined in it: M . plugins = { user = { [ \"kyazdani42/nvim-tree.lua\" ] = { cmd = { \"abc\" }, setup = function () require ( \"core.mappings\" ). yourfile end , config = function () your stuff ! end , } } } Eseguire: PackerSync Abilitare la dashboard local M = {} M . plugins = { user = { [ \"goolord/alpha-nvim\" ] = { disable = false , }, }, } return M Eseguire: PackerSync Questo \u00e8 un esempio, ma \u00e8 meglio inserire alfa nella tabella dell'elenco dei plugin personalizzati, che molto probabilmente si trova in un altro file, se si ama organizzare le cose. Istantanea Packer Eseguiamo :PackerSnapshot stable_chad (questo comando crea nuove istantanee) il mio chadrc potrebbe apparire come questo M . plugins = { override = { [ \"wbthomason/packer.nvim\" ] = { snapshot = \"stable_chad\" , } } } Nel caso in cui si verifichi un problema di interruzione, \u00e8 sufficiente eseguire :PackerSnapshotRollback stable_chad e attendere 1-2 minuti. Per eliminare l'istantanea, PackerSnapshotDelete stable_chad Autocmds Per esempio, si pu\u00f2 creare un nuovo file chiamato autochad_cmds.lua nella cartella lua/custom e richiederlo in lua/custom/init.lua! oppure definire autocmds in custom/init.lua. File da modificare Modificare solo i file nella cartella custom, non toccare nulla al di fuori di essa. Il resto dei file al di fuori della cartella personalizzata verr\u00e0 sovrascritto quando viene aggiornato usando + uu. Caricamento lazy Carichiamo in modo lazy quasi il 95% dei plugin, quindi ci aspettiamo che carichiate in modo lazy i plugin che avete aggiunto per ridurre i tempi di avvio. Non vogliamo che gli utenti rendano NvChad lento solo perch\u00e9 non hanno caricato i plugin che hanno aggiunto! Controllate il readme del packer per maggiori informazioni!","title":"Personalizzazione"},{"location":"nvchad/config/custom_config/#configurazione-personalizzata","text":"","title":"Configurazione personalizzata"},{"location":"nvchad/config/custom_config/#creare-la-propria-configurazione","text":"Creare una cartella personalizzata in lua/ Copiare i file della cartella /examples in questa cartella personalizzata. Controlla la configurazione personalizzata di siduck come riferimento! Quelli che seguono sono solo esempi","title":"Creare la propria configurazione:"},{"location":"nvchad/config/custom_config/#cambiare-le-opzioni-predefinite","text":"M . options = { user = function () vim . opt . number = false end , } -- or just load the module with your options M . options = { user = function () require ( \"custom.myoptions\" ) end , }","title":"Cambiare le opzioni predefinite"},{"location":"nvchad/config/custom_config/#aggiungere-plugin","text":"-- custom/plugins/init.lua return { [ \"elkowar/yuck.vim\" ] = { ft = \"yuck\" }, [ \"NvChad/nvterm\" ] = { config = function () require \"plugins.configs.nvterm\" end , }, } \u00e8 possibile utilizzare anche una tabella o semplicemente collegare il percorso della tabella per organizzare una configurazione ordinata! -- chadrc.lua M . plugins = { user = require \"custom.plugins\" }","title":"Aggiungere plugin"},{"location":"nvchad/config/custom_config/#sostituire-la-configurazione-predefinita-di-un-plugin","text":"Utilizzare la tabella default_plugin_config_replace in chadrc.lua M . plugins = { user = { [ \"NvChad/nvterm\" ] = { config = function () require \"custom.nvterm\" end } }, } Eseguire :PackerSync","title":"Sostituire la configurazione predefinita di un plugin"},{"location":"nvchad/config/custom_config/#sovrascrivere-la-configurazione-predefinita-di-un-plugin","text":"Questa funzione \u00e8 utile quando si vuole cambiare qualche impostazione della configurazione predefinita di un plugin, ma senza copiare e incollare l'intera configurazione! M . plugins = { override = { [ \"nvim-treesitter/nvim-treesitter\" ] = { ensure_installed = { \"html\" , \"css\" , }, } } } Nota: la parola 'nvim_treesitter' \u00e8 presa dalla funzione di sovrascrittura della tabella 'use' di treesitter di /lua/plugins/init.lua . Il metodo di cui sopra potrebbe diventare disordinato se si sovrascrivono molte configurazioni di plugin, quindi di seguito \u00e8 riportato un esempio di base per mantenerlo pulito: local pluginConfs = require \"custom.plugins.configs\" M . plugins = { override = { [ \"nvim-treesitter/nvim-treesitter\" ] = pluginConfs . treesitter , [ \"kyazdani42/nvim-tree.lua\" ] = pluginConfs . nvimtree , }, } -- custom/plugins/configs.lua file local M = {} M . treesitter = { ensure_installed = { \"lua\" , \"html\" , \"css\" , }, } M . nvimtree = { git = { enable = true , }, view = { side = \"right\" , width = 20 , }, } return M","title":"Sovrascrivere la configurazione predefinita di un plugin"},{"location":"nvchad/config/custom_config/#temi-locali","text":"I temi predefiniti si trovano nella cartella hl_themes del nostro repo nvim-base16. La struttura di qualsiasi tema nvchad \u00e8 simile a: -- siduck.lua = theme name local M = {} M . base_30 = { -- my colors } M . base_16 = { -- my base16 colors } return M Assicuratevi di usare i nomi esatti delle variabili! Poi mettere il file del tema in /custom/themes dir, es: custom/themes/siduck.lua M . ui = { theme = \"siduck\" , } NOTA: Il selettore di temi del Telescope \u00e8 ancora in fase di sviluppo, quindi per ora \u00e8 necessario aggiungere manualmente il nome del tema in chadrc.","title":"Temi locali"},{"location":"nvchad/config/custom_config/#sovrascrivere-colori-specifici-nei-temi","text":"M . ui = { changed_themes = { onedark = { base_16 = { base00 = \"#mycol\" , }, base_30 = { red = \"#mycol\" , white = \"#mycol\" , }, }, nord = { -- and so on! }, }, }","title":"Sovrascrivere colori specifici nei temi"},{"location":"nvchad/config/custom_config/#sovrascrivere-le-evidenziazioni-predefinite","text":"Questo metodo pu\u00f2 essere utilizzato anche per aggiungere i propri gruppi di evidenziazione. Assicuratevi di utilizzare un gruppo di evidenziazione valido! controllare il proprio tema in: ~/.local/share/nvim/site/pack/packer/opt/base46/lua/hl_themes Nel file del tema, ad esempio: onedark.lua, solo le variabili di base_30 possono essere utilizzate per sovrascrivere i gruppi di evidenziazione personalizzati. Si possono anche usare i colori esadecimali nel campo fg/bg, ma \u00e8 preferibile usare i nomi delle variabili, ad esempio: blue, darker_black, one_bg ecc. dal file del tema, perch\u00e9 si integreranno meglio. Non \u00e8 quindi necessario importare una tabella di colori ecc. M . ui = { hl_override = { --override default highlights Pmenu = { bg = \"white\" }, MyHighlightGroup = { fg = \"red\" , bg = \"darker_black\" } }, } NOTA: controllare la sezione di integrazione del nostro repo base16 per conoscere i gruppi hl predefiniti utilizzati. Si pu\u00f2 anche usare il percorso della tabella nella tabella hl_override (assicurandosi di caricarla prima nella variabile), in questo modo: -- custom.highlights return { Pmenu = { bg = \"#ffffff\" }, MyHighlightGroup = { fg = \"blue\" , bg = \"grey\" } } -- chadrc local my_highlights = require ( \"custom.highlights\" ) M . ui = { hl_override = my_highlights }","title":"Sovrascrivere le evidenziazioni predefinite"},{"location":"nvchad/config/custom_config/#rimuovere-i-plugin","text":"M . plugins = { remove = { \"andymass/vim-matchup\" , \"NvChad/nvterm\" , }, } Eseguire: PackerSync","title":"Rimuovere i plugin"},{"location":"nvchad/config/custom_config/#modificare-le-opzioni-di-definizione-dei-plugin","text":"Ad esempio, questa \u00e8 la definizione di nvimtree [ \"kyazdani42/nvim-tree.lua\" ] = { cmd = { \"NvimTreeToggle\" , \"NvimTreeFocus\" }, setup = function () require ( \"core.mappings\" ). nvimtree () end , config = function () require \"plugins.configs.nvimtree\" end , } Now to change cmd, setup or any option defined in it: M . plugins = { user = { [ \"kyazdani42/nvim-tree.lua\" ] = { cmd = { \"abc\" }, setup = function () require ( \"core.mappings\" ). yourfile end , config = function () your stuff ! end , } } } Eseguire: PackerSync","title":"Modificare le opzioni di definizione dei plugin"},{"location":"nvchad/config/custom_config/#abilitare-la-dashboard","text":"local M = {} M . plugins = { user = { [ \"goolord/alpha-nvim\" ] = { disable = false , }, }, } return M Eseguire: PackerSync Questo \u00e8 un esempio, ma \u00e8 meglio inserire alfa nella tabella dell'elenco dei plugin personalizzati, che molto probabilmente si trova in un altro file, se si ama organizzare le cose.","title":"Abilitare la dashboard"},{"location":"nvchad/config/custom_config/#istantanea-packer","text":"Eseguiamo :PackerSnapshot stable_chad (questo comando crea nuove istantanee) il mio chadrc potrebbe apparire come questo M . plugins = { override = { [ \"wbthomason/packer.nvim\" ] = { snapshot = \"stable_chad\" , } } } Nel caso in cui si verifichi un problema di interruzione, \u00e8 sufficiente eseguire :PackerSnapshotRollback stable_chad e attendere 1-2 minuti. Per eliminare l'istantanea, PackerSnapshotDelete stable_chad","title":"Istantanea Packer"},{"location":"nvchad/config/custom_config/#autocmds","text":"Per esempio, si pu\u00f2 creare un nuovo file chiamato autochad_cmds.lua nella cartella lua/custom e richiederlo in lua/custom/init.lua! oppure definire autocmds in custom/init.lua.","title":"Autocmds"},{"location":"nvchad/config/custom_config/#file-da-modificare","text":"Modificare solo i file nella cartella custom, non toccare nulla al di fuori di essa. Il resto dei file al di fuori della cartella personalizzata verr\u00e0 sovrascritto quando viene aggiornato usando + uu. Caricamento lazy Carichiamo in modo lazy quasi il 95% dei plugin, quindi ci aspettiamo che carichiate in modo lazy i plugin che avete aggiunto per ridurre i tempi di avvio. Non vogliamo che gli utenti rendano NvChad lento solo perch\u00e9 non hanno caricato i plugin che hanno aggiunto! Controllate il readme del packer per maggiori informazioni!","title":"File da modificare"},{"location":"nvchad/config/format_lint/","tags":["lua","nvchad","programmazione"],"text":"Formato e lint Ci sono molti plugin per questo scopo, io user\u00f2 null-ls.nvim in questo esempio! Installare null-ls [ \"jose-elias-alvarez/null-ls.nvim\" ] = { after = \"nvim-lspconfig\" , config = function () require \"custom.plugins.null-ls\" end , } -- load it after nvim-lspconfig cuz we lazy loaded lspconfig Configurazione di Null-ls NOTA : La configurazione qui sotto \u00e8 la mia personale! Quindi usatela come riferimento o controllate i documenti di null-ls. local present , null_ls = pcall ( require , \"null-ls\" ) if not present then return end local b = null_ls . builtins local sources = { -- webdev stuff b . formatting . deno_fmt , b . formatting . prettier , -- Lua b . formatting . stylua , -- Shell b . formatting . shfmt , b . diagnostics . shellcheck . with { diagnostics_format = \"#{m} [#{c}]\" }, } null_ls . setup { debug = true , sources = sources , } Formato del codice: <leader> + fm Controllare i builtins di null-ls per ottenere la configurazione per la propria lingua! Si noti anche che nell'esempio precedente ho aggiunto alcune configurazioni di linters e formatters nella configurazione di null-ls, quindi questi programmi devono essere installati anche sul mio sistema! Come prettierd, stylua, shfmt, eslint_d ecc.","title":"Formato e Lint"},{"location":"nvchad/config/format_lint/#formato-e-lint","text":"Ci sono molti plugin per questo scopo, io user\u00f2 null-ls.nvim in questo esempio!","title":"Formato e lint"},{"location":"nvchad/config/format_lint/#installare-null-ls","text":"[ \"jose-elias-alvarez/null-ls.nvim\" ] = { after = \"nvim-lspconfig\" , config = function () require \"custom.plugins.null-ls\" end , } -- load it after nvim-lspconfig cuz we lazy loaded lspconfig","title":"Installare null-ls"},{"location":"nvchad/config/format_lint/#configurazione-di-null-ls","text":"NOTA : La configurazione qui sotto \u00e8 la mia personale! Quindi usatela come riferimento o controllate i documenti di null-ls. local present , null_ls = pcall ( require , \"null-ls\" ) if not present then return end local b = null_ls . builtins local sources = { -- webdev stuff b . formatting . deno_fmt , b . formatting . prettier , -- Lua b . formatting . stylua , -- Shell b . formatting . shfmt , b . diagnostics . shellcheck . with { diagnostics_format = \"#{m} [#{c}]\" }, } null_ls . setup { debug = true , sources = sources , } Formato del codice: <leader> + fm Controllare i builtins di null-ls per ottenere la configurazione per la propria lingua! Si noti anche che nell'esempio precedente ho aggiunto alcune configurazioni di linters e formatters nella configurazione di null-ls, quindi questi programmi devono essere installati anche sul mio sistema! Come prettierd, stylua, shfmt, eslint_d ecc.","title":"Configurazione di Null-ls"},{"location":"nvchad/config/lsp_stuff/","tags":["lua","nvchad","programmazione"],"text":"Configurare il server lsp Controllare nel repo lspconfig per avere una panoramica generale di come appare/funziona la configurazione. Poi controllare server_configurations.md per assicurarsi che il server lsp della propria lingua sia presente. Creare un file nella cartella personalizzata. (Suggerisco di creare la cartella plugins nella cartella custom, quindi /custom/plugins/lspconfig.lua \u00e8 il file di configurazione per questo esempio). Inserire il percorso del file nella sezione lspconfig di chadrc : M . plugins = { options = { lspconfig = { setup_lspconf = \"custom.plugins.lspconfig\" , }, }, } -- so setup_lspconf = any file but that should be in custom dir! Il file seguente \u00e8 un esempio di file lspconfig : local M = {} M . setup_lsp = function ( attach , capabilities ) local lspconfig = require \"lspconfig\" -- lspservers with default config local servers = { \"html\" , \"cssls\" , \"clangd\" } for _ , lsp in ipairs ( servers ) do lspconfig [ lsp ]. setup { on_attach = attach , capabilities = capabilities , } end end return M Sovrascrivere on_attach \u00c8 possibile sovrascrivere il valore predefinito di on_attach , ad esempio per modificare le funzionalit\u00e0 del server: M . setup_lsp = function ( attach , capabilities ) -- [...] for _ , lsp in ipairs ( servers ) do lspconfig [ lsp ]. setup { on_attach = function ( client , bufnr ) attach ( client , bufnr ) -- change gopls server capabilities if lsp == \"gopls\" then client . resolved_capabilities . document_formatting = true client . resolved_capabilities . document_range_formatting = true end end , capabilities = capabilities , } end end Assicurarsi di passare bufnr alla funzione attach . Installatore lsp :LspInstall clangd Abbiamo abilitato l'installazione automatica nella configurazione di lsp-installer , il che significa che non \u00e8 pi\u00f9 necessario eseguire LspInstall . Qualsiasi server lsp configurato nel file lspconfig personalizzato, verr\u00e0 rilevato da lsp-installer che lo installer\u00e0 automaticamente!","title":"Lsp"},{"location":"nvchad/config/lsp_stuff/#configurare-il-server-lsp","text":"Controllare nel repo lspconfig per avere una panoramica generale di come appare/funziona la configurazione. Poi controllare server_configurations.md per assicurarsi che il server lsp della propria lingua sia presente. Creare un file nella cartella personalizzata. (Suggerisco di creare la cartella plugins nella cartella custom, quindi /custom/plugins/lspconfig.lua \u00e8 il file di configurazione per questo esempio). Inserire il percorso del file nella sezione lspconfig di chadrc : M . plugins = { options = { lspconfig = { setup_lspconf = \"custom.plugins.lspconfig\" , }, }, } -- so setup_lspconf = any file but that should be in custom dir! Il file seguente \u00e8 un esempio di file lspconfig : local M = {} M . setup_lsp = function ( attach , capabilities ) local lspconfig = require \"lspconfig\" -- lspservers with default config local servers = { \"html\" , \"cssls\" , \"clangd\" } for _ , lsp in ipairs ( servers ) do lspconfig [ lsp ]. setup { on_attach = attach , capabilities = capabilities , } end end return M","title":"Configurare il server lsp"},{"location":"nvchad/config/lsp_stuff/#sovrascrivere-on_attach","text":"\u00c8 possibile sovrascrivere il valore predefinito di on_attach , ad esempio per modificare le funzionalit\u00e0 del server: M . setup_lsp = function ( attach , capabilities ) -- [...] for _ , lsp in ipairs ( servers ) do lspconfig [ lsp ]. setup { on_attach = function ( client , bufnr ) attach ( client , bufnr ) -- change gopls server capabilities if lsp == \"gopls\" then client . resolved_capabilities . document_formatting = true client . resolved_capabilities . document_range_formatting = true end end , capabilities = capabilities , } end end Assicurarsi di passare bufnr alla funzione attach .","title":"Sovrascrivere on_attach"},{"location":"nvchad/config/lsp_stuff/#installatore-lsp","text":":LspInstall clangd Abbiamo abilitato l'installazione automatica nella configurazione di lsp-installer , il che significa che non \u00e8 pi\u00f9 necessario eseguire LspInstall . Qualsiasi server lsp configurato nel file lspconfig personalizzato, verr\u00e0 rilevato da lsp-installer che lo installer\u00e0 automaticamente!","title":"Installatore lsp"},{"location":"nvchad/config/mapping/","tags":["lua","nvchad","programmazione"],"text":"Mappature Eenco di alcune mappature importanti! C = Ctrl leader = spazio A = alt S = shift Navigare in modalit\u00e0 di inserimento C + h/j/k/l - spostamento del cursore C + b - inizio riga C + e - fine riga Commutare le finestre C + h - commuta la finestra sinistra C + j - commuta la finestra inferiore C + k - commuta la finestra superiore C + l - commuta la finestra destra Varie C + s - Salva S + b - nuovo buffer leader + n - alterna la riga dei numeri leader + rn - alterna la riga dei numeri relativi NvChad leader + uu - aggiorna nvchad leader + th - cambia tema Terminale A + i - attiva il terminale fluttuante A + h - attiva il terminale orizzontale A + v - attiva il terminale verticale leader + h - nuovo terminale orizzontale leader + v - nuovo terminale verticale NvimTree C + n - alterna NvimTree (Nota: per verificare il resto delle mappature, eseguire :Telescope keymaps). Personalizzazione I valori predefiniti sono definiti in core.mappings (core/mappings.lua), con cui \u00e8 bene familiarizzare. Le mappature utente devono essere definite nel campo mappings della tabella restituita da custom.chadrc (queste possono essere richieste da un altro file, ad esempio, M.mappings = require \"custom.mappings \") Formato delle mappature -- general format -- opts here is completely optional [ \"keys\" ] = { \"action\" , \"icon mapping description\" , opts = {}}, [ \"keys\" ] = { \"action\" , opts = {}}, -- non whichkey users -- examples [ \"<C-n>\" ] = { \"<cmd> NvimTreeToggle <CR>\" , \"Toggle nvimtree\" , opts = {}}, [ \"<C-s>\" ] = { \"<cmd> w <CR>\" , \"\ufb1a save file\" }, [ \"<leader>uu\" ] = { \"<cmd> :NvChadUpdate <CR>\" , \"\uf135 update nvchad\" }, -- example with lua function [ \"<leader>tt\" ] = { function () require ( \"base46\" ). toggle_theme () end , \"\uf205 toggle theme\" , }, La descrizione della mappatura \u00e8 richiesta per WhichKey, ma pu\u00f2 essere disabilitata. Come mostrato sopra, \u00e8 possibile usare funzioni lua nelle mappature (ad esempio, per chiamare moduli lua). Le icone sono visivamente accattivanti e aiutano la leggibilit\u00e0, ma sono facoltative. La prassi migliore \u00e8 quella di collocare le icone prima della descrizione testuale, separate da 2-3 spazi. Suggerimento: Trovare le icone da copiare/incollare all'indirizzo https://www.nerdfonts.com/cheat-sheet. Valori predefiniti delle opzioni { buffer = nil , -- Global mappings. Specify a buffer number for buffer local mappings silent = true , noremap = true , nowait = false , -- all standard key binding opts are supported } Nota: \u00e8 del tutto facoltativo Struttura della tabella delle mappature Questa \u00e8 la struttura delle mappature di core.mappings e del proprio file di mappatura. -- n , i , t etc will be the mode names so i = insert mode and so on local M = {} -- add this table only when you want to disable default keys M . disabled = { n = { [ \"<leader>h\" ] = \"\" , [ \"<C-s>\" ] = \"\" } } M . abc = { n = { [ \"<C-n>\" ] = { \"<cmd> Telescope <CR>\" , \"Open Telescope\" } } -- non which key users n = { [ \"<C-n>\" ] = { \"<cmd> Telescope <CR>\" } } i = { -- more keys! } } M . xyz = { -- stuff } return M abc e xyz sono arbitrari; potrebbero, ad esempio, essere il nome di un plugin n, i, v, sono i nomi delle modalit\u00e0, cio\u00e8 normale, inserto, visuale. Assicurarsi di mantenere una struttura di tabella simile a core.mappings Sovrascrivere le mappature predefinite e creare mappature consente di sovrascrivere le mappature di nvimtree -- chadrc M . mappings = require \"custom.mappings\" -- the above path can be any file in custom dir, just an example! -- custom.mappings local M = {} M . nvimtree = { n = { [ \"<leader>ff\" ] = { \"<cmd> NvimTreeToggle <CR>\" , \"\uf413 toggle nvimtree\" }, [ \"<C-n>\" ] = { \"<cmd> Telescope <CR>\" , \"open telescope\" }, }, } Controllare la configurazione di siduck come riferimento Allo stesso modo si possono aggiungere le mappature :) Mappatura con quale chiave disabilitata Il metodo \u00e8 lo stesso, ma in questo caso non \u00e8 necessario scrivere la descrizione delle mappature! Inserite anche questo nel vostro file custom.init.lua : require ( \"core.utils\" ). load_mappings ()","title":"Mappature"},{"location":"nvchad/config/mapping/#mappature","text":"","title":"Mappature"},{"location":"nvchad/config/mapping/#eenco-di-alcune-mappature-importanti","text":"C = Ctrl leader = spazio A = alt S = shift","title":"Eenco di alcune mappature importanti!"},{"location":"nvchad/config/mapping/#navigare-in-modalita-di-inserimento","text":"C + h/j/k/l - spostamento del cursore C + b - inizio riga C + e - fine riga","title":"Navigare in modalit\u00e0 di inserimento"},{"location":"nvchad/config/mapping/#commutare-le-finestre","text":"C + h - commuta la finestra sinistra C + j - commuta la finestra inferiore C + k - commuta la finestra superiore C + l - commuta la finestra destra","title":"Commutare le finestre"},{"location":"nvchad/config/mapping/#varie","text":"C + s - Salva S + b - nuovo buffer leader + n - alterna la riga dei numeri leader + rn - alterna la riga dei numeri relativi","title":"Varie"},{"location":"nvchad/config/mapping/#nvchad","text":"leader + uu - aggiorna nvchad leader + th - cambia tema","title":"NvChad"},{"location":"nvchad/config/mapping/#terminale","text":"A + i - attiva il terminale fluttuante A + h - attiva il terminale orizzontale A + v - attiva il terminale verticale leader + h - nuovo terminale orizzontale leader + v - nuovo terminale verticale NvimTree C + n - alterna NvimTree (Nota: per verificare il resto delle mappature, eseguire :Telescope keymaps).","title":"Terminale"},{"location":"nvchad/config/mapping/#personalizzazione","text":"I valori predefiniti sono definiti in core.mappings (core/mappings.lua), con cui \u00e8 bene familiarizzare. Le mappature utente devono essere definite nel campo mappings della tabella restituita da custom.chadrc (queste possono essere richieste da un altro file, ad esempio, M.mappings = require \"custom.mappings \")","title":"Personalizzazione"},{"location":"nvchad/config/mapping/#formato-delle-mappature","text":"-- general format -- opts here is completely optional [ \"keys\" ] = { \"action\" , \"icon mapping description\" , opts = {}}, [ \"keys\" ] = { \"action\" , opts = {}}, -- non whichkey users -- examples [ \"<C-n>\" ] = { \"<cmd> NvimTreeToggle <CR>\" , \"Toggle nvimtree\" , opts = {}}, [ \"<C-s>\" ] = { \"<cmd> w <CR>\" , \"\ufb1a save file\" }, [ \"<leader>uu\" ] = { \"<cmd> :NvChadUpdate <CR>\" , \"\uf135 update nvchad\" }, -- example with lua function [ \"<leader>tt\" ] = { function () require ( \"base46\" ). toggle_theme () end , \"\uf205 toggle theme\" , }, La descrizione della mappatura \u00e8 richiesta per WhichKey, ma pu\u00f2 essere disabilitata. Come mostrato sopra, \u00e8 possibile usare funzioni lua nelle mappature (ad esempio, per chiamare moduli lua). Le icone sono visivamente accattivanti e aiutano la leggibilit\u00e0, ma sono facoltative. La prassi migliore \u00e8 quella di collocare le icone prima della descrizione testuale, separate da 2-3 spazi. Suggerimento: Trovare le icone da copiare/incollare all'indirizzo https://www.nerdfonts.com/cheat-sheet.","title":"Formato delle mappature"},{"location":"nvchad/config/mapping/#valori-predefiniti-delle-opzioni","text":"{ buffer = nil , -- Global mappings. Specify a buffer number for buffer local mappings silent = true , noremap = true , nowait = false , -- all standard key binding opts are supported } Nota: \u00e8 del tutto facoltativo","title":"Valori predefiniti delle opzioni"},{"location":"nvchad/config/mapping/#struttura-della-tabella-delle-mappature","text":"Questa \u00e8 la struttura delle mappature di core.mappings e del proprio file di mappatura. -- n , i , t etc will be the mode names so i = insert mode and so on local M = {} -- add this table only when you want to disable default keys M . disabled = { n = { [ \"<leader>h\" ] = \"\" , [ \"<C-s>\" ] = \"\" } } M . abc = { n = { [ \"<C-n>\" ] = { \"<cmd> Telescope <CR>\" , \"Open Telescope\" } } -- non which key users n = { [ \"<C-n>\" ] = { \"<cmd> Telescope <CR>\" } } i = { -- more keys! } } M . xyz = { -- stuff } return M abc e xyz sono arbitrari; potrebbero, ad esempio, essere il nome di un plugin n, i, v, sono i nomi delle modalit\u00e0, cio\u00e8 normale, inserto, visuale. Assicurarsi di mantenere una struttura di tabella simile a core.mappings","title":"Struttura della tabella delle mappature"},{"location":"nvchad/config/mapping/#sovrascrivere-le-mappature-predefinite-e-creare-mappature","text":"consente di sovrascrivere le mappature di nvimtree -- chadrc M . mappings = require \"custom.mappings\" -- the above path can be any file in custom dir, just an example! -- custom.mappings local M = {} M . nvimtree = { n = { [ \"<leader>ff\" ] = { \"<cmd> NvimTreeToggle <CR>\" , \"\uf413 toggle nvimtree\" }, [ \"<C-n>\" ] = { \"<cmd> Telescope <CR>\" , \"open telescope\" }, }, } Controllare la configurazione di siduck come riferimento Allo stesso modo si possono aggiungere le mappature :)","title":"Sovrascrivere le mappature predefinite e creare mappature"},{"location":"nvchad/config/mapping/#mappatura-con-quale-chiave-disabilitata","text":"Il metodo \u00e8 lo stesso, ma in questo caso non \u00e8 necessario scrivere la descrizione delle mappature! Inserite anche questo nel vostro file custom.init.lua : require ( \"core.utils\" ). load_mappings ()","title":"Mappatura con quale chiave disabilitata"},{"location":"nvchad/config/nvim_lua_stuff/","text":"title: Lua per Nvim tags: - lua - nvchad -programmazione","title":"Lua per Nvim"},{"location":"rocky_linux/","text":"Rocky Linux Cronologia Tutto \u00e8 iniziato con un commento sul blog. Post Originale Ripensando ai primi giorni di CentOS... Il mio cofondatore era Rocky McGaugh. Non \u00e8 pi\u00f9 con noi, cos\u00ec come un H/T a lui, che non ha mai potuto vedere il successo che CentOS \u00e8 diventato, vi presento... Rocky Linux. Gregory Kurtzer Co-fondatore di CentOS / Fondatore di Rocky Linux L'8 dicembre 2020, Red Hat ha annunciato che avrebbe interrotto lo sviluppo di CentOS, che \u00e8 stata una versione downstream pronta per la produzione di Red Hat Enterprise Linux, in favore di una variante di sviluppo upstream pi\u00f9 recente di quel sistema operativo noto come \"CentOS Stream\". In risposta, il fondatore originale di CentOS, Gregory Kurtzer, ha annunciato tramite un commento sul sito web di CentOS che avrebbe nuovamente iniziato un progetto per raggiungere gli obiettivi originali di CentOS. Il suo nome \u00e8 stato scelto come tributo al primo co-fondatore di CentOS, Rocky McGaugh. Entro il 12 dicembre, il repository del codice di Rocky Linux era diventato il repository pi\u00f9 in voga su GitHub. Il 22 dicembre 2020, Rocky Linux ha annunciato che l'obiettivo per un primo rilascio era ovunque tra marzo e maggio del 2021. Il 20 gennaio 2021, \u00e8 stato annunciato che un repository di test sarebbe stato reso disponibile al pubblico entro la fine di febbraio, e che una release candidate era prevista per la fine di marzo 2021. Tuttavia, quella data \u00e8 stata leggermente spostata indietro, e il 30 aprile 2021, la prima release candidate \u00e8 stata ufficialmente rilasciata. La seconda release candidate, della versione 8.4, l'ultima prima del rilascio stabile, \u00e8 stata rilasciata il 4 giugno 2021. Il 21 giugno 2021, la versione stabile di Rocky Linux 8.4 \u00e8 stata rilasciata, con il nome in codice \"Green Obsidian\". In primo luogo, abbiamo fatto dei passi per proteggere legalmente il nome Rocky Linux. Questo significa registrare i suoi marchi e varie propriet\u00e0 associate per proteggerli dal controllo di un'altra entit\u00e0. Abbiamo ottenuto questo risultato istituendoli sotto la Rocky Enterprise Software Foundation (RESF). Successivamente, abbiamo redatto uno statuto della comunit\u00e0 che definisce la struttura organizzativa, gli obiettivi, i valori e la missione dietro l'entit\u00e0 legale che rappresenta Rocky Linux. Critico in questo statuto \u00e8 l'istituzione di principi che permettono e proteggono la comunit\u00e0: trasparenza, coinvolgimento della comunit\u00e0, sviluppo aperto e indipendenza. Rocky Linux non sar\u00e0 mai controllata, acquistata o altrimenti influenzata da una singola entit\u00e0 o organizzazione. Infine, stiamo architettando e implementando l'infrastruttura necessaria per consentire ulteriormente alla comunit\u00e0 di contribuire a Rocky Linux.","title":"Introduzione"},{"location":"rocky_linux/#rocky-linux","text":"","title":"Rocky Linux"},{"location":"rocky_linux/#cronologia","text":"Tutto \u00e8 iniziato con un commento sul blog. Post Originale Ripensando ai primi giorni di CentOS... Il mio cofondatore era Rocky McGaugh. Non \u00e8 pi\u00f9 con noi, cos\u00ec come un H/T a lui, che non ha mai potuto vedere il successo che CentOS \u00e8 diventato, vi presento... Rocky Linux. Gregory Kurtzer Co-fondatore di CentOS / Fondatore di Rocky Linux L'8 dicembre 2020, Red Hat ha annunciato che avrebbe interrotto lo sviluppo di CentOS, che \u00e8 stata una versione downstream pronta per la produzione di Red Hat Enterprise Linux, in favore di una variante di sviluppo upstream pi\u00f9 recente di quel sistema operativo noto come \"CentOS Stream\". In risposta, il fondatore originale di CentOS, Gregory Kurtzer, ha annunciato tramite un commento sul sito web di CentOS che avrebbe nuovamente iniziato un progetto per raggiungere gli obiettivi originali di CentOS. Il suo nome \u00e8 stato scelto come tributo al primo co-fondatore di CentOS, Rocky McGaugh. Entro il 12 dicembre, il repository del codice di Rocky Linux era diventato il repository pi\u00f9 in voga su GitHub. Il 22 dicembre 2020, Rocky Linux ha annunciato che l'obiettivo per un primo rilascio era ovunque tra marzo e maggio del 2021. Il 20 gennaio 2021, \u00e8 stato annunciato che un repository di test sarebbe stato reso disponibile al pubblico entro la fine di febbraio, e che una release candidate era prevista per la fine di marzo 2021. Tuttavia, quella data \u00e8 stata leggermente spostata indietro, e il 30 aprile 2021, la prima release candidate \u00e8 stata ufficialmente rilasciata. La seconda release candidate, della versione 8.4, l'ultima prima del rilascio stabile, \u00e8 stata rilasciata il 4 giugno 2021. Il 21 giugno 2021, la versione stabile di Rocky Linux 8.4 \u00e8 stata rilasciata, con il nome in codice \"Green Obsidian\". In primo luogo, abbiamo fatto dei passi per proteggere legalmente il nome Rocky Linux. Questo significa registrare i suoi marchi e varie propriet\u00e0 associate per proteggerli dal controllo di un'altra entit\u00e0. Abbiamo ottenuto questo risultato istituendoli sotto la Rocky Enterprise Software Foundation (RESF). Successivamente, abbiamo redatto uno statuto della comunit\u00e0 che definisce la struttura organizzativa, gli obiettivi, i valori e la missione dietro l'entit\u00e0 legale che rappresenta Rocky Linux. Critico in questo statuto \u00e8 l'istituzione di principi che permettono e proteggono la comunit\u00e0: trasparenza, coinvolgimento della comunit\u00e0, sviluppo aperto e indipendenza. Rocky Linux non sar\u00e0 mai controllata, acquistata o altrimenti influenzata da una singola entit\u00e0 o organizzazione. Infine, stiamo architettando e implementando l'infrastruttura necessaria per consentire ulteriormente alla comunit\u00e0 di contribuire a Rocky Linux.","title":"Cronologia"},{"location":"rocky_linux/Tutorial/increase_speed/","tags":["rocky","linux","sysadmin"],"text":"Aumentare la velocit\u00e0 di DNF su Rocky Linux 8 Gli utenti di Rocky Linux a volte possono notare che la velocit\u00e0 di download DNF pu\u00f2 essere lenta rispetto ad altre distribuzioni che utilizzano lo stesso gestore di pacchetti. Questo pu\u00f2 essere frustrante quando \u00e8 necessario scaricare e installare un grande numero di pacchetti (ad esempio un corposo aggiornamento di sistema). Con alcune piccole modifiche al file di configurazione si pu\u00f2 aumentare notevolmente la velocit\u00e0 di download. Nel seguente tutorial, vedremo come configurare e aumentare la velocit\u00e0 del vostro gestore di pacchetti DNF su Rocky Linux 8.x. Aggiornare il sistema operativo Aggiornate il vostro sistema operativo Rocky Linux per assicurarvi che tutti i pacchetti esistenti siano aggiornati: dnf upgrade --refresh Il tutorial presuppone che tutti i comandi siano eseguiti con l'utente amministrativo root nel caso questo non sia possibile e siano disponibili solo i permessi di sudo adattate i comandi di conseguenza. Configurare il gestore di pacchetti DNF Il primo passo \u00e8 quello di modificare il file di configurazione che si trova in /etc/dnf/dnf.conf . In questo esempio viene usato vim ma qualunque editor da riga di comando va altrettanto bene. vim /etc/dnf/dnf.conf Configurare i download paralleli La prima opzione per aumentare la velocit\u00e0 di DNF \u00e8 quella di aggiungere i download paralleli , con questa opzione abilitata si dovrebbero vedere gi\u00e0 i primi incrementi di velocit\u00e0. Aggiungere quanto segue in fondo al file di configurazione dnf.conf . max_parallel_downloads = 10 Quanto sopra dice al gestore di pacchetti DNF di scaricare 10 pacchetti in parallelo allo stesso tempo, 10 \u00e8 l'impostazione raccomandata, ma \u00e8 possibile aumentare questo valore, ma solo con parsimonia, ad esempio da 10 a 15, 15 a 20. Configurare il mirror pi\u00f9 veloce Il secondo miglioramento accanto ai download paralleli \u00e8 quello di abilitare la ricerca del mirror pi\u00f9 veloce . Aggiungete quanto segue sotto i download paralleli nel file di configurazione dnf.conf . fastestmirror = True Salvate il file. A questo punto \u00e8 arrivato il momento di eseguire un aggiornamento DNF, noterete nell'output che il gestore dei pacchetti DNF ora determina prima i mirror pi\u00f9 veloci. dnf upgrade --refresh determining the fastest mirror ( 65 hosts ) .. done .-- B/s | 0 B --:-- ETA Rocky Linux 8 - AppStream 862 B/s | 4 .8 kB 00 :05 Rocky Linux 8 - BaseOS 13 kB/s | 4 .3 kB 00 :00 Rocky Linux 8 - Extras 9 .3 kB/s | 3 .5 kB 00 :00 Rocky Linux 8 - PowerTools 14 kB/s | 4 .8 kB 00 :00 Rocky Linux 8 - Rasperry Pi 9 .7 kB/s | 3 .5 kB 00 :00 determining the fastest mirror ( 183 hosts ) .. done .- B/s | 0 B --:-- ETA Extra Packages for Enterprise Linux 8 - aarch64 2 .7 kB/s | 31 kB 00 :11 determining the fastest mirror ( 11 hosts ) .. done .-- B/s | 0 B --:-- ETA Extra Packages for Enterprise Linux Modular 8 - 28 kB/s | 32 kB 00 :01 Dipendenze risolte. Nessuna operazione da compiere. Fatto! A seconda del numero di download paralleli, questo potrebbe richiedere qualche istante per controllare e determinare il pi\u00f9 veloce, ma a lungo termine, la velocit\u00e0 di DNF dovrebbe risultare molto pi\u00f9 performante.","title":"Velocizzare DNF"},{"location":"rocky_linux/Tutorial/increase_speed/#aumentare-la-velocita-di-dnf-su-rocky-linux-8","text":"Gli utenti di Rocky Linux a volte possono notare che la velocit\u00e0 di download DNF pu\u00f2 essere lenta rispetto ad altre distribuzioni che utilizzano lo stesso gestore di pacchetti. Questo pu\u00f2 essere frustrante quando \u00e8 necessario scaricare e installare un grande numero di pacchetti (ad esempio un corposo aggiornamento di sistema). Con alcune piccole modifiche al file di configurazione si pu\u00f2 aumentare notevolmente la velocit\u00e0 di download. Nel seguente tutorial, vedremo come configurare e aumentare la velocit\u00e0 del vostro gestore di pacchetti DNF su Rocky Linux 8.x.","title":"Aumentare la velocit\u00e0 di DNF su Rocky Linux 8"},{"location":"rocky_linux/Tutorial/increase_speed/#aggiornare-il-sistema-operativo","text":"Aggiornate il vostro sistema operativo Rocky Linux per assicurarvi che tutti i pacchetti esistenti siano aggiornati: dnf upgrade --refresh Il tutorial presuppone che tutti i comandi siano eseguiti con l'utente amministrativo root nel caso questo non sia possibile e siano disponibili solo i permessi di sudo adattate i comandi di conseguenza.","title":"Aggiornare il sistema operativo"},{"location":"rocky_linux/Tutorial/increase_speed/#configurare-il-gestore-di-pacchetti-dnf","text":"Il primo passo \u00e8 quello di modificare il file di configurazione che si trova in /etc/dnf/dnf.conf . In questo esempio viene usato vim ma qualunque editor da riga di comando va altrettanto bene. vim /etc/dnf/dnf.conf","title":"Configurare il gestore di pacchetti DNF"},{"location":"rocky_linux/Tutorial/increase_speed/#configurare-i-download-paralleli","text":"La prima opzione per aumentare la velocit\u00e0 di DNF \u00e8 quella di aggiungere i download paralleli , con questa opzione abilitata si dovrebbero vedere gi\u00e0 i primi incrementi di velocit\u00e0. Aggiungere quanto segue in fondo al file di configurazione dnf.conf . max_parallel_downloads = 10 Quanto sopra dice al gestore di pacchetti DNF di scaricare 10 pacchetti in parallelo allo stesso tempo, 10 \u00e8 l'impostazione raccomandata, ma \u00e8 possibile aumentare questo valore, ma solo con parsimonia, ad esempio da 10 a 15, 15 a 20.","title":"Configurare i download paralleli"},{"location":"rocky_linux/Tutorial/increase_speed/#configurare-il-mirror-piu-veloce","text":"Il secondo miglioramento accanto ai download paralleli \u00e8 quello di abilitare la ricerca del mirror pi\u00f9 veloce . Aggiungete quanto segue sotto i download paralleli nel file di configurazione dnf.conf . fastestmirror = True Salvate il file. A questo punto \u00e8 arrivato il momento di eseguire un aggiornamento DNF, noterete nell'output che il gestore dei pacchetti DNF ora determina prima i mirror pi\u00f9 veloci. dnf upgrade --refresh determining the fastest mirror ( 65 hosts ) .. done .-- B/s | 0 B --:-- ETA Rocky Linux 8 - AppStream 862 B/s | 4 .8 kB 00 :05 Rocky Linux 8 - BaseOS 13 kB/s | 4 .3 kB 00 :00 Rocky Linux 8 - Extras 9 .3 kB/s | 3 .5 kB 00 :00 Rocky Linux 8 - PowerTools 14 kB/s | 4 .8 kB 00 :00 Rocky Linux 8 - Rasperry Pi 9 .7 kB/s | 3 .5 kB 00 :00 determining the fastest mirror ( 183 hosts ) .. done .- B/s | 0 B --:-- ETA Extra Packages for Enterprise Linux 8 - aarch64 2 .7 kB/s | 31 kB 00 :11 determining the fastest mirror ( 11 hosts ) .. done .-- B/s | 0 B --:-- ETA Extra Packages for Enterprise Linux Modular 8 - 28 kB/s | 32 kB 00 :01 Dipendenze risolte. Nessuna operazione da compiere. Fatto! A seconda del numero di download paralleli, questo potrebbe richiedere qualche istante per controllare e determinare il pi\u00f9 veloce, ma a lungo termine, la velocit\u00e0 di DNF dovrebbe risultare molto pi\u00f9 performante.","title":"Configurare il mirror pi\u00f9 veloce"},{"location":"rocky_linux/Tutorial/log/","tags":["sysadmin","system"],"text":"Come trovare e interpretare i file di log del sistema su Rocky Linux I file di registro (logs) e i diari (journals) sono importanti per il lavoro di un amministratore di sistema. Rivelano una grande quantit\u00e0 di informazioni su un sistema e sono fondamentali per la risoluzione dei problemi e la verifica. Il sistema di log di Red Hat Enterprise Linux si basa sul protocollo syslog integrato. Particolari programmi utilizzano questo sistema per registrare gli eventi e organizzarli in file di log, utili per la verifica del sistema operativo e la risoluzione di vari problemi. Risoluzione dei problemi utilizzando i file di log I file di registro contengono messaggi sul sistema, compreso il kernel, i servizi e le applicazioni in esecuzione. Contengono informazioni che aiutano a risolvere i problemi o a monitorare le funzioni del sistema. Utilizzare rsyslog Syslog e rsyslog sono stati a lungo utilizzati per fornire il logging sui server Linux. Con l'arrivo di Systemd come gestore di servizi predefinito (da RHEL 7) \u00e8 stato introdotto un sistema di log chiamato systemd-journald. Systemd-journald continua a essere il meccanismo di log su RHEL 8 e 9 e derivate, pur mantenendo rsyslog per la compatibilit\u00e0 con il passato. Il servizio rsyslog conserva diversi file di log nella directory /var/log. \u00c8 possibile aprire questi file utilizzando comandi nativi come tail, head, more, less, cat e cos\u00ec via, a seconda di ci\u00f2 che si sta cercando. Ad esempio, per visualizzare i messaggi di avvio e altri messaggi del kernel, visualizzare /var/log/messages : cat /var/log/messages Usate grep e altri strumenti di filtraggio per raccogliere eventi pi\u00f9 specifici da un file. \u00c8 anche possibile utilizzare tail per visualizzare i file man mano che vengono aggiornati: tail -f /var/log/messages May 19 21 :53:27 rockyserver systemd [ 6893 ] : Reached target Shutdown. May 19 21 :53:27 rockyserver systemd [ 6893 ] : Started Exit the Session. May 19 21 :53:27 rockyserver systemd [ 6893 ] : Reached target Exit the Session. May 19 21 :53:27 rockyserver systemd [ 1 ] : user@992.service: Succeeded. May 19 21 :53:27 rockyserver systemd [ 1 ] : Stopped User Manager for UID 992 . May 19 21 :53:27 rockyserver systemd [ 1 ] : Stopping User runtime directory /run/user/992... May 19 21 :53:27 rockyserver systemd [ 1 ] : run-user-992.mount: Succeeded. May 19 21 :53:27 rockyserver systemd [ 1 ] : user-runtime-dir@992.service: Succeeded. May 19 21 :53:27 rockyserver systemd [ 1 ] : Stopped User runtime directory /run/user/992. May 19 21 :53:27 rockyserver systemd [ 1 ] : Removed slice User Slice of UID 992 . Nel comando precedente, l'opzione -f aggiorna l'output quando vengono aggiunte nuove voci al file di log. Controllare il file /var/log/secure per visualizzare gli utenti e le loro attivit\u00e0: tail -f /var/log/secure May 19 21 :53:17 rockyserver sshd [ 6904 ] : Received disconnect from 109 .234.59.205 port 51406 :11: disconnected by user May 19 21 :53:17 rockyserver sshd [ 6904 ] : Disconnected from user git 109 .234.59.205 port 51406 May 19 21 :53:17 rockyserver sshd [ 6888 ] : pam_unix ( sshd:session ) : session closed for user git May 19 21 :53:27 rockyserver systemd [ 6897 ] : pam_unix ( systemd-user:session ) : session closed for user git May 19 21 :56:17 rockyserver sshd [ 6935 ] : Accepted publickey for git from 109 .234.59.205 port 51408 ssh2: ED25519 SHA256:YIR6tn4HxXoZ14XOTh4sdXGL6H8krJPFzGvQo1ujDmM May 19 21 :56:18 rockyserver systemd [ 6940 ] : pam_unix ( systemd-user:session ) : session opened for user git by ( uid = 0 ) May 19 21 :56:18 rockyserver sshd [ 6935 ] : pam_unix ( sshd:session ) : session opened for user git by ( uid = 0 ) May 19 21 :56:18 rockyserver sshd [ 6949 ] : Received disconnect from 109 .234.59.205 port 51408 :11: disconnected by user May 19 21 :56:18 rockyserver sshd [ 6949 ] : Disconnected from user git 109 .234.59.205 port 51408 May 19 21 :56:18 rockyserver sshd [ 6935 ] : pam_unix ( sshd:session ) : session closed for user git Utilizzare systemd-journald Il servizio systemd-journald non conserva file separati, come fa rsyslog. L'idea \u00e8 quella di evitare di controllare i problemi in file diversi. Systemd-journald salva gli eventi e i messaggi in un formato binario che non pu\u00f2 essere letto con un editor di testo. \u00c8 possibile interrogare il journal con il comando journalctl. Per visualizzare tutti i messaggi degli eventi, utilizzare: journalctl \u00c8 simile a /var/log/messages del servizio rsyslog. Per visualizzare gli ultimi 10 messaggi di eventi, utilizzare: journalctl -n -- Logs begin at Fri 2018 -06-22 13 :11:50 CEST, end at Thu 2022 -05-19 22 :03:34 CEST. -- mag 19 22 :03:24 rockyserver systemd [ 7048 ] : pam_unix ( systemd-user:session ) : session closed for user git mag 19 22 :03:24 rockyserver systemd [ 1 ] : user@992.service: Succeeded. mag 19 22 :03:24 rockyserver systemd [ 1 ] : Stopped User Manager for UID 992 . mag 19 22 :03:24 rockyserver systemd [ 1 ] : Stopping User runtime directory /run/user/992... mag 19 22 :03:24 rockyserver systemd [ 1 ] : run-user-992.mount: Succeeded. mag 19 22 :03:24 rockyserver systemd [ 1 ] : user-runtime-dir@992.service: Succeeded. mag 19 22 :03:24 rockyserver systemd [ 1 ] : Stopped User runtime directory /run/user/992. mag 19 22 :03:24 rockyserver systemd [ 1 ] : Removed slice User Slice of UID 992 . mag 19 22 :03:34 rockyserver sshd [ 7082 ] : Received disconnect from 61 .177.173.53 port 62507 :11: [ preauth ] mag 19 22 :03:34 rockyserver sshd [ 7082 ] : Disconnected from authenticating user root 61 .177.173.53 port 62507 [ preauth ] \u00c8 possibile visualizzare le ultime n voci utilizzando journalctl -n {numero} . Ad esempio, per visualizzare le ultime 20 voci, digitare: journalctl -n 20 Per visualizzare le nuove voci del diario man mano che vengono scritte nel diario, utilizzare: journalctl -f Eseguire il seguente comando per visualizzare il registro dei messaggi del kernel dall'ultimo avvio: journalctl -k -- Logs begin at Fri 2018 -06-22 13 :11:50 CEST, end at Thu 2022 -05-19 22 :10:09 CEST. -- giu 22 13 :11:50 rockyserver kernel: Booting Linux on physical CPU 0x0000000000 [ 0x410fd083 ] giu 22 13 :11:50 rockyserver kernel: Linux version 5 .15.34-v8.1.el8 ( mockbuild@ord1-prod-a64build003.svc.aws.rockylinux.org ) ( gcc ( GCC ) > giu 22 13 :11:50 rockyserver kernel: random: fast init done giu 22 13 :11:50 rockyserver kernel: Machine model: Raspberry Pi 4 Model B Rev 1 .2 giu 22 13 :11:50 rockyserver kernel: efi: UEFI not found. giu 22 13 :11:50 rockyserver kernel: Reserved memory: created CMA memory pool at 0x000000002ac00000, size 64 MiB giu 22 13 :11:50 rockyserver kernel: OF: reserved mem: initialized node linux,cma, compatible id shared-dma-pool giu 22 13 :11:50 rockyserver kernel: Zone ranges: giu 22 13 :11:50 rockyserver kernel: DMA [ mem 0x0000000000000000-0x000000003fffffff ] giu 22 13 :11:50 rockyserver kernel: DMA32 [ mem 0x0000000040000000-0x00000000fbffffff ] giu 22 13 :11:50 rockyserver kernel: Normal empty giu 22 13 :11:50 rockyserver kernel: Movable zone start for each node giu 22 13 :11:50 rockyserver kernel: Early memory node ranges giu 22 13 :11:50 rockyserver kernel: node 0 : [ mem 0x0000000000000000-0x000000003b2fffff ] giu 22 13 :11:50 rockyserver kernel: node 0 : [ mem 0x0000000040000000-0x00000000fbffffff ] giu 22 13 :11:50 rockyserver kernel: Initmem setup node 0 [ mem 0x0000000000000000-0x00000000fbffffff ] giu 22 13 :11:50 rockyserver kernel: On node 0 , zone DMA32: 256 pages in unavailable ranges giu 22 13 :11:50 rockyserver kernel: percpu: Embedded 28 pages/cpu s77144 r8192 d29352 u114688 giu 22 13 :11:50 rockyserver kernel: pcpu-alloc: s77144 r8192 d29352 u114688 alloc = 28 *4096 giu 22 13 :11:50 rockyserver kernel: pcpu-alloc: [ 0 ] 0 [ 0 ] 1 [ 0 ] 2 [ 0 ] 3 giu 22 13 :11:50 rockyserver kernel: Detected PIPT I-cache on CPU0 giu 22 13 :11:50 rockyserver kernel: CPU features: detected: Spectre-v2 Il comando journalctl ha diverse opzioni che possono facilitare l'interrogazione del journal. \u00c8 possibile interrogare il registro in base alle applicazioni, all'intervallo di tempo, alle unit\u00e0 systemd, alla priorit\u00e0 e a molte altre opzioni. Eseguire il comando journalctl -help per elencare le opzioni disponibili. Per visualizzare le voci del diario in base alla loro priorit\u00e0 critica, utilizzare: journalctl -p crit Per interrogare tutti i messaggi relativi a un particolare utente, trovare l'ID dell'utente (UID) e usarlo per eseguire la ricerca. Ad esempio, per controllare tutti i log relativi all'utente sadmin, eseguire: id git uid = 992 ( git ) gid = 989 ( git ) gruppi = 989 ( git ) journalctl _UID = 992 -- Logs begin at Fri 2018 -06-22 13 :11:50 CEST, end at Thu 2022 -05-19 22 :12:53 CEST. -- mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Paths. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Timers. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Starting D-Bus User Message Bus Socket. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Listening on D-Bus User Message Bus Socket. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Sockets. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Basic System. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Default. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Startup finished in 132ms. mag 18 11 :51:25 rockyserver sshd [ 1168 ] : Received disconnect from 79 .98.46.20 port 33790 :11: disconnected by user mag 18 11 :51:25 rockyserver sshd [ 1168 ] : Disconnected from user git 79 .98.46.20 port 33790 mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Default. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Basic System. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Sockets. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Closed D-Bus User Message Bus Socket. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Paths. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Reached target Shutdown. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Started Exit the Session. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Reached target Exit the Session. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Timers. mag 18 11 :51:35 rockyserver systemd [ 1160 ] : pam_unix ( systemd-user:session ) : session closed for user git mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Paths. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Timers. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Starting D-Bus User Message Bus Socket. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Listening on D-Bus User Message Bus Socket. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Sockets. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Basic System. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Default. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Startup finished in 118ms. mag 18 11 :51:45 rockyserver sshd [ 1212 ] : Received disconnect from 79 .98.46.20 port 33792 :11: disconnected by user Per visualizzare le voci del diario di oggi, utilizzare: journalctl --since today Per visualizzare le voci del diario relative al demone sshd, eseguire: journalctl -u sshd Lo stesso vale per altri servizi in esecuzione sotto systemd che possono essere fermati e avviati con systemctl. Per controllare i messaggi relativi al servizio httpd nell'ultima ora, si pu\u00f2 eseguire: journalctl -u httpd -since \"1 ora fa\" . Gestire l'inoltro dei log I server RHEL 8 e 9 utilizzano sia rsyslog che systemd-journald, che si completano a vicenda per eseguire il log. Systemd-journald non ha un meccanismo per inoltrare i log a sistemi esterni e applicazioni di monitoraggio. Una configurazione modifica questo aspetto in /etc/systemd/journald.conf. Il parametro ForwardToSyslog definisce se le voci del journal devono essere inoltrate a syslog. Quando \u00e8 abilitato, syslog cattura le voci che passano attraverso systemd-journald e le inoltra di conseguenza.","title":"Interpretare i logs"},{"location":"rocky_linux/Tutorial/log/#come-trovare-e-interpretare-i-file-di-log-del-sistema-su-rocky-linux","text":"I file di registro (logs) e i diari (journals) sono importanti per il lavoro di un amministratore di sistema. Rivelano una grande quantit\u00e0 di informazioni su un sistema e sono fondamentali per la risoluzione dei problemi e la verifica. Il sistema di log di Red Hat Enterprise Linux si basa sul protocollo syslog integrato. Particolari programmi utilizzano questo sistema per registrare gli eventi e organizzarli in file di log, utili per la verifica del sistema operativo e la risoluzione di vari problemi. Risoluzione dei problemi utilizzando i file di log I file di registro contengono messaggi sul sistema, compreso il kernel, i servizi e le applicazioni in esecuzione. Contengono informazioni che aiutano a risolvere i problemi o a monitorare le funzioni del sistema.","title":"Come trovare e interpretare i file di log del sistema su Rocky Linux"},{"location":"rocky_linux/Tutorial/log/#utilizzare-rsyslog","text":"Syslog e rsyslog sono stati a lungo utilizzati per fornire il logging sui server Linux. Con l'arrivo di Systemd come gestore di servizi predefinito (da RHEL 7) \u00e8 stato introdotto un sistema di log chiamato systemd-journald. Systemd-journald continua a essere il meccanismo di log su RHEL 8 e 9 e derivate, pur mantenendo rsyslog per la compatibilit\u00e0 con il passato. Il servizio rsyslog conserva diversi file di log nella directory /var/log. \u00c8 possibile aprire questi file utilizzando comandi nativi come tail, head, more, less, cat e cos\u00ec via, a seconda di ci\u00f2 che si sta cercando. Ad esempio, per visualizzare i messaggi di avvio e altri messaggi del kernel, visualizzare /var/log/messages : cat /var/log/messages Usate grep e altri strumenti di filtraggio per raccogliere eventi pi\u00f9 specifici da un file. \u00c8 anche possibile utilizzare tail per visualizzare i file man mano che vengono aggiornati: tail -f /var/log/messages May 19 21 :53:27 rockyserver systemd [ 6893 ] : Reached target Shutdown. May 19 21 :53:27 rockyserver systemd [ 6893 ] : Started Exit the Session. May 19 21 :53:27 rockyserver systemd [ 6893 ] : Reached target Exit the Session. May 19 21 :53:27 rockyserver systemd [ 1 ] : user@992.service: Succeeded. May 19 21 :53:27 rockyserver systemd [ 1 ] : Stopped User Manager for UID 992 . May 19 21 :53:27 rockyserver systemd [ 1 ] : Stopping User runtime directory /run/user/992... May 19 21 :53:27 rockyserver systemd [ 1 ] : run-user-992.mount: Succeeded. May 19 21 :53:27 rockyserver systemd [ 1 ] : user-runtime-dir@992.service: Succeeded. May 19 21 :53:27 rockyserver systemd [ 1 ] : Stopped User runtime directory /run/user/992. May 19 21 :53:27 rockyserver systemd [ 1 ] : Removed slice User Slice of UID 992 . Nel comando precedente, l'opzione -f aggiorna l'output quando vengono aggiunte nuove voci al file di log. Controllare il file /var/log/secure per visualizzare gli utenti e le loro attivit\u00e0: tail -f /var/log/secure May 19 21 :53:17 rockyserver sshd [ 6904 ] : Received disconnect from 109 .234.59.205 port 51406 :11: disconnected by user May 19 21 :53:17 rockyserver sshd [ 6904 ] : Disconnected from user git 109 .234.59.205 port 51406 May 19 21 :53:17 rockyserver sshd [ 6888 ] : pam_unix ( sshd:session ) : session closed for user git May 19 21 :53:27 rockyserver systemd [ 6897 ] : pam_unix ( systemd-user:session ) : session closed for user git May 19 21 :56:17 rockyserver sshd [ 6935 ] : Accepted publickey for git from 109 .234.59.205 port 51408 ssh2: ED25519 SHA256:YIR6tn4HxXoZ14XOTh4sdXGL6H8krJPFzGvQo1ujDmM May 19 21 :56:18 rockyserver systemd [ 6940 ] : pam_unix ( systemd-user:session ) : session opened for user git by ( uid = 0 ) May 19 21 :56:18 rockyserver sshd [ 6935 ] : pam_unix ( sshd:session ) : session opened for user git by ( uid = 0 ) May 19 21 :56:18 rockyserver sshd [ 6949 ] : Received disconnect from 109 .234.59.205 port 51408 :11: disconnected by user May 19 21 :56:18 rockyserver sshd [ 6949 ] : Disconnected from user git 109 .234.59.205 port 51408 May 19 21 :56:18 rockyserver sshd [ 6935 ] : pam_unix ( sshd:session ) : session closed for user git","title":"Utilizzare rsyslog"},{"location":"rocky_linux/Tutorial/log/#utilizzare-systemd-journald","text":"Il servizio systemd-journald non conserva file separati, come fa rsyslog. L'idea \u00e8 quella di evitare di controllare i problemi in file diversi. Systemd-journald salva gli eventi e i messaggi in un formato binario che non pu\u00f2 essere letto con un editor di testo. \u00c8 possibile interrogare il journal con il comando journalctl. Per visualizzare tutti i messaggi degli eventi, utilizzare: journalctl \u00c8 simile a /var/log/messages del servizio rsyslog. Per visualizzare gli ultimi 10 messaggi di eventi, utilizzare: journalctl -n -- Logs begin at Fri 2018 -06-22 13 :11:50 CEST, end at Thu 2022 -05-19 22 :03:34 CEST. -- mag 19 22 :03:24 rockyserver systemd [ 7048 ] : pam_unix ( systemd-user:session ) : session closed for user git mag 19 22 :03:24 rockyserver systemd [ 1 ] : user@992.service: Succeeded. mag 19 22 :03:24 rockyserver systemd [ 1 ] : Stopped User Manager for UID 992 . mag 19 22 :03:24 rockyserver systemd [ 1 ] : Stopping User runtime directory /run/user/992... mag 19 22 :03:24 rockyserver systemd [ 1 ] : run-user-992.mount: Succeeded. mag 19 22 :03:24 rockyserver systemd [ 1 ] : user-runtime-dir@992.service: Succeeded. mag 19 22 :03:24 rockyserver systemd [ 1 ] : Stopped User runtime directory /run/user/992. mag 19 22 :03:24 rockyserver systemd [ 1 ] : Removed slice User Slice of UID 992 . mag 19 22 :03:34 rockyserver sshd [ 7082 ] : Received disconnect from 61 .177.173.53 port 62507 :11: [ preauth ] mag 19 22 :03:34 rockyserver sshd [ 7082 ] : Disconnected from authenticating user root 61 .177.173.53 port 62507 [ preauth ] \u00c8 possibile visualizzare le ultime n voci utilizzando journalctl -n {numero} . Ad esempio, per visualizzare le ultime 20 voci, digitare: journalctl -n 20 Per visualizzare le nuove voci del diario man mano che vengono scritte nel diario, utilizzare: journalctl -f Eseguire il seguente comando per visualizzare il registro dei messaggi del kernel dall'ultimo avvio: journalctl -k -- Logs begin at Fri 2018 -06-22 13 :11:50 CEST, end at Thu 2022 -05-19 22 :10:09 CEST. -- giu 22 13 :11:50 rockyserver kernel: Booting Linux on physical CPU 0x0000000000 [ 0x410fd083 ] giu 22 13 :11:50 rockyserver kernel: Linux version 5 .15.34-v8.1.el8 ( mockbuild@ord1-prod-a64build003.svc.aws.rockylinux.org ) ( gcc ( GCC ) > giu 22 13 :11:50 rockyserver kernel: random: fast init done giu 22 13 :11:50 rockyserver kernel: Machine model: Raspberry Pi 4 Model B Rev 1 .2 giu 22 13 :11:50 rockyserver kernel: efi: UEFI not found. giu 22 13 :11:50 rockyserver kernel: Reserved memory: created CMA memory pool at 0x000000002ac00000, size 64 MiB giu 22 13 :11:50 rockyserver kernel: OF: reserved mem: initialized node linux,cma, compatible id shared-dma-pool giu 22 13 :11:50 rockyserver kernel: Zone ranges: giu 22 13 :11:50 rockyserver kernel: DMA [ mem 0x0000000000000000-0x000000003fffffff ] giu 22 13 :11:50 rockyserver kernel: DMA32 [ mem 0x0000000040000000-0x00000000fbffffff ] giu 22 13 :11:50 rockyserver kernel: Normal empty giu 22 13 :11:50 rockyserver kernel: Movable zone start for each node giu 22 13 :11:50 rockyserver kernel: Early memory node ranges giu 22 13 :11:50 rockyserver kernel: node 0 : [ mem 0x0000000000000000-0x000000003b2fffff ] giu 22 13 :11:50 rockyserver kernel: node 0 : [ mem 0x0000000040000000-0x00000000fbffffff ] giu 22 13 :11:50 rockyserver kernel: Initmem setup node 0 [ mem 0x0000000000000000-0x00000000fbffffff ] giu 22 13 :11:50 rockyserver kernel: On node 0 , zone DMA32: 256 pages in unavailable ranges giu 22 13 :11:50 rockyserver kernel: percpu: Embedded 28 pages/cpu s77144 r8192 d29352 u114688 giu 22 13 :11:50 rockyserver kernel: pcpu-alloc: s77144 r8192 d29352 u114688 alloc = 28 *4096 giu 22 13 :11:50 rockyserver kernel: pcpu-alloc: [ 0 ] 0 [ 0 ] 1 [ 0 ] 2 [ 0 ] 3 giu 22 13 :11:50 rockyserver kernel: Detected PIPT I-cache on CPU0 giu 22 13 :11:50 rockyserver kernel: CPU features: detected: Spectre-v2 Il comando journalctl ha diverse opzioni che possono facilitare l'interrogazione del journal. \u00c8 possibile interrogare il registro in base alle applicazioni, all'intervallo di tempo, alle unit\u00e0 systemd, alla priorit\u00e0 e a molte altre opzioni. Eseguire il comando journalctl -help per elencare le opzioni disponibili. Per visualizzare le voci del diario in base alla loro priorit\u00e0 critica, utilizzare: journalctl -p crit Per interrogare tutti i messaggi relativi a un particolare utente, trovare l'ID dell'utente (UID) e usarlo per eseguire la ricerca. Ad esempio, per controllare tutti i log relativi all'utente sadmin, eseguire: id git uid = 992 ( git ) gid = 989 ( git ) gruppi = 989 ( git ) journalctl _UID = 992 -- Logs begin at Fri 2018 -06-22 13 :11:50 CEST, end at Thu 2022 -05-19 22 :12:53 CEST. -- mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Paths. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Timers. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Starting D-Bus User Message Bus Socket. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Listening on D-Bus User Message Bus Socket. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Sockets. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Basic System. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Reached target Default. mag 18 11 :51:25 rockyserver systemd [ 1158 ] : Startup finished in 132ms. mag 18 11 :51:25 rockyserver sshd [ 1168 ] : Received disconnect from 79 .98.46.20 port 33790 :11: disconnected by user mag 18 11 :51:25 rockyserver sshd [ 1168 ] : Disconnected from user git 79 .98.46.20 port 33790 mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Default. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Basic System. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Sockets. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Closed D-Bus User Message Bus Socket. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Paths. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Reached target Shutdown. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Started Exit the Session. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Reached target Exit the Session. mag 18 11 :51:35 rockyserver systemd [ 1158 ] : Stopped target Timers. mag 18 11 :51:35 rockyserver systemd [ 1160 ] : pam_unix ( systemd-user:session ) : session closed for user git mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Paths. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Timers. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Starting D-Bus User Message Bus Socket. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Listening on D-Bus User Message Bus Socket. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Sockets. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Basic System. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Reached target Default. mag 18 11 :51:45 rockyserver systemd [ 1203 ] : Startup finished in 118ms. mag 18 11 :51:45 rockyserver sshd [ 1212 ] : Received disconnect from 79 .98.46.20 port 33792 :11: disconnected by user Per visualizzare le voci del diario di oggi, utilizzare: journalctl --since today Per visualizzare le voci del diario relative al demone sshd, eseguire: journalctl -u sshd Lo stesso vale per altri servizi in esecuzione sotto systemd che possono essere fermati e avviati con systemctl. Per controllare i messaggi relativi al servizio httpd nell'ultima ora, si pu\u00f2 eseguire: journalctl -u httpd -since \"1 ora fa\" .","title":"Utilizzare systemd-journald"},{"location":"rocky_linux/Tutorial/log/#gestire-linoltro-dei-log","text":"I server RHEL 8 e 9 utilizzano sia rsyslog che systemd-journald, che si completano a vicenda per eseguire il log. Systemd-journald non ha un meccanismo per inoltrare i log a sistemi esterni e applicazioni di monitoraggio. Una configurazione modifica questo aspetto in /etc/systemd/journald.conf. Il parametro ForwardToSyslog definisce se le voci del journal devono essere inoltrate a syslog. Quando \u00e8 abilitato, syslog cattura le voci che passano attraverso systemd-journald e le inoltra di conseguenza.","title":"Gestire l'inoltro dei log"},{"location":"rocky_linux/Tutorial/power_tools/","tags":["rockylinux","dnf"],"text":"Abilitare il repository dei PowerTools Il repository PowerTools \u00e8 un contenitore che contiene molti pacchetti, librerie e strumenti per sviluppatori per creare da sorgente o installare applicazioni. La maggior parte dei repository si basano sui PowerTools per essere abilitati, inclusi i pi\u00f9 popolari pacchetti Extra per il repository Enterprise Linux. Installare le dipendenze necessarie Sono necessarie le seguenti dipendenze per abilitare il repository dei PowerTools. Questo dovrebbe essere gi\u00e0 installato di default, ma \u00e8 meglio eseguire il comando per controllare. dnf install dnf-plugins-core Per poter abilitare il repository PowerTools, \u00e8 necessario installare il repository EPEL, che \u00e8 l'abbreviazione di Extra Packages for Enterprise Linux . Nel tuo terminale, esegui il seguente comando. dnf install epel-release Per impostazione predefinita, EPEL dovrebbe essere abilitato, ma se necessario potete utilizzare il seguente comando per abilitarlo manualmente. dnf config-manager --enable epel Abilitare il repository Per abilitare il repository si utilizza il seguente comando: sudo dnf config-manager --set-enabled powertools Per confermare che il repository PowerTools sia stato abilitato, usate il comando dnf repolist . dnf repolist | grep powertools powertools Rocky Linux 8 - PowerTools Utilizzando il seguente comando, \u00e8 possibile visualizzare quali altre opzioni sono disponibili con PowerTools ma attualmente disabilitate. dnf repolist disabled | grep -i power powertools-debug Rocky Linux 8 - PowerTools - Source powertools-source Rocky Linux 8 - PowerTools - Source Come si ricava da sopra debug e source sono disabilitati in quanto non sono necessari nell'installazione di pacchetti precompilati, sar\u00e0 sufficiente il repository standard di PowerTools. Tuttavia, se hai bisogno di abilitarli, usa il seguente comando. Per abilitare il debug di PowerTools: dnf config-manager --set-enabled powertools-debug Per abilitare il source di PowerTools: dnf config-manager --set-enabled powertools-source Potete verificare che i nuovi repository PowerTools siano stati abilitati con il seguente comando. dnf repolist | grep powertools Conclusione Powertools \u00e8 un repository che dovrebbe essere abilitato di default insieme ad EPEL, poich\u00e9 contiene molti pacchetti utili e ampiamente utilizzati dalla comunit\u00e0.","title":"Power Tools"},{"location":"rocky_linux/Tutorial/power_tools/#abilitare-il-repository-dei-powertools","text":"Il repository PowerTools \u00e8 un contenitore che contiene molti pacchetti, librerie e strumenti per sviluppatori per creare da sorgente o installare applicazioni. La maggior parte dei repository si basano sui PowerTools per essere abilitati, inclusi i pi\u00f9 popolari pacchetti Extra per il repository Enterprise Linux.","title":"Abilitare il repository dei PowerTools"},{"location":"rocky_linux/Tutorial/power_tools/#installare-le-dipendenze-necessarie","text":"Sono necessarie le seguenti dipendenze per abilitare il repository dei PowerTools. Questo dovrebbe essere gi\u00e0 installato di default, ma \u00e8 meglio eseguire il comando per controllare. dnf install dnf-plugins-core Per poter abilitare il repository PowerTools, \u00e8 necessario installare il repository EPEL, che \u00e8 l'abbreviazione di Extra Packages for Enterprise Linux . Nel tuo terminale, esegui il seguente comando. dnf install epel-release Per impostazione predefinita, EPEL dovrebbe essere abilitato, ma se necessario potete utilizzare il seguente comando per abilitarlo manualmente. dnf config-manager --enable epel","title":"Installare le dipendenze necessarie"},{"location":"rocky_linux/Tutorial/power_tools/#abilitare-il-repository","text":"Per abilitare il repository si utilizza il seguente comando: sudo dnf config-manager --set-enabled powertools Per confermare che il repository PowerTools sia stato abilitato, usate il comando dnf repolist . dnf repolist | grep powertools powertools Rocky Linux 8 - PowerTools Utilizzando il seguente comando, \u00e8 possibile visualizzare quali altre opzioni sono disponibili con PowerTools ma attualmente disabilitate. dnf repolist disabled | grep -i power powertools-debug Rocky Linux 8 - PowerTools - Source powertools-source Rocky Linux 8 - PowerTools - Source Come si ricava da sopra debug e source sono disabilitati in quanto non sono necessari nell'installazione di pacchetti precompilati, sar\u00e0 sufficiente il repository standard di PowerTools. Tuttavia, se hai bisogno di abilitarli, usa il seguente comando. Per abilitare il debug di PowerTools: dnf config-manager --set-enabled powertools-debug Per abilitare il source di PowerTools: dnf config-manager --set-enabled powertools-source Potete verificare che i nuovi repository PowerTools siano stati abilitati con il seguente comando. dnf repolist | grep powertools","title":"Abilitare il repository"},{"location":"rocky_linux/Tutorial/power_tools/#conclusione","text":"Powertools \u00e8 un repository che dovrebbe essere abilitato di default insieme ad EPEL, poich\u00e9 contiene molti pacchetti utili e ampiamente utilizzati dalla comunit\u00e0.","title":"Conclusione"},{"location":"sysadmin/inxi/","tags":["sysadmin","filesystem","linux","freebsd"],"text":"Scopri di pi\u00f9 sul tuo sistema Linux Raccogli una variet\u00e0 di informazioni di sistema e non con un singolo comando Inxi La raccolta di informazioni sui sistemi GNU/Linux \u00e8 un'attivit\u00e0 essenziale dell'amministratore di sistema. Ci sono molti strumenti che possono aiutare in questo senso. Tuttavia, un comando che pu\u00f2 raccogliere molte informazioni con solo poche opzioni e parametri \u00e8 Inxi . Inxi \u00e8 un'utilit\u00e0 CLI (command line interface) completa che mostra tutti i tipi di informazioni di sistema nella tua console/terminale/shell o nel tuo client IRC. Raccoglie queste informazioni da una variet\u00e0 di fonti sul tuo sistema, cos\u00ec puoi vedere quello che vuoi in un formato facile da usare. Installazione di Inxi I sistemi Red Hat Enterprise Linux (RHEL) non hanno inxi installato per impostazione predefinita. \u00c8 disponibile tramite il repository epel-release . Per installare inxi , esegui i seguenti comandi sul tuo sistema Su RHEL 8, e Rocky Linux 8 usa il seguente comando per installare il repository epel dnf install -y epel-release e il comando: dnf install -y inxi Su RHEL 7, installa inxi usando il comando yum: yum install -y epel-release yum install -y inxi Di seguito una sinossi di tutte le opzioni del comando inxi : inxi [-AbBCdDEfFGhiIjJlLmMnNopPrRsSuUVwzZ] quando inxi viene eseguito senza alcuna opzione, visualizza una riga di dati di sistema e la versione di inxi inxi CPU: Quad Core Model N/A ( -MCP- ) speed/min/max: 600 /600/1500 MHz Kernel: 5 .12.11-300.fc34.aarch64 aarch64 Up: 2h 18m Mem: 322 .7/3817.0 MiB ( 8 .5% ) Storage: 119 GiB ( 3 .7% used ) Procs: 165 Shell: Bash inxi: 3 .3.03 Ecco un esempio di output da una Raspberry pi 4 Headless con Fedora Server: inxi -b System: Host: unixlike.ddns.net Kernel: 5 .12.11-300.fc34.aarch64 aarch64 bits: 64 Console: tty pts/0 Distro: Fedora release 34 ( Thirty Four ) Machine: Type: N/A Mobo: N/A model: N/A serial: <superuser required> UEFI: U-Boot v: 2021 .04 date: 04 /21/2021 CPU: Info: Quad Core Model N/A [ MCP ] speed: 600 MHz min/max: 600 /1500 MHz Graphics: Device-1: bcm2711-hdmi0 driver: vc4_hdmi v: N/A Device-2: bcm2711-hdmi1 driver: vc4_hdmi v: N/A Device-3: bcm2711-vc5 driver: vc4_drm v: N/A Display: server: No display server data found. Headless machine? tty: 80x24 Message: Unable to show advanced data. Required tool glxinfo missing. Network: Device-1: bcm2835-mmc driver: sdhci_iproc Device-2: bcm2711-genet-v5 driver: bcmgenet Drives: Local Storage: total: 119 GiB used: 4 .35 GiB ( 3 .7% ) Info: Processes: 161 Uptime: 2h 32m Memory: 3 .73 GiB used: 322 MiB ( 8 .4% ) Init: systemd runlevel: 3 Shell: Bash inxi: 3 .3.03 Per mostrare l'output completo del sistema inxi -F Per mostrare solo le informazioni sulla CPU inxi -C CPU: Info: Quad Core model: N/A variant: cortex-a72 bits: 64 type: MCP Speed: 600 MHz min/max: 600 /1500 MHz Core speeds ( MHz ) : 1 : 600 2 : 600 3 : 600 4 : 600 Per mostrare i dispositivi di rete e il driver inxi -N Network: Device-1: bcm2835-mmc driver: sdhci_iproc Device-2: bcm2711-genet-v5 driver: bcmgenet Per visualizzare informazioni avanzate sul dispositivo di rete Interfaccia, velocit\u00e0, ID MAC, stato, ecc. inxi -n Network: Device-1: bcm2835-mmc driver: sdhci_iproc IF: wlan0 state: down mac: 1a:34:8b:77:5f:68 Device-2: bcm2711-genet-v5 driver: bcmgenet IF: eth0 state: up speed: 1000 Mbps duplex: full mac: dc:a6:32:5c:93:a5 Per visualizzare le informazioni sul disco rigido inxi -D Drives: Local Storage: total: 119 GiB used: 4 .35 GiB ( 3 .7% ) ID-1: /dev/mmcblk0 vendor: SanDisk model: SD08G size: 7 .21 GiB ID-2: /dev/sda type: USB vendor: PNY model: CS900 120GB SSD size: 111 .79 GiB Per mostrare i repository configurati sul sistema inxi -r Repos: Active yum repos in : /etc/yum.repos.d/fedora-cisco-openh264.repo 1 : fedora-cisco-openh264 ~ https://mirrors.fedoraproject.org/metalink?repo = fedora-cisco-openh264- $releasever & arch = $basearch Active yum repos in : /etc/yum.repos.d/fedora-modular.repo 1 : fedora-modular ~ https://mirrors.fedoraproject.org/metalink?repo = fedora-modular- $releasever & arch = $basearch Active yum repos in : /etc/yum.repos.d/fedora-updates-modular.repo 1 : updates-modular ~ https://mirrors.fedoraproject.org/metalink?repo = updates-released-modular-f $releasever & arch = $basearch No active yum repos in : /etc/yum.repos.d/fedora-updates-testing-modular.repo No active yum repos in : /etc/yum.repos.d/fedora-updates-testing.repo Active yum repos in : /etc/yum.repos.d/fedora-updates.repo 1 : updates ~ https://mirrors.fedoraproject.org/metalink?repo = updates-released-f $releasever & arch = $basearch Active yum repos in : /etc/yum.repos.d/fedora.repo 1 : fedora ~ https://mirrors.fedoraproject.org/metalink?repo = fedora- $releasever & arch = $basearch Per mostrare le partizioni sul server o sul sistema inxi -p Partition: ID-1: / size: 110 .19 GiB used: 4 .07 GiB ( 3 .7% ) fs: xfs dev: /dev/dm-0 ID-2: /boot size: 1014 MiB used: 262 .5 MiB ( 25 .9% ) fs: xfs dev: /dev/sda2 ID-3: /boot/efi size: 598 .8 MiB used: 29 .4 MiB ( 4 .9% ) fs: vfat dev: /dev/sda1 Per visualizzare i dati della memoria con tutti gli slot disponibili inxi -m Memory: RAM: total: 3 .73 GiB used: 320 .5 MiB ( 8 .4% ) RAM Report: unknown-error: Unknown dmidecode error. Unable to generate data. Per mostrare un breve report dei dati della memoria inxi --memory-short Per mostrare i processi incluso l'utilizzo di CPU e RAM inxi -t Processes: CPU top: 5 of 162 1 : cpu: 0 .2% command: systemd-oomd pid: 723 2 : cpu: 0 .0% command: systemd pid: 1 3 : cpu: 0 .0% command: [ kthreadd ] pid: 2 4 : cpu: 0 .0% command: [ rcu_gp ] pid: 3 5 : cpu: 0 .0% command: [ rcu_par_gp ] pid: 4 System RAM: total: 3 .73 GiB used: 319 .9 MiB ( 8 .4% ) Memory top: 5 of 162 1 : mem: 39 .1 MiB ( 1 .0% ) command: python3 pid: 762 2 : mem: 37 .5 MiB ( 0 .9% ) command: sssd_nss pid: 793 3 : mem: 24 .5 MiB ( 0 .6% ) command: php-fpm: pid: 814 4 : mem: 22 .0 MiB ( 0 .5% ) command: polkitd pid: 895 5 : mem: 21 .0 MiB ( 0 .5% ) command: abrt-dump-journal-oops pid: 789 Se vuoi mostrare i primi 10 processi che consumano CPU e RAM inxi -t cm10 Processes: CPU top: 10 of 162 1 : cpu: 0 .2% command: systemd-oomd pid: 723 2 : cpu: 0 .0% command: systemd pid: 1 3 : cpu: 0 .0% command: [ kthreadd ] pid: 2 4 : cpu: 0 .0% command: [ rcu_gp ] pid: 3 5 : cpu: 0 .0% command: [ rcu_par_gp ] pid: 4 6 : cpu: 0 .0% command: [ mm_percpu_wq ] pid: 8 7 : cpu: 0 .0% command: [ rcu_tasks_kthre ] pid: 9 8 : cpu: 0 .0% command: [ rcu_tasks_rude_ ] pid: 10 9 : cpu: 0 .0% command: [ rcu_tasks_trace ] pid: 11 10 : cpu: 0 .0% command: [ ksoftirqd/0 ] pid: 12 System RAM: total: 3 .73 GiB used: 320 .4 MiB ( 8 .4% ) Memory top: 10 of 162 1 : mem: 39 .1 MiB ( 1 .0% ) command: python3 pid: 762 2 : mem: 37 .5 MiB ( 0 .9% ) command: sssd_nss pid: 793 3 : mem: 24 .5 MiB ( 0 .6% ) command: php-fpm: pid: 814 4 : mem: 22 .0 MiB ( 0 .5% ) command: polkitd pid: 895 5 : mem: 21 .0 MiB ( 0 .5% ) command: abrt-dump-journal-oops pid: 789 6 : mem: 19 .3 MiB ( 0 .5% ) command: networkmanager pid: 796 7 : mem: 18 .9 MiB ( 0 .4% ) command: systemd-journald pid: 608 8 : mem: 18 .5 MiB ( 0 .4% ) command: abrt-dump-journal-xorg pid: 790 9 : mem: 17 .6 MiB ( 0 .4% ) command: systemd-resolved pid: 725 10 : mem: 16 .9 MiB ( 0 .4% ) command: abrt-dump-journal-core pid: 788 Per mostrare i dispositivi USB sul sistema inxi -J USB: Hub-1: 1 -0:1 info: Full speed ( or root ) Hub ports: 1 rev: 2 .0 Hub-2: 1 -1:2 info: VIA Labs Hub ports: 4 rev: 2 .1 Hub-3: 2 -0:1 info: Full speed ( or root ) Hub ports: 4 rev: 3 .0 Device-1: 2 -2:2 info: ASMedia ASM1051E SATA 6Gb/s bridge ASM1053E SATA 6Gb/s bridge ASM1153 SATA 3Gb/s bridge ASM1153E SATA 6Gb/s bridge type: Mass Storage rev: 3 .0 Hub-4: 3 -0:1 info: Full speed ( or root ) Hub ports: 1 rev: 2 .0 Pagina del progetto","title":"Inxi - Info di Sistema"},{"location":"sysadmin/inxi/#scopri-di-piu-sul-tuo-sistema-linux","text":"Raccogli una variet\u00e0 di informazioni di sistema e non con un singolo comando Inxi La raccolta di informazioni sui sistemi GNU/Linux \u00e8 un'attivit\u00e0 essenziale dell'amministratore di sistema. Ci sono molti strumenti che possono aiutare in questo senso. Tuttavia, un comando che pu\u00f2 raccogliere molte informazioni con solo poche opzioni e parametri \u00e8 Inxi . Inxi \u00e8 un'utilit\u00e0 CLI (command line interface) completa che mostra tutti i tipi di informazioni di sistema nella tua console/terminale/shell o nel tuo client IRC. Raccoglie queste informazioni da una variet\u00e0 di fonti sul tuo sistema, cos\u00ec puoi vedere quello che vuoi in un formato facile da usare.","title":"Scopri di pi\u00f9 sul tuo sistema Linux"},{"location":"sysadmin/inxi/#installazione-di-inxi","text":"I sistemi Red Hat Enterprise Linux (RHEL) non hanno inxi installato per impostazione predefinita. \u00c8 disponibile tramite il repository epel-release . Per installare inxi , esegui i seguenti comandi sul tuo sistema Su RHEL 8, e Rocky Linux 8 usa il seguente comando per installare il repository epel dnf install -y epel-release e il comando: dnf install -y inxi Su RHEL 7, installa inxi usando il comando yum: yum install -y epel-release yum install -y inxi Di seguito una sinossi di tutte le opzioni del comando inxi : inxi [-AbBCdDEfFGhiIjJlLmMnNopPrRsSuUVwzZ] quando inxi viene eseguito senza alcuna opzione, visualizza una riga di dati di sistema e la versione di inxi inxi CPU: Quad Core Model N/A ( -MCP- ) speed/min/max: 600 /600/1500 MHz Kernel: 5 .12.11-300.fc34.aarch64 aarch64 Up: 2h 18m Mem: 322 .7/3817.0 MiB ( 8 .5% ) Storage: 119 GiB ( 3 .7% used ) Procs: 165 Shell: Bash inxi: 3 .3.03 Ecco un esempio di output da una Raspberry pi 4 Headless con Fedora Server: inxi -b System: Host: unixlike.ddns.net Kernel: 5 .12.11-300.fc34.aarch64 aarch64 bits: 64 Console: tty pts/0 Distro: Fedora release 34 ( Thirty Four ) Machine: Type: N/A Mobo: N/A model: N/A serial: <superuser required> UEFI: U-Boot v: 2021 .04 date: 04 /21/2021 CPU: Info: Quad Core Model N/A [ MCP ] speed: 600 MHz min/max: 600 /1500 MHz Graphics: Device-1: bcm2711-hdmi0 driver: vc4_hdmi v: N/A Device-2: bcm2711-hdmi1 driver: vc4_hdmi v: N/A Device-3: bcm2711-vc5 driver: vc4_drm v: N/A Display: server: No display server data found. Headless machine? tty: 80x24 Message: Unable to show advanced data. Required tool glxinfo missing. Network: Device-1: bcm2835-mmc driver: sdhci_iproc Device-2: bcm2711-genet-v5 driver: bcmgenet Drives: Local Storage: total: 119 GiB used: 4 .35 GiB ( 3 .7% ) Info: Processes: 161 Uptime: 2h 32m Memory: 3 .73 GiB used: 322 MiB ( 8 .4% ) Init: systemd runlevel: 3 Shell: Bash inxi: 3 .3.03","title":"Installazione di Inxi"},{"location":"sysadmin/inxi/#per-mostrare-loutput-completo-del-sistema","text":"inxi -F","title":"Per mostrare l'output completo del sistema"},{"location":"sysadmin/inxi/#per-mostrare-solo-le-informazioni-sulla-cpu","text":"inxi -C CPU: Info: Quad Core model: N/A variant: cortex-a72 bits: 64 type: MCP Speed: 600 MHz min/max: 600 /1500 MHz Core speeds ( MHz ) : 1 : 600 2 : 600 3 : 600 4 : 600","title":"Per mostrare solo le informazioni sulla CPU"},{"location":"sysadmin/inxi/#per-mostrare-i-dispositivi-di-rete-e-il-driver","text":"inxi -N Network: Device-1: bcm2835-mmc driver: sdhci_iproc Device-2: bcm2711-genet-v5 driver: bcmgenet","title":"Per mostrare i dispositivi di rete e il driver"},{"location":"sysadmin/inxi/#per-visualizzare-informazioni-avanzate-sul-dispositivo-di-rete","text":"Interfaccia, velocit\u00e0, ID MAC, stato, ecc. inxi -n Network: Device-1: bcm2835-mmc driver: sdhci_iproc IF: wlan0 state: down mac: 1a:34:8b:77:5f:68 Device-2: bcm2711-genet-v5 driver: bcmgenet IF: eth0 state: up speed: 1000 Mbps duplex: full mac: dc:a6:32:5c:93:a5","title":"Per visualizzare informazioni avanzate sul dispositivo di rete"},{"location":"sysadmin/inxi/#per-visualizzare-le-informazioni-sul-disco-rigido","text":"inxi -D Drives: Local Storage: total: 119 GiB used: 4 .35 GiB ( 3 .7% ) ID-1: /dev/mmcblk0 vendor: SanDisk model: SD08G size: 7 .21 GiB ID-2: /dev/sda type: USB vendor: PNY model: CS900 120GB SSD size: 111 .79 GiB","title":"Per visualizzare le informazioni sul disco rigido"},{"location":"sysadmin/inxi/#per-mostrare-i-repository-configurati-sul-sistema","text":"inxi -r Repos: Active yum repos in : /etc/yum.repos.d/fedora-cisco-openh264.repo 1 : fedora-cisco-openh264 ~ https://mirrors.fedoraproject.org/metalink?repo = fedora-cisco-openh264- $releasever & arch = $basearch Active yum repos in : /etc/yum.repos.d/fedora-modular.repo 1 : fedora-modular ~ https://mirrors.fedoraproject.org/metalink?repo = fedora-modular- $releasever & arch = $basearch Active yum repos in : /etc/yum.repos.d/fedora-updates-modular.repo 1 : updates-modular ~ https://mirrors.fedoraproject.org/metalink?repo = updates-released-modular-f $releasever & arch = $basearch No active yum repos in : /etc/yum.repos.d/fedora-updates-testing-modular.repo No active yum repos in : /etc/yum.repos.d/fedora-updates-testing.repo Active yum repos in : /etc/yum.repos.d/fedora-updates.repo 1 : updates ~ https://mirrors.fedoraproject.org/metalink?repo = updates-released-f $releasever & arch = $basearch Active yum repos in : /etc/yum.repos.d/fedora.repo 1 : fedora ~ https://mirrors.fedoraproject.org/metalink?repo = fedora- $releasever & arch = $basearch","title":"Per mostrare i repository configurati sul sistema"},{"location":"sysadmin/inxi/#per-mostrare-le-partizioni-sul-server-o-sul-sistema","text":"inxi -p Partition: ID-1: / size: 110 .19 GiB used: 4 .07 GiB ( 3 .7% ) fs: xfs dev: /dev/dm-0 ID-2: /boot size: 1014 MiB used: 262 .5 MiB ( 25 .9% ) fs: xfs dev: /dev/sda2 ID-3: /boot/efi size: 598 .8 MiB used: 29 .4 MiB ( 4 .9% ) fs: vfat dev: /dev/sda1","title":"Per mostrare le partizioni sul server o sul sistema"},{"location":"sysadmin/inxi/#per-visualizzare-i-dati-della-memoria-con-tutti-gli-slot-disponibili","text":"inxi -m Memory: RAM: total: 3 .73 GiB used: 320 .5 MiB ( 8 .4% ) RAM Report: unknown-error: Unknown dmidecode error. Unable to generate data.","title":"Per visualizzare i dati della memoria con tutti gli slot disponibili"},{"location":"sysadmin/inxi/#per-mostrare-un-breve-report-dei-dati-della-memoria","text":"inxi --memory-short","title":"Per mostrare un breve report dei dati della memoria"},{"location":"sysadmin/inxi/#per-mostrare-i-processi-incluso-lutilizzo-di-cpu-e-ram","text":"inxi -t Processes: CPU top: 5 of 162 1 : cpu: 0 .2% command: systemd-oomd pid: 723 2 : cpu: 0 .0% command: systemd pid: 1 3 : cpu: 0 .0% command: [ kthreadd ] pid: 2 4 : cpu: 0 .0% command: [ rcu_gp ] pid: 3 5 : cpu: 0 .0% command: [ rcu_par_gp ] pid: 4 System RAM: total: 3 .73 GiB used: 319 .9 MiB ( 8 .4% ) Memory top: 5 of 162 1 : mem: 39 .1 MiB ( 1 .0% ) command: python3 pid: 762 2 : mem: 37 .5 MiB ( 0 .9% ) command: sssd_nss pid: 793 3 : mem: 24 .5 MiB ( 0 .6% ) command: php-fpm: pid: 814 4 : mem: 22 .0 MiB ( 0 .5% ) command: polkitd pid: 895 5 : mem: 21 .0 MiB ( 0 .5% ) command: abrt-dump-journal-oops pid: 789","title":"Per mostrare i processi incluso l'utilizzo di CPU e RAM"},{"location":"sysadmin/inxi/#se-vuoi-mostrare-i-primi-10-processi-che-consumano-cpu-e-ram","text":"inxi -t cm10 Processes: CPU top: 10 of 162 1 : cpu: 0 .2% command: systemd-oomd pid: 723 2 : cpu: 0 .0% command: systemd pid: 1 3 : cpu: 0 .0% command: [ kthreadd ] pid: 2 4 : cpu: 0 .0% command: [ rcu_gp ] pid: 3 5 : cpu: 0 .0% command: [ rcu_par_gp ] pid: 4 6 : cpu: 0 .0% command: [ mm_percpu_wq ] pid: 8 7 : cpu: 0 .0% command: [ rcu_tasks_kthre ] pid: 9 8 : cpu: 0 .0% command: [ rcu_tasks_rude_ ] pid: 10 9 : cpu: 0 .0% command: [ rcu_tasks_trace ] pid: 11 10 : cpu: 0 .0% command: [ ksoftirqd/0 ] pid: 12 System RAM: total: 3 .73 GiB used: 320 .4 MiB ( 8 .4% ) Memory top: 10 of 162 1 : mem: 39 .1 MiB ( 1 .0% ) command: python3 pid: 762 2 : mem: 37 .5 MiB ( 0 .9% ) command: sssd_nss pid: 793 3 : mem: 24 .5 MiB ( 0 .6% ) command: php-fpm: pid: 814 4 : mem: 22 .0 MiB ( 0 .5% ) command: polkitd pid: 895 5 : mem: 21 .0 MiB ( 0 .5% ) command: abrt-dump-journal-oops pid: 789 6 : mem: 19 .3 MiB ( 0 .5% ) command: networkmanager pid: 796 7 : mem: 18 .9 MiB ( 0 .4% ) command: systemd-journald pid: 608 8 : mem: 18 .5 MiB ( 0 .4% ) command: abrt-dump-journal-xorg pid: 790 9 : mem: 17 .6 MiB ( 0 .4% ) command: systemd-resolved pid: 725 10 : mem: 16 .9 MiB ( 0 .4% ) command: abrt-dump-journal-core pid: 788","title":"Se vuoi mostrare i primi 10 processi che consumano CPU e RAM"},{"location":"sysadmin/inxi/#per-mostrare-i-dispositivi-usb-sul-sistema","text":"inxi -J USB: Hub-1: 1 -0:1 info: Full speed ( or root ) Hub ports: 1 rev: 2 .0 Hub-2: 1 -1:2 info: VIA Labs Hub ports: 4 rev: 2 .1 Hub-3: 2 -0:1 info: Full speed ( or root ) Hub ports: 4 rev: 3 .0 Device-1: 2 -2:2 info: ASMedia ASM1051E SATA 6Gb/s bridge ASM1053E SATA 6Gb/s bridge ASM1153 SATA 3Gb/s bridge ASM1153E SATA 6Gb/s bridge type: Mass Storage rev: 3 .0 Hub-4: 3 -0:1 info: Full speed ( or root ) Hub ports: 1 rev: 2 .0 Pagina del progetto","title":"Per mostrare i dispositivi USB sul sistema"},{"location":"sysadmin/kakoune/","tags":["sysadmin","linux","freebsd"],"text":"L'editor di testo Vi \u00e8 in giro da molto tempo, ha molti fan e utenti, e viene fornito con quasi tutti i sistemi POSIX disponibili. A suo credito, Vi non \u00e8 cambiato molto, anche se \u00e8 riuscito a ricevere alcuni miglioramenti importanti (infatti, la maggior parte degli utenti Vi usa Vi-improved, o Vim). Una delle cose pi\u00f9 grandi dell'open source \u00e8 il modo in cui pu\u00f2 essere adattato e migliorato, comunque! Cos\u00ec ci si potrebbe chiedere come potrebbe essere Vi se fosse stato inventato oggi. Si pu\u00f2 avere un assaggio di questa linea temporale alternativa con Kakoune, un moderno editor Vi-like che incorpora idee dagli attuali editor cos\u00ec come Vi e Vim. Installare Kakoune Su Fedora, puoi installare Kakoune dal tuo repository: sudo dnf kakoune Su Red Hat Enterprise Linux (RHEL), CentOS 7 e CentOS Stream, Kakoune \u00e8 disponibile dal progetto EPEL. Su FreeBSD \u00e8 presente nell'albero dei ports e pu\u00f2 essere installato con: pkg install kakoune Usare Kakoune Come Vi, Kakoune si apre in una finestra di terminale. Il comando per lanciarlo \u00e8 kak , e potete avviarlo con o senza specificare un file da aprire. Questo comando apre il file test.md in Kakoune o crea il file se non esiste gi\u00e0: kak test.md Modifica modale Kakoune ha due modalit\u00e0: modalit\u00e0 normale e modalit\u00e0 inserimento. Il suo stato predefinito \u00e8 la modalit\u00e0 normale, ed \u00e8 il modo in cui si interagisce con Kakoune come applicazione, come si userebbe un mouse per interagire con le applicazioni GUI. In Kakoune, tutta l'interazione avviene con la tastiera, sia che tu stia muovendo il cursore su o gi\u00f9 per una linea, cancellando un carattere (o una parola o una linea), copiando e incollando, e qualsiasi altra cosa che potresti fare in un editor di testo a parte l'inserimento del testo. Per entrare in modalit\u00e0 inserimento, premete il tasto i. In modalit\u00e0 inserimento, digitate e modificate il testo come fareste in qualsiasi altro editor. A differenza di Vi, Kakoune favorisce la tastiera moderna, quindi tasti come Home e Fine e tutti i tasti freccia sono considerati tasti standard per azioni comuni come spostarsi all'inizio o alla fine di una riga. Non c'\u00e8 molto da imparare sulla modalit\u00e0 di inserimento. Inserite del testo, e potreste anche essere in Gedit. Selezionare il testo Kakoune ha sempre del testo attivamente selezionato, anche quando \u00e8 largo solo un carattere (nel qual caso il vostro cursore \u00e8 anche la vostra selezione). Alcuni compiti di navigazione, come saltare all'inizio o alla fine di una parola, implicano una selezione maggiore. Combinando la navigazione comune con la selezione, Kakoune \u00e8 spesso un passo avanti a te. Considerate questo: Quando saltate avanti una parola, potreste semplicemente saltare avanti una parola, nel qual caso una selezione non \u00e8 importante. Tuttavia, a volte, quando si salta in avanti una parola, \u00e8 perch\u00e9 \u00e8 necessario selezionare quella parola in modo da poterla copiare o rimuovere. In questi casi, Kakoune vi risparmia la fatica di selezionare un oggetto perch\u00e9 il metodo di navigazione lo ha gi\u00e0 fatto. Kakoune chiama i due bordi di una sezione il cursore e l' ancora . Assistente Paperclip Kakoune presenta una graffetta antropomorfa come assistente di editing. Quando si impartiscono i comandi in Kakoune, il vostro assistente graffetta appare e vi dice tutte i potenziali completamenti per il comando che avete digitato. Se avete avuto precedenti esperienze negative con gli assistenti paperclip, non preoccupatevi. La graffetta di Kakoune \u00e8 in realt\u00e0 molto utile e dinamica. Si tratta di un avviso pop-up che scompare una volta che il comando \u00e8 sufficientemente unico o completo. Scorciatoie da tastiera A differenza della modalit\u00e0 inserimento, la modalit\u00e0 normale ha molte scorciatoie da tastiera e comandi da imparare. Potete impararli tutti o solo l'essenziale. Sono progettati specificamente per consentire di fare di pi\u00f9 con meno pressioni di tasti. Modalit\u00e0 ESC: modo normale i: modalit\u00e0 di inserimento I (\u00e8 una i maiuscola): inserisce il testo all'inizio della linea corrente a: aggiunge del testo dopo il cursore A: aggiunge del testo alla fine della linea corrente Navigazione La navigazione in modalit\u00e0 normale pu\u00f2 avvenire sulla riga iniziale della vostra tastiera QWERTY: h o Freccia sinistra: cursore a sinistra j o Freccia gi\u00f9: cursore gi\u00f9 (j sembra banalmente una freccia gi\u00f9) o Freccia su: cursore su l (\u00e8 una L minuscola) o Right arrow: cursore a destra b: cursore all'inizio della parola corrente, ancora alla fine e: cursore alla fine della parola corrente, ancora all'inizio Home: va all'inizio di una riga End: va alla fine di una riga gg: va alla prima riga del file Gk: cursore alla prima riga del file, ancora alla fine Ge: cursore all'ultima riga del file, ancoraggio all'inizio 7g: va alla linea 7 del file Copia e incolla y: copiare (\"strattonare\") la selezione p: incolla` Elimina x: cancella carattere dw: cancella parola d$: cancella dalla posizione corrente alla fine di una riga d0: cancella dalla posizione corrente all'inizio di una riga dG: cancella fino all'ultima riga di un file Annulla u: annulla Salva :w: salvare :wq o :ZZ: salvare e uscire :q!: forzare l'uscita senza salvare Prova Kakoune Kakoune \u00e8 un approccio interessante e progressivo ad un classico editor di testo. \u00c8 diverso da Vim, in particolare nel modo in cui tratta la navigazione essenzialmente allo stesso modo della selezione e in molte delle sue scorciatoie da tastiera. Tuttavia, se sei un fan di Vim alla ricerca di qualcosa di nuovo da provare, dovresti considerare Kakoune. Pagina Ufficiale","title":"Kakoune - moderno VI"},{"location":"sysadmin/kakoune/#installare-kakoune","text":"Su Fedora, puoi installare Kakoune dal tuo repository: sudo dnf kakoune Su Red Hat Enterprise Linux (RHEL), CentOS 7 e CentOS Stream, Kakoune \u00e8 disponibile dal progetto EPEL. Su FreeBSD \u00e8 presente nell'albero dei ports e pu\u00f2 essere installato con: pkg install kakoune","title":"Installare Kakoune"},{"location":"sysadmin/kakoune/#usare-kakoune","text":"Come Vi, Kakoune si apre in una finestra di terminale. Il comando per lanciarlo \u00e8 kak , e potete avviarlo con o senza specificare un file da aprire. Questo comando apre il file test.md in Kakoune o crea il file se non esiste gi\u00e0: kak test.md","title":"Usare Kakoune"},{"location":"sysadmin/kakoune/#modifica-modale","text":"Kakoune ha due modalit\u00e0: modalit\u00e0 normale e modalit\u00e0 inserimento. Il suo stato predefinito \u00e8 la modalit\u00e0 normale, ed \u00e8 il modo in cui si interagisce con Kakoune come applicazione, come si userebbe un mouse per interagire con le applicazioni GUI. In Kakoune, tutta l'interazione avviene con la tastiera, sia che tu stia muovendo il cursore su o gi\u00f9 per una linea, cancellando un carattere (o una parola o una linea), copiando e incollando, e qualsiasi altra cosa che potresti fare in un editor di testo a parte l'inserimento del testo. Per entrare in modalit\u00e0 inserimento, premete il tasto i. In modalit\u00e0 inserimento, digitate e modificate il testo come fareste in qualsiasi altro editor. A differenza di Vi, Kakoune favorisce la tastiera moderna, quindi tasti come Home e Fine e tutti i tasti freccia sono considerati tasti standard per azioni comuni come spostarsi all'inizio o alla fine di una riga. Non c'\u00e8 molto da imparare sulla modalit\u00e0 di inserimento. Inserite del testo, e potreste anche essere in Gedit.","title":"Modifica modale"},{"location":"sysadmin/kakoune/#selezionare-il-testo","text":"Kakoune ha sempre del testo attivamente selezionato, anche quando \u00e8 largo solo un carattere (nel qual caso il vostro cursore \u00e8 anche la vostra selezione). Alcuni compiti di navigazione, come saltare all'inizio o alla fine di una parola, implicano una selezione maggiore. Combinando la navigazione comune con la selezione, Kakoune \u00e8 spesso un passo avanti a te. Considerate questo: Quando saltate avanti una parola, potreste semplicemente saltare avanti una parola, nel qual caso una selezione non \u00e8 importante. Tuttavia, a volte, quando si salta in avanti una parola, \u00e8 perch\u00e9 \u00e8 necessario selezionare quella parola in modo da poterla copiare o rimuovere. In questi casi, Kakoune vi risparmia la fatica di selezionare un oggetto perch\u00e9 il metodo di navigazione lo ha gi\u00e0 fatto. Kakoune chiama i due bordi di una sezione il cursore e l' ancora .","title":"Selezionare il testo"},{"location":"sysadmin/kakoune/#assistente-paperclip","text":"Kakoune presenta una graffetta antropomorfa come assistente di editing. Quando si impartiscono i comandi in Kakoune, il vostro assistente graffetta appare e vi dice tutte i potenziali completamenti per il comando che avete digitato. Se avete avuto precedenti esperienze negative con gli assistenti paperclip, non preoccupatevi. La graffetta di Kakoune \u00e8 in realt\u00e0 molto utile e dinamica. Si tratta di un avviso pop-up che scompare una volta che il comando \u00e8 sufficientemente unico o completo.","title":"Assistente Paperclip"},{"location":"sysadmin/kakoune/#scorciatoie-da-tastiera","text":"A differenza della modalit\u00e0 inserimento, la modalit\u00e0 normale ha molte scorciatoie da tastiera e comandi da imparare. Potete impararli tutti o solo l'essenziale. Sono progettati specificamente per consentire di fare di pi\u00f9 con meno pressioni di tasti.","title":"Scorciatoie da tastiera"},{"location":"sysadmin/kakoune/#modalita","text":"ESC: modo normale i: modalit\u00e0 di inserimento I (\u00e8 una i maiuscola): inserisce il testo all'inizio della linea corrente a: aggiunge del testo dopo il cursore A: aggiunge del testo alla fine della linea corrente","title":"Modalit\u00e0"},{"location":"sysadmin/kakoune/#navigazione","text":"La navigazione in modalit\u00e0 normale pu\u00f2 avvenire sulla riga iniziale della vostra tastiera QWERTY: h o Freccia sinistra: cursore a sinistra j o Freccia gi\u00f9: cursore gi\u00f9 (j sembra banalmente una freccia gi\u00f9) o Freccia su: cursore su l (\u00e8 una L minuscola) o Right arrow: cursore a destra b: cursore all'inizio della parola corrente, ancora alla fine e: cursore alla fine della parola corrente, ancora all'inizio Home: va all'inizio di una riga End: va alla fine di una riga gg: va alla prima riga del file Gk: cursore alla prima riga del file, ancora alla fine Ge: cursore all'ultima riga del file, ancoraggio all'inizio 7g: va alla linea 7 del file","title":"Navigazione"},{"location":"sysadmin/kakoune/#copia-e-incolla","text":"y: copiare (\"strattonare\") la selezione p: incolla`","title":"Copia e incolla"},{"location":"sysadmin/kakoune/#elimina","text":"x: cancella carattere dw: cancella parola d$: cancella dalla posizione corrente alla fine di una riga d0: cancella dalla posizione corrente all'inizio di una riga dG: cancella fino all'ultima riga di un file","title":"Elimina"},{"location":"sysadmin/kakoune/#annulla","text":"u: annulla","title":"Annulla"},{"location":"sysadmin/kakoune/#salva","text":":w: salvare :wq o :ZZ: salvare e uscire :q!: forzare l'uscita senza salvare","title":"Salva"},{"location":"sysadmin/kakoune/#prova-kakoune","text":"Kakoune \u00e8 un approccio interessante e progressivo ad un classico editor di testo. \u00c8 diverso da Vim, in particolare nel modo in cui tratta la navigazione essenzialmente allo stesso modo della selezione e in molte delle sue scorciatoie da tastiera. Tuttavia, se sei un fan di Vim alla ricerca di qualcosa di nuovo da provare, dovresti considerare Kakoune. Pagina Ufficiale","title":"Prova Kakoune"},{"location":"sysadmin/ssh_key/","text":"","title":"Ssh key"},{"location":"terminologia/01_upstream_downstream/","tags":["software","opensource"],"text":"Cos'\u00e8 Upstream e Downstream nello sviluppo del software? Molto spesso le definizione delle parole Upstream (a monte) e Downstream (a valle) creano confusione nei vari contesti di sviluppo del software. Per questo cercheremo di fare un p\u00f2 di chiarezza a riguardo. Partiamo da un processo generico di produzione, anche se non ha niente a che fare con lo sviluppo del software \u00e8 una buona base di partenza per la comprensione dei concetti. A monte e a valle in un processo di produzione Passi del processo da monte a valle graph LR A[\\Raccolta/]-->B[Assemblaggio]-->C((Finitura)); Nel nostro esempio di processo, abbiamo tre passaggi: raccolta delle parti assemblaggio delle parti finitura dell'assemblaggio Un processo di produzione \u00e8 molto simile a un fiume, quindi \u00e8 facile capire che mentre il processo va da un passaggio al successivo, ci stiamo muovendo verso valle. Possiamo quindi ricavare le seguenti regole: Regola della dipendenza: ogni elemento dipende da tutti gli elementi a monte dal suo punto di vista Regola del valore: muovendosi a valle, ogni passo aggiunge pi\u00f9 valore al prodotto Ora, proviamo ad applicare queste regole a diversi contesti di sviluppo del software. Dipendenze del software La maggior parte dei componenti software hanno dipendenze da altri componenti. Quindi cos'\u00e8 una dipendenza a monte e una dipendenza a valle? Considerate questa figura: graph LR A([Componente A])--->B([Componente B]) ---> C([Componente C]); Il componente C dipende dal componente B che a sua volta dipende dal componente A. Applicando la Regola della Dipendenza , possiamo tranquillamente dire che il componente A \u00e8 a monte del componente B che \u00e8 a monte del componente C. Applicare la Regola del Valore qui \u00e8 un po' pi\u00f9 astratto, ma possiamo dire che il componente C detiene il maggior valore poich\u00e9 \"importa\" tutte le caratteristiche dei componenti B e A e aggiunge il proprio valore a quelle caratteristiche, rendendolo il componente a valle. Progetti Open Source Un altro contesto in cui le parole Upstream e Downstream sono molto usate \u00e8 nello sviluppo open source. In realt\u00e0 \u00e8 molto simile alle dipendenze dei componenti discusse sopra. Consideriamo i progetti A e B, dove A \u00e8 un progetto originale e B \u00e8 un fork di A: graph LR A([Progetto A])-- fork -->B([Progetto B])-->C([Patch e Fix]); C -- Push Request --> A Questo \u00e8 uno stile di sviluppo piuttosto comune nei progetti open source: si crea un fork di un progetto, si corregge un bug o si aggiunge una caratteristica in quel fork e poi si invia una patch al progetto originale. In questo contesto, la regola della dipendenza rende il progetto A il progetto a monte, poich\u00e9 pu\u00f2 benissimo vivere senza il progetto B, ma il progetto B (il fork) non esisterebbe nemmeno senza il progetto A (il progetto originale). Si applica anche la Regola del Valore: poich\u00e9 il progetto B aggiunge una nuova caratteristica o un bugfix, aggiungendo valore al progetto originale A. Cos\u00ec, ogni volta che contribuiamo con una patch ad un progetto open source possiamo dire che abbiamo inviato una patch a monte. In ogni contesto in cui si usa il concetto di Upstream e Downstream , possiamo applicare due semplici regole per scoprire quale elemento \u00e8 a monte o a valle di un altro. Se un elemento aggiunge valore ad un altro o dipende da esso in qualsiasi altro modo, \u00e8 quasi certamente a valle. Termini Upstream e Downstream sono termini non molto usati dagli utilizzatori di computer. Se sei un utente di Linux e non scrivi o mantieni software, ci sono buone probabilit\u00e0 che questi termini non significhino nulla per te, ma possono essere istruttivi su come funziona la comunicazione tra gruppi all'interno del mondo Linux. I termini sono usati nel networking, nella programmazione, nel kernel, e anche in aree non informatiche come le catene di approvvigionamento. Quando si parla di Upstream e Downstream quindi, il contesto \u00e8 importante. Nella sua forma pi\u00f9 semplice, upstream e downstream sono la direzione del flusso di informazioni. Che i dati siano a monte o a valle \u00e8 probabilmente poco importante per noi come utenti, ma \u00e8 importante per gli amministratori di server che controllano l'uso della larghezza di banda, cos\u00ec come per i distributori e i programmatori di applicazioni. Nel mondo Linux, upstream e downstream hanno due contesti principali. Uno riguarda il kernel e l'altro le applicazioni . Ce ne sono altri, ma per ora ci soffermeremo su questi due. Upstream e downstream nel contesto del kernel Linux Linux \u00e8 il kernel. Nel creare una distribuzione (spesso chiamata \"distro\"), le distribuzioni Linux inizialmente usano il codice sorgente di un kernel non modificato. Le patch necessarie vengono aggiunte e poi il kernel viene configurato. La configurazione del kernel \u00e8 basata su quali caratteristiche e opzioni la distribuzione vuole offrire. Una volta deciso, il kernel viene creato di conseguenza. Il kernel originale \u00e8 a monte della distribuzione. Quando la distribuzione ottiene il codice sorgente, questo scorre a valle. Una volta che la distribuzione ha il codice, esso rimane con i creatori della distribuzione mentre si lavora su di esso. \u00c8 ancora a monte rispetto a noi, come utenti, finch\u00e9 non \u00e8 pronto per il rilascio. La versione del kernel che la distribuzione crea avr\u00e0 patch aggiunte e certe caratteristiche e opzioni abilitate. Questa configurazione \u00e8 determinata dallo sviluppatore della distro. Questo \u00e8 il motivo per cui ci sono diverse versioni di Linux: Debian contro Red Hat, per esempio. Lo sviluppatore della distro decide le opzioni da offrire alla propria base di utenti, e compila il kernel di conseguenza. Una volta che quel lavoro \u00e8 completato, viene reso pronto per il rilascio in un repository e ci \u00e8 permesso di prenderne una copia. Quella copia scorre a valle fino a noi. Allo stesso modo, se il distributore trova un bug nel kernel, lo corregge e poi manda la patch agli sviluppatori del kernel in modo che possano correggere il kernel per tutti quelli a valle. Questo si chiama contribuire all'upstream perch\u00e9 qui il flusso va verso l'alto fino alla fonte originale. Upstream e downstream nel contesto delle applicazioni Di nuovo, tecnicamente, Linux \u00e8 il kernel, tutto il resto \u00e8 software aggiuntivo. Il costruttore della distro aggiunge anche software aggiuntivo al suo progetto. In questo caso, ci sono diversi software aggiuntivi. Una distro pu\u00f2 contenere qualsiasi numero di applicazioni come X, KDE, Gnome, e cos\u00ec via. Immaginiamo che stiate usando l'editor nano e scopriate che non funziona bene, quindi inviate una segnalazione di bug al distributore. I programmatori che lavorano alla distro lo guarderanno e, se trovano che hanno inserito un bug in nano, lo correggeranno e renderanno disponibile una nuova versione nel loro repository. Se trovano che non hanno inserito il bug, il distributore invier\u00e0 un bug report a monte al programmatore di nano. Quando si tratta di cose come segnalazioni di bug, richieste di caratteristiche, ecc. \u00e8 sempre meglio inviarle a monte al vostro distributore, dato che loro mantengono il kernel e le applicazioni aggiuntive per la distro che state usando. Una volta sistemato, il programma aggiornato viene messo in un repository a vostra disposizione. Quando ricevi l'aggiornamento, ti arriva a valle, in questo modo: Se un distributore fa la correzione, la nuova versione \u00e8 resa disponibile nel repository della distribuzione Se il programmatore dell'applicazione fa la correzione, questa viene inviata a valle ai distributori che testano il nuovo codice. Una volta trovato che funziona bene, viene messo nel repository, per fluire a valle fino a te Flusso automatico C'\u00e8 stato un tempo in cui gli utenti dovevano ottenere i propri aggiornamenti. Un utente otteneva il codice sorgente aggiornato e compilava un nuovo eseguibile. Con il passare del tempo, utility come dnf o apt sono state create per permettere agli utenti di estrarre i binari aggiornati (eseguibili) dai repository. Programmi come dnf si occupano del lavoro upstream/downstream . Se hai eseguito dnf con l'opzione di aggiornamento in questo modo: dnf update cercher\u00e0 (a monte) il repository della distro, trover\u00e0 tutti i pacchetti aggiornati necessari e li scaricher\u00e0 (a valle) sulla tua macchina e li installer\u00e0. Conclusione A monte e a valle \u00e8 davvero solo la direzione del flusso di dati. Quanto a monte o a valle questi dati fluiscono dipende da chi alla fine ha bisogno di lavorarci. Fondamentalmente, i programmatori sono a monte e gli utenti sono a valle. Di nuovo, come utenti, non abbiamo davvero bisogno di preoccuparci di questi termini, ma i concetti aiutano nello sviluppo e nella manutenzione del software. Essendo in grado di indirizzare il lavoro al gruppo appropriato, si evita il lavoro duplicato. Assicura anche il mantenimento di uno standard. Se trovate un bug su qualsiasi programma nella vostra distro, segnalatelo semplicemente ai manutentori della vostra distro, cosa che di solito si fa attraverso il loro sito web. Lo invierete a monte a loro, ma non importa se non vi ricordate che state inviando la segnalazione a monte .","title":"Upstream - Downstream"},{"location":"terminologia/01_upstream_downstream/#cose-upstream-e-downstream-nello-sviluppo-del-software","text":"Molto spesso le definizione delle parole Upstream (a monte) e Downstream (a valle) creano confusione nei vari contesti di sviluppo del software. Per questo cercheremo di fare un p\u00f2 di chiarezza a riguardo. Partiamo da un processo generico di produzione, anche se non ha niente a che fare con lo sviluppo del software \u00e8 una buona base di partenza per la comprensione dei concetti.","title":"Cos'\u00e8 Upstream e Downstream nello sviluppo del software?"},{"location":"terminologia/01_upstream_downstream/#a-monte-e-a-valle-in-un-processo-di-produzione","text":"","title":"A monte e a valle in un processo di produzione"},{"location":"terminologia/01_upstream_downstream/#passi-del-processo-da-monte-a-valle","text":"graph LR A[\\Raccolta/]-->B[Assemblaggio]-->C((Finitura)); Nel nostro esempio di processo, abbiamo tre passaggi: raccolta delle parti assemblaggio delle parti finitura dell'assemblaggio Un processo di produzione \u00e8 molto simile a un fiume, quindi \u00e8 facile capire che mentre il processo va da un passaggio al successivo, ci stiamo muovendo verso valle. Possiamo quindi ricavare le seguenti regole: Regola della dipendenza: ogni elemento dipende da tutti gli elementi a monte dal suo punto di vista Regola del valore: muovendosi a valle, ogni passo aggiunge pi\u00f9 valore al prodotto Ora, proviamo ad applicare queste regole a diversi contesti di sviluppo del software.","title":"Passi del processo da monte a valle"},{"location":"terminologia/01_upstream_downstream/#dipendenze-del-software","text":"La maggior parte dei componenti software hanno dipendenze da altri componenti. Quindi cos'\u00e8 una dipendenza a monte e una dipendenza a valle? Considerate questa figura: graph LR A([Componente A])--->B([Componente B]) ---> C([Componente C]); Il componente C dipende dal componente B che a sua volta dipende dal componente A. Applicando la Regola della Dipendenza , possiamo tranquillamente dire che il componente A \u00e8 a monte del componente B che \u00e8 a monte del componente C. Applicare la Regola del Valore qui \u00e8 un po' pi\u00f9 astratto, ma possiamo dire che il componente C detiene il maggior valore poich\u00e9 \"importa\" tutte le caratteristiche dei componenti B e A e aggiunge il proprio valore a quelle caratteristiche, rendendolo il componente a valle.","title":"Dipendenze del software"},{"location":"terminologia/01_upstream_downstream/#progetti-open-source","text":"Un altro contesto in cui le parole Upstream e Downstream sono molto usate \u00e8 nello sviluppo open source. In realt\u00e0 \u00e8 molto simile alle dipendenze dei componenti discusse sopra. Consideriamo i progetti A e B, dove A \u00e8 un progetto originale e B \u00e8 un fork di A: graph LR A([Progetto A])-- fork -->B([Progetto B])-->C([Patch e Fix]); C -- Push Request --> A Questo \u00e8 uno stile di sviluppo piuttosto comune nei progetti open source: si crea un fork di un progetto, si corregge un bug o si aggiunge una caratteristica in quel fork e poi si invia una patch al progetto originale. In questo contesto, la regola della dipendenza rende il progetto A il progetto a monte, poich\u00e9 pu\u00f2 benissimo vivere senza il progetto B, ma il progetto B (il fork) non esisterebbe nemmeno senza il progetto A (il progetto originale). Si applica anche la Regola del Valore: poich\u00e9 il progetto B aggiunge una nuova caratteristica o un bugfix, aggiungendo valore al progetto originale A. Cos\u00ec, ogni volta che contribuiamo con una patch ad un progetto open source possiamo dire che abbiamo inviato una patch a monte. In ogni contesto in cui si usa il concetto di Upstream e Downstream , possiamo applicare due semplici regole per scoprire quale elemento \u00e8 a monte o a valle di un altro. Se un elemento aggiunge valore ad un altro o dipende da esso in qualsiasi altro modo, \u00e8 quasi certamente a valle.","title":"Progetti Open Source"},{"location":"terminologia/01_upstream_downstream/#termini","text":"Upstream e Downstream sono termini non molto usati dagli utilizzatori di computer. Se sei un utente di Linux e non scrivi o mantieni software, ci sono buone probabilit\u00e0 che questi termini non significhino nulla per te, ma possono essere istruttivi su come funziona la comunicazione tra gruppi all'interno del mondo Linux. I termini sono usati nel networking, nella programmazione, nel kernel, e anche in aree non informatiche come le catene di approvvigionamento. Quando si parla di Upstream e Downstream quindi, il contesto \u00e8 importante. Nella sua forma pi\u00f9 semplice, upstream e downstream sono la direzione del flusso di informazioni. Che i dati siano a monte o a valle \u00e8 probabilmente poco importante per noi come utenti, ma \u00e8 importante per gli amministratori di server che controllano l'uso della larghezza di banda, cos\u00ec come per i distributori e i programmatori di applicazioni. Nel mondo Linux, upstream e downstream hanno due contesti principali. Uno riguarda il kernel e l'altro le applicazioni . Ce ne sono altri, ma per ora ci soffermeremo su questi due.","title":"Termini"},{"location":"terminologia/01_upstream_downstream/#upstream-e-downstream-nel-contesto-del-kernel-linux","text":"Linux \u00e8 il kernel. Nel creare una distribuzione (spesso chiamata \"distro\"), le distribuzioni Linux inizialmente usano il codice sorgente di un kernel non modificato. Le patch necessarie vengono aggiunte e poi il kernel viene configurato. La configurazione del kernel \u00e8 basata su quali caratteristiche e opzioni la distribuzione vuole offrire. Una volta deciso, il kernel viene creato di conseguenza. Il kernel originale \u00e8 a monte della distribuzione. Quando la distribuzione ottiene il codice sorgente, questo scorre a valle. Una volta che la distribuzione ha il codice, esso rimane con i creatori della distribuzione mentre si lavora su di esso. \u00c8 ancora a monte rispetto a noi, come utenti, finch\u00e9 non \u00e8 pronto per il rilascio. La versione del kernel che la distribuzione crea avr\u00e0 patch aggiunte e certe caratteristiche e opzioni abilitate. Questa configurazione \u00e8 determinata dallo sviluppatore della distro. Questo \u00e8 il motivo per cui ci sono diverse versioni di Linux: Debian contro Red Hat, per esempio. Lo sviluppatore della distro decide le opzioni da offrire alla propria base di utenti, e compila il kernel di conseguenza. Una volta che quel lavoro \u00e8 completato, viene reso pronto per il rilascio in un repository e ci \u00e8 permesso di prenderne una copia. Quella copia scorre a valle fino a noi. Allo stesso modo, se il distributore trova un bug nel kernel, lo corregge e poi manda la patch agli sviluppatori del kernel in modo che possano correggere il kernel per tutti quelli a valle. Questo si chiama contribuire all'upstream perch\u00e9 qui il flusso va verso l'alto fino alla fonte originale.","title":"Upstream e downstream nel contesto del kernel Linux"},{"location":"terminologia/01_upstream_downstream/#upstream-e-downstream-nel-contesto-delle-applicazioni","text":"Di nuovo, tecnicamente, Linux \u00e8 il kernel, tutto il resto \u00e8 software aggiuntivo. Il costruttore della distro aggiunge anche software aggiuntivo al suo progetto. In questo caso, ci sono diversi software aggiuntivi. Una distro pu\u00f2 contenere qualsiasi numero di applicazioni come X, KDE, Gnome, e cos\u00ec via. Immaginiamo che stiate usando l'editor nano e scopriate che non funziona bene, quindi inviate una segnalazione di bug al distributore. I programmatori che lavorano alla distro lo guarderanno e, se trovano che hanno inserito un bug in nano, lo correggeranno e renderanno disponibile una nuova versione nel loro repository. Se trovano che non hanno inserito il bug, il distributore invier\u00e0 un bug report a monte al programmatore di nano. Quando si tratta di cose come segnalazioni di bug, richieste di caratteristiche, ecc. \u00e8 sempre meglio inviarle a monte al vostro distributore, dato che loro mantengono il kernel e le applicazioni aggiuntive per la distro che state usando. Una volta sistemato, il programma aggiornato viene messo in un repository a vostra disposizione. Quando ricevi l'aggiornamento, ti arriva a valle, in questo modo: Se un distributore fa la correzione, la nuova versione \u00e8 resa disponibile nel repository della distribuzione Se il programmatore dell'applicazione fa la correzione, questa viene inviata a valle ai distributori che testano il nuovo codice. Una volta trovato che funziona bene, viene messo nel repository, per fluire a valle fino a te","title":"Upstream e downstream nel contesto delle applicazioni"},{"location":"terminologia/01_upstream_downstream/#flusso-automatico","text":"C'\u00e8 stato un tempo in cui gli utenti dovevano ottenere i propri aggiornamenti. Un utente otteneva il codice sorgente aggiornato e compilava un nuovo eseguibile. Con il passare del tempo, utility come dnf o apt sono state create per permettere agli utenti di estrarre i binari aggiornati (eseguibili) dai repository. Programmi come dnf si occupano del lavoro upstream/downstream . Se hai eseguito dnf con l'opzione di aggiornamento in questo modo: dnf update cercher\u00e0 (a monte) il repository della distro, trover\u00e0 tutti i pacchetti aggiornati necessari e li scaricher\u00e0 (a valle) sulla tua macchina e li installer\u00e0.","title":"Flusso automatico"},{"location":"terminologia/01_upstream_downstream/#conclusione","text":"A monte e a valle \u00e8 davvero solo la direzione del flusso di dati. Quanto a monte o a valle questi dati fluiscono dipende da chi alla fine ha bisogno di lavorarci. Fondamentalmente, i programmatori sono a monte e gli utenti sono a valle. Di nuovo, come utenti, non abbiamo davvero bisogno di preoccuparci di questi termini, ma i concetti aiutano nello sviluppo e nella manutenzione del software. Essendo in grado di indirizzare il lavoro al gruppo appropriato, si evita il lavoro duplicato. Assicura anche il mantenimento di uno standard. Se trovate un bug su qualsiasi programma nella vostra distro, segnalatelo semplicemente ai manutentori della vostra distro, cosa che di solito si fa attraverso il loro sito web. Lo invierete a monte a loro, ma non importa se non vi ricordate che state inviando la segnalazione a monte .","title":"Conclusione"},{"location":"terminologia/03_epel_intro/","tags":["rockylinux","rhel","fedora"],"text":"Gli utenti Linux che utilizzano Fedora probabilmente sanno che lo sviluppo della distro \u00e8 l'upstream per le principali versioni di Red Hat Enterprise Linux (RHEL). Le nuove versioni dei pacchetti o i nuovi pacchetti da inserire in RHEL vengono testati estesamente su Fedora prima di essere inseriti nei repository ufficiali di RHEL (infatti la nuova versione 9.x di RHEL \u00e8 basata sullo sviluppo di Fedora 34). Questo di fatto fa si che i set di pacchetti che Red Hat distribuisce per RHEL siano limitati rispetto a quelli che potete trovare in Fedora. La cosa ha senso, perch\u00e9 c'\u00e8 un sacco di software in Fedora che non \u00e8 necessario in un ambiente aziendale o non rientra nello scopo di RHEL. Red Hat mantiene e supporta i pacchetti in RHEL molto pi\u00f9 a lungo della durata di una release di Fedora, e il software \u00e8 selezionato per essere affidabile e stabile nell'implementazione e nell'utilizzo di RHEL e derivate nell'esecuzione dei loro carichi di lavoro. A volte per\u00f2 \u00e8 necessaria qualche applicazione che \u00e8 disponibile in Fedora ma non in RHEL. Per questo motivo e stato formato EPEL . Extra Packages for Enterprise Linux (EPEL) \u00e8 un gruppo di interesse speciale (SIG) del Fedora Project che fornisce un insieme di pacchetti aggiuntivi per RHEL (e CentOS, Rocky Linux, e altri) dai sorgenti di Fedora. Cos'\u00e8 EPEL e come si usa con le derivate di RHEL? Per portare un pacchetto in EPEL, deve prima esserelo in Fedora. EPEL segue le Fedora Packaging Guidelines per assicurare un'integrazione corretta, e include solo software libero e open source che non \u00e8 gravato da brevetti. Quindi non troverete alcun software proprietario in EPEL o cose come i codec multimediali che sono limitati da brevetti, anche se il software che li abilita \u00e8 sotto una licenza open source. EPEL \u00e8 supportato? Prima di entrare nel \"come\" dovremmo probabilmente affrontare la questione del supporto. EPEL \u00e8 supportato nella migliore tradizione della comunit\u00e0 open source. (\"Se si rompe, puoi tenere entrambi i pezzi\") Vale a dire che EPEL non \u00e8 supportato nel senso in cui lo \u00e8 RHEL. Come la maggior parte dei progetti open source (al contrario dell'open source aziendale), \u00e8 un accordo del tipo \"facciamo quello che possiamo\" che fornisce un sacco di vantaggi per gli utenti, ma senza la garanzia della rapidit\u00e0 nella produzione di aggiornamenti o del supporto. Red Hat non supporta i pacchetti in EPEL o non offre nessun SLA intorno ai bugfix o alle patch per i CVE. \u00c8 anche possibile che i pacchetti in EPEL \"vadano e vengano\" (per usare il linguaggio del progetto) nel corso di una singola release di RHEL. \u00c8 possibile che gli aggiornamenti richiedano l'intervento dell'amministratore. Il progetto EPEL raccomanda agli utenti di EPEL di iscriversi alla mailing list epel-announce per essere al corrente dei prossimi problemi e per avere il tempo di testare prima che l'aggiornamento abbia un impatto. Questo non significa che EPEL non abbia un posto nel vostro ambiente, solo che dovreste considerare dove e come distribuite i pacchetti da EPEL. Cosa \u00e8 incluso in EPEL? EPEL \u00e8 una selezione di pacchetti da Fedora, ma solo pacchetti che non sono in RHEL o nei loro prodotti derivati per evitare conflitti. (Cos\u00ec, per esempio, non troverete in EPEL una versione pi\u00f9 recente di qualcosa che \u00e8 gi\u00e0 presente in RHEL) L'elenco dei pacchetti per EPEL varia a seconda della release e dell'architettura. I pacchetti che sono disponibili per, diciamo, EPEL 7 su x86_64 potrebbero non essere disponibili per EPEL 8 su Power o ARM. Puoi trovare i link ai set di pacchetti sul Fedora Wiki. I pacchetti non sono automaticamente aggiornati da un rilascio all'altro perch\u00e9 i vari manutentori vogliono aggiungere i loro pacchetti solo quando sono pronti a farlo. Questo significa che i pacchetti possono richiedere tempo per entrare in una nuova release come EPEL 8. Attualmente EPEL ha pacchetti per RHEL 6, RHEL 7 e RHEL 8. I pacchetti in EPEL includono cose come i moduli per Python, Perl e altri extra per altri linguaggi di programmazione. Troverete anche utility come etckeeper, ImageMagick e GraphicsMagick, e le build del browser Chromium. (Non \u00e8 una lista completa, ovviamente) Per provare EPEL, ecco da dove si pu\u00f2 iniziare, le istruzioni sono sul Fedora Wiki per ogni release. EPEL non \u00e8 una parte ufficiale dell'universo RHEL o un'offerta ufficiale di Red Hat. Ma pu\u00f2 essere utile per gli amministratori e gli sviluppatori che lavorano con RHEL e hanno bisogno di alcune utility preparate per RHEL da una fonte di cui possono sentirsi sicuri.","title":"EPEL Repository"},{"location":"terminologia/03_epel_intro/#cose-epel-e-come-si-usa-con-le-derivate-di-rhel","text":"Per portare un pacchetto in EPEL, deve prima esserelo in Fedora. EPEL segue le Fedora Packaging Guidelines per assicurare un'integrazione corretta, e include solo software libero e open source che non \u00e8 gravato da brevetti. Quindi non troverete alcun software proprietario in EPEL o cose come i codec multimediali che sono limitati da brevetti, anche se il software che li abilita \u00e8 sotto una licenza open source.","title":"Cos'\u00e8 EPEL e come si usa con le derivate di RHEL?"},{"location":"terminologia/03_epel_intro/#epel-e-supportato","text":"Prima di entrare nel \"come\" dovremmo probabilmente affrontare la questione del supporto. EPEL \u00e8 supportato nella migliore tradizione della comunit\u00e0 open source. (\"Se si rompe, puoi tenere entrambi i pezzi\") Vale a dire che EPEL non \u00e8 supportato nel senso in cui lo \u00e8 RHEL. Come la maggior parte dei progetti open source (al contrario dell'open source aziendale), \u00e8 un accordo del tipo \"facciamo quello che possiamo\" che fornisce un sacco di vantaggi per gli utenti, ma senza la garanzia della rapidit\u00e0 nella produzione di aggiornamenti o del supporto. Red Hat non supporta i pacchetti in EPEL o non offre nessun SLA intorno ai bugfix o alle patch per i CVE. \u00c8 anche possibile che i pacchetti in EPEL \"vadano e vengano\" (per usare il linguaggio del progetto) nel corso di una singola release di RHEL. \u00c8 possibile che gli aggiornamenti richiedano l'intervento dell'amministratore. Il progetto EPEL raccomanda agli utenti di EPEL di iscriversi alla mailing list epel-announce per essere al corrente dei prossimi problemi e per avere il tempo di testare prima che l'aggiornamento abbia un impatto. Questo non significa che EPEL non abbia un posto nel vostro ambiente, solo che dovreste considerare dove e come distribuite i pacchetti da EPEL.","title":"EPEL \u00e8 supportato?"},{"location":"terminologia/03_epel_intro/#cosa-e-incluso-in-epel","text":"EPEL \u00e8 una selezione di pacchetti da Fedora, ma solo pacchetti che non sono in RHEL o nei loro prodotti derivati per evitare conflitti. (Cos\u00ec, per esempio, non troverete in EPEL una versione pi\u00f9 recente di qualcosa che \u00e8 gi\u00e0 presente in RHEL) L'elenco dei pacchetti per EPEL varia a seconda della release e dell'architettura. I pacchetti che sono disponibili per, diciamo, EPEL 7 su x86_64 potrebbero non essere disponibili per EPEL 8 su Power o ARM. Puoi trovare i link ai set di pacchetti sul Fedora Wiki. I pacchetti non sono automaticamente aggiornati da un rilascio all'altro perch\u00e9 i vari manutentori vogliono aggiungere i loro pacchetti solo quando sono pronti a farlo. Questo significa che i pacchetti possono richiedere tempo per entrare in una nuova release come EPEL 8. Attualmente EPEL ha pacchetti per RHEL 6, RHEL 7 e RHEL 8. I pacchetti in EPEL includono cose come i moduli per Python, Perl e altri extra per altri linguaggi di programmazione. Troverete anche utility come etckeeper, ImageMagick e GraphicsMagick, e le build del browser Chromium. (Non \u00e8 una lista completa, ovviamente) Per provare EPEL, ecco da dove si pu\u00f2 iniziare, le istruzioni sono sul Fedora Wiki per ogni release. EPEL non \u00e8 una parte ufficiale dell'universo RHEL o un'offerta ufficiale di Red Hat. Ma pu\u00f2 essere utile per gli amministratori e gli sviluppatori che lavorano con RHEL e hanno bisogno di alcune utility preparate per RHEL da una fonte di cui possono sentirsi sicuri.","title":"Cosa \u00e8 incluso in EPEL?"}]}